1
00:00:05,040 --> 00:00:09,519
 thank you felix

2
00:00:06,309 --> 00:00:09,519
 

3
00:00:06,319 --> 00:00:12,160
 i also wanted to thank uh

4
00:00:09,509 --> 00:00:12,160
 

5
00:00:09,519 --> 00:00:12,880
 jim and charlotte and michael and julie

6
00:00:12,150 --> 00:00:12,880
 

7
00:00:12,160 --> 00:00:16,080
 and melissa

8
00:00:12,870 --> 00:00:16,080
 

9
00:00:12,880 --> 00:00:18,320
 and everybody else at accu who who

10
00:00:16,070 --> 00:00:18,320
 

11
00:00:16,080 --> 00:00:19,600
 helped with all my initial travel

12
00:00:18,310 --> 00:00:19,600
 

13
00:00:18,320 --> 00:00:22,720
 arrangements to get

14
00:00:19,590 --> 00:00:22,720
 

15
00:00:19,600 --> 00:00:25,279
 to accu last year and

16
00:00:22,710 --> 00:00:25,279
 

17
00:00:22,720 --> 00:00:27,119
 helped get me all set up for this year

18
00:00:25,269 --> 00:00:27,119
 

19
00:00:25,279 --> 00:00:28,080
 so and i want to say good morning to all

20
00:00:27,109 --> 00:00:28,080
 

21
00:00:27,119 --> 00:00:31,760
 the attendees

22
00:00:28,070 --> 00:00:31,760
 

23
00:00:28,080 --> 00:00:35,200
 i'm in california right now and it is

24
00:00:31,750 --> 00:00:35,200
 

25
00:00:31,760 --> 00:00:35,840
 8 30 in the morning so i've been around

26
00:00:35,190 --> 00:00:35,840
 

27
00:00:35,200 --> 00:00:38,079
 all week

28
00:00:35,830 --> 00:00:38,079
 

29
00:00:35,840 --> 00:00:39,040
 i gave a workshop at the at the start of

30
00:00:38,069 --> 00:00:39,040
 

31
00:00:38,079 --> 00:00:40,879
 the week

32
00:00:39,030 --> 00:00:40,879
 

33
00:00:39,040 --> 00:00:42,640
 and i've been attending sessions all

34
00:00:40,869 --> 00:00:42,640
 

35
00:00:40,879 --> 00:00:44,719
 week which has been

36
00:00:42,630 --> 00:00:44,719
 

37
00:00:42,640 --> 00:00:46,399
 very early in the morning for me and

38
00:00:44,709 --> 00:00:46,399
 

39
00:00:44,719 --> 00:00:48,239
 have very much enjoyed

40
00:00:46,389 --> 00:00:48,239
 

41
00:00:46,399 --> 00:00:51,760
 the conference so i hope everybody here

42
00:00:48,229 --> 00:00:51,760
 

43
00:00:48,239 --> 00:00:51,760
 has enjoyed it as much as i have

44
00:00:56,709 --> 00:00:56,709
 

45
00:00:56,719 --> 00:01:00,079
 so felix gave me a very nice

46
00:00:59,110 --> 00:01:00,079
 

47
00:00:59,120 --> 00:01:02,160
 introduction

48
00:01:00,069 --> 00:01:02,160
 

49
00:01:00,079 --> 00:01:03,120
 i'm a senior principal scientist these

50
00:01:02,150 --> 00:01:03,120
 

51
00:01:02,160 --> 00:01:06,240
 days working on

52
00:01:03,110 --> 00:01:06,240
 

53
00:01:03,120 --> 00:01:06,479
 on photoshop as felix mentioned i worked

54
00:01:06,230 --> 00:01:06,479
 

55
00:01:06,240 --> 00:01:08,240
 on

56
00:01:06,469 --> 00:01:08,240
 

57
00:01:06,479 --> 00:01:10,960
 photoshop mobile i've had a fairly

58
00:01:08,230 --> 00:01:10,960
 

59
00:01:08,240 --> 00:01:13,600
 fortunate career i've been at adobe

60
00:01:10,950 --> 00:01:13,600
 

61
00:01:10,960 --> 00:01:14,400
 for over 25 years although i did take a

62
00:01:13,590 --> 00:01:14,400
 

63
00:01:13,600 --> 00:01:19,600
 break in the middle

64
00:01:14,390 --> 00:01:19,600
 

65
00:01:14,400 --> 00:01:19,600
 and went to google for about a year

66
00:01:20,469 --> 00:01:20,469
 

67
00:01:20,479 --> 00:01:25,119
 and before that i was at apple so i've

68
00:01:23,429 --> 00:01:25,119
 

69
00:01:23,439 --> 00:01:26,640
 i've worked in silicon valley and worked

70
00:01:25,109 --> 00:01:26,640
 

71
00:01:25,119 --> 00:01:29,200
 in the industry

72
00:01:26,630 --> 00:01:29,200
 

73
00:01:26,640 --> 00:01:30,560
 and i've i've had the pleasure to work

74
00:01:29,190 --> 00:01:30,560
 

75
00:01:29,200 --> 00:01:33,360
 with some really great people and some

76
00:01:30,550 --> 00:01:33,360
 

77
00:01:30,560 --> 00:01:33,360
 really great teams

78
00:01:35,109 --> 00:01:35,109
 

79
00:01:35,119 --> 00:01:40,320
 all of my talks have a goal

80
00:01:38,310 --> 00:01:40,320
 

81
00:01:38,320 --> 00:01:42,399
 at least all of my talks in my my better

82
00:01:40,310 --> 00:01:42,399
 

83
00:01:40,320 --> 00:01:45,040
 code series of talks have a goal

84
00:01:42,389 --> 00:01:45,040
 

85
00:01:42,399 --> 00:01:46,079
 and this is kind of the last talk in

86
00:01:45,030 --> 00:01:46,079
 

87
00:01:45,040 --> 00:01:48,640
 that series

88
00:01:46,069 --> 00:01:48,640
 

89
00:01:46,079 --> 00:01:49,920
 i'm hoping to eventually get a book

90
00:01:48,630 --> 00:01:49,920
 

91
00:01:48,640 --> 00:01:51,439
 published

92
00:01:49,910 --> 00:01:51,439
 

93
00:01:49,920 --> 00:01:53,040
 felix has been helping me with some of

94
00:01:51,429 --> 00:01:53,040
 

95
00:01:51,439 --> 00:01:55,439
 the writing so

96
00:01:53,030 --> 00:01:55,439
 

97
00:01:53,040 --> 00:01:56,719
 the goal for this talk on relationships

98
00:01:55,429 --> 00:01:56,719
 

99
00:01:55,439 --> 00:01:59,280
 is no contradictions

100
00:01:56,709 --> 00:01:59,280
 

101
00:01:56,719 --> 00:02:01,840
 so that's just something to keep keeping

102
00:01:59,270 --> 00:02:01,840
 

103
00:01:59,280 --> 00:02:01,840
 in your mind

104
00:02:01,990 --> 00:02:01,990
 

105
00:02:02,000 --> 00:02:08,319
 i want to start with this quote at least

106
00:02:04,149 --> 00:02:08,319
 

107
00:02:04,159 --> 00:02:12,879
 i think this is a quote uh

108
00:02:08,309 --> 00:02:12,879
 

109
00:02:08,319 --> 00:02:15,360
 uh it's a uh regarding chess

110
00:02:12,869 --> 00:02:15,360
 

111
00:02:12,879 --> 00:02:16,480
 a novices only the chessmen an amateur

112
00:02:15,350 --> 00:02:16,480
 

113
00:02:15,360 --> 00:02:19,520
 sees the board

114
00:02:16,470 --> 00:02:19,520
 

115
00:02:16,480 --> 00:02:23,840
 and a master sees the game

116
00:02:19,510 --> 00:02:23,840
 

117
00:02:19,520 --> 00:02:27,520
 i thought this was a quote from

118
00:02:23,830 --> 00:02:27,520
 

119
00:02:23,840 --> 00:02:30,640
 um searching for barbie

120
00:02:27,510 --> 00:02:30,640
 

121
00:02:27,520 --> 00:02:31,519
 for bobby fischer the movie but the

122
00:02:30,630 --> 00:02:31,519
 

123
00:02:30,640 --> 00:02:33,920
 internet seems to

124
00:02:31,509 --> 00:02:33,920
 

125
00:02:31,519 --> 00:02:35,519
 to disagree so if anybody can can

126
00:02:33,910 --> 00:02:35,519
 

127
00:02:33,920 --> 00:02:36,800
 actually find where this quote comes

128
00:02:35,509 --> 00:02:36,800
 

129
00:02:35,519 --> 00:02:38,319
 from i would be interested

130
00:02:36,790 --> 00:02:38,319
 

131
00:02:36,800 --> 00:02:40,640
 otherwise i think i would lay claim to

132
00:02:38,309 --> 00:02:40,640
 

133
00:02:38,319 --> 00:02:40,640
 myself

134
00:02:43,750 --> 00:02:43,750
 

135
00:02:43,760 --> 00:02:47,280
 but what this quote is talking about by

136
00:02:46,790 --> 00:02:47,280
 

137
00:02:46,800 --> 00:02:49,440
 saying

138
00:02:47,270 --> 00:02:49,440
 

139
00:02:47,280 --> 00:02:53,360
 c's is certainly not looking at the

140
00:02:49,430 --> 00:02:53,360
 

141
00:02:49,440 --> 00:02:53,360
 board or looking at the game or watching

142
00:02:53,509 --> 00:02:53,509
 

143
00:02:53,519 --> 00:02:57,200
 but it's that a player of chess sees the

144
00:02:55,910 --> 00:02:57,200
 

145
00:02:55,920 --> 00:02:59,120
 relationships

146
00:02:57,190 --> 00:02:59,120
 

147
00:02:57,200 --> 00:03:01,280
 and when you start learning chess as a

148
00:02:59,110 --> 00:03:01,280
 

149
00:02:59,120 --> 00:03:02,800
 novice you just see the pieces and how

150
00:03:01,270 --> 00:03:02,800
 

151
00:03:01,280 --> 00:03:04,640
 the pieces move

152
00:03:02,790 --> 00:03:04,640
 

153
00:03:02,800 --> 00:03:06,080
 and as an amateur you start to see the

154
00:03:04,630 --> 00:03:06,080
 

155
00:03:04,640 --> 00:03:08,000
 structure of the board

156
00:03:06,070 --> 00:03:08,000
 

157
00:03:06,080 --> 00:03:10,000
 and as a master you start to see the

158
00:03:07,990 --> 00:03:10,000
 

159
00:03:08,000 --> 00:03:12,319
 relationships that play out in an entire

160
00:03:09,990 --> 00:03:12,319
 

161
00:03:10,000 --> 00:03:12,319
 game

162
00:03:12,630 --> 00:03:12,630
 

163
00:03:12,640 --> 00:03:15,920
 which brings me to my quote this one i

164
00:03:14,550 --> 00:03:15,920
 

165
00:03:14,560 --> 00:03:17,680
 do claim credit to

166
00:03:15,910 --> 00:03:17,680
 

167
00:03:15,920 --> 00:03:19,680
 computer scientists are very bad at

168
00:03:17,670 --> 00:03:19,680
 

169
00:03:17,680 --> 00:03:23,360
 relationships i think my wife would

170
00:03:19,670 --> 00:03:23,360
 

171
00:03:19,680 --> 00:03:23,360
 probably agree with this quote as well

172
00:03:24,869 --> 00:03:24,869
 

173
00:03:24,879 --> 00:03:28,720
 so let's start learning a little bit

174
00:03:26,789 --> 00:03:28,720
 

175
00:03:26,799 --> 00:03:32,959
 about relationships and

176
00:03:28,710 --> 00:03:32,959
 

177
00:03:28,720 --> 00:03:36,080
 understanding what the pieces are

178
00:03:32,949 --> 00:03:36,080
 

179
00:03:32,959 --> 00:03:38,400
 so relationships in math a relation is a

180
00:03:36,070 --> 00:03:38,400
 

181
00:03:36,080 --> 00:03:39,440
 set of ordered pairs mapping entities

182
00:03:38,390 --> 00:03:39,440
 

183
00:03:38,400 --> 00:03:41,920
 from a domain

184
00:03:39,430 --> 00:03:41,920
 

185
00:03:39,440 --> 00:03:42,640
 to a range it's a little different than

186
00:03:41,910 --> 00:03:42,640
 

187
00:03:41,920 --> 00:03:44,159
 a function

188
00:03:42,630 --> 00:03:44,159
 

189
00:03:42,640 --> 00:03:46,480
 in that the first entity does not

190
00:03:44,149 --> 00:03:46,480
 

191
00:03:44,159 --> 00:03:49,280
 uniquely determine the second

192
00:03:46,470 --> 00:03:49,280
 

193
00:03:46,480 --> 00:03:50,720
 so in this sense relationships go both

194
00:03:49,270 --> 00:03:50,720
 

195
00:03:49,280 --> 00:03:52,720
 directions

196
00:03:50,710 --> 00:03:52,720
 

197
00:03:50,720 --> 00:03:54,959
 a relationship is the way two entities

198
00:03:52,710 --> 00:03:54,959
 

199
00:03:52,720 --> 00:03:58,840
 are connected

200
00:03:54,949 --> 00:03:58,840
 

201
00:03:54,959 --> 00:04:02,319
 so as an example

202
00:03:58,830 --> 00:04:02,319
 

203
00:03:58,840 --> 00:04:04,239
 um see i've probably got some

204
00:04:02,309 --> 00:04:04,239
 

205
00:04:02,319 --> 00:04:06,080
 some better examples now we'll give an

206
00:04:04,229 --> 00:04:06,080
 

207
00:04:04,239 --> 00:04:08,799
 example there as an example uh

208
00:04:06,070 --> 00:04:08,799
 

209
00:04:06,080 --> 00:04:10,080
 uh is marriage right right two people

210
00:04:08,789 --> 00:04:10,080
 

211
00:04:08,799 --> 00:04:11,920
 can be involved

212
00:04:10,070 --> 00:04:11,920
 

213
00:04:10,080 --> 00:04:13,200
 involved in a marriage that would be a

214
00:04:11,910 --> 00:04:13,200
 

215
00:04:11,920 --> 00:04:14,959
 one-to-one relationship

216
00:04:13,190 --> 00:04:14,959
 

217
00:04:13,200 --> 00:04:17,199
 but a relationship could also be a

218
00:04:14,949 --> 00:04:17,199
 

219
00:04:14,959 --> 00:04:19,359
 many-to-one relationship

220
00:04:17,189 --> 00:04:19,359
 

221
00:04:17,199 --> 00:04:20,880
 you are a member of your family and in

222
00:04:19,349 --> 00:04:20,880
 

223
00:04:19,359 --> 00:04:22,240
 that way you're related to everybody in

224
00:04:20,870 --> 00:04:22,240
 

225
00:04:20,880 --> 00:04:25,040
 your family and everybody in your family

226
00:04:22,230 --> 00:04:25,040
 

227
00:04:22,240 --> 00:04:25,040
 is related to you

228
00:04:27,030 --> 00:04:27,030
 

229
00:04:27,040 --> 00:04:31,120
 so for any relationship there's also a

230
00:04:29,030 --> 00:04:31,120
 

231
00:04:29,040 --> 00:04:34,320
 corresponding predicate

232
00:04:31,110 --> 00:04:34,320
 

233
00:04:31,120 --> 00:04:34,320
 a predicate is a really

234
00:04:35,030 --> 00:04:35,030
 

235
00:04:35,040 --> 00:04:40,000
 the the predicate uh implies a course

236
00:04:38,550 --> 00:04:40,000
 

237
00:04:38,560 --> 00:04:41,600
 i'm sorry a relation implies a

238
00:04:39,990 --> 00:04:41,600
 

239
00:04:40,000 --> 00:04:43,680
 corresponding predicate

240
00:04:41,590 --> 00:04:43,680
 

241
00:04:41,600 --> 00:04:45,680
 that tests if the pair exists in the

242
00:04:43,670 --> 00:04:45,680
 

243
00:04:43,680 --> 00:04:47,840
 relationship

244
00:04:45,670 --> 00:04:47,840
 

245
00:04:45,680 --> 00:04:50,800
 so if it's true the relationship is

246
00:04:47,830 --> 00:04:50,800
 

247
00:04:47,840 --> 00:04:52,880
 satisfied or holds

248
00:04:50,790 --> 00:04:52,880
 

249
00:04:50,800 --> 00:04:56,160
 so for example for the relationship john

250
00:04:52,870 --> 00:04:56,160
 

251
00:04:52,880 --> 00:04:58,000
 is married to jane

252
00:04:56,150 --> 00:04:58,000
 

253
00:04:56,160 --> 00:05:00,320
 we have the predicate is john married to

254
00:04:57,990 --> 00:05:00,320
 

255
00:04:58,000 --> 00:05:00,320
 jane

256
00:05:01,350 --> 00:05:01,350
 

257
00:05:01,360 --> 00:05:05,680
 now constraints are a little bit of a

258
00:05:04,310 --> 00:05:05,680
 

259
00:05:04,320 --> 00:05:07,520
 specialized relationship

260
00:05:05,670 --> 00:05:07,520
 

261
00:05:05,680 --> 00:05:10,000
 a constraint is a relationship which

262
00:05:07,510 --> 00:05:10,000
 

263
00:05:07,520 --> 00:05:14,160
 must be satisfied

264
00:05:09,990 --> 00:05:14,160
 

265
00:05:10,000 --> 00:05:14,160
 for another relationship to be satisfied

266
00:05:14,390 --> 00:05:14,390
 

267
00:05:14,400 --> 00:05:17,759
 so for example the denominator must not

268
00:05:16,870 --> 00:05:17,759
 

269
00:05:16,880 --> 00:05:21,360
 be zero

270
00:05:17,749 --> 00:05:21,360
 

271
00:05:17,759 --> 00:05:21,360
 for the result of a divisor to be

272
00:05:22,830 --> 00:05:22,830
 

273
00:05:22,840 --> 00:05:26,639
 defined

274
00:05:23,990 --> 00:05:26,639
 

275
00:05:24,000 --> 00:05:27,600
 a constraint is a form of an implication

276
00:05:26,629 --> 00:05:27,600
 

277
00:05:26,639 --> 00:05:29,840
 relationship

278
00:05:27,590 --> 00:05:29,840
 

279
00:05:27,600 --> 00:05:31,120
 a implies b this is actually the most

280
00:05:29,830 --> 00:05:31,120
 

281
00:05:29,840 --> 00:05:34,639
 common relationship

282
00:05:31,110 --> 00:05:34,639
 

283
00:05:31,120 --> 00:05:36,080
 you'll find and this is the truth table

284
00:05:34,629 --> 00:05:36,080
 

285
00:05:34,639 --> 00:05:40,720
 for that

286
00:05:36,070 --> 00:05:40,720
 

287
00:05:36,080 --> 00:05:40,720
 so if if

288
00:05:42,629 --> 00:05:42,629
 

289
00:05:42,639 --> 00:05:48,880
 uh yes if if if a is true and b is true

290
00:05:45,510 --> 00:05:48,880
 

291
00:05:45,520 --> 00:05:48,880
 then the relationship is true

292
00:05:50,830 --> 00:05:50,830
 

293
00:05:50,840 --> 00:05:55,280
 now i'm also going to introduce a notion

294
00:05:54,310 --> 00:05:55,280
 

295
00:05:54,320 --> 00:05:57,440
 here this is an

296
00:05:55,270 --> 00:05:57,440
 

297
00:05:55,280 --> 00:05:58,800
 incomplete notation for describing

298
00:05:57,430 --> 00:05:58,800
 

299
00:05:57,440 --> 00:06:00,240
 relationships it has a lot of

300
00:05:58,790 --> 00:06:00,240
 

301
00:05:58,800 --> 00:06:02,319
 limitations

302
00:06:00,230 --> 00:06:02,319
 

303
00:06:00,240 --> 00:06:05,919
 and it breaks down for very complex

304
00:06:02,309 --> 00:06:05,919
 

305
00:06:02,319 --> 00:06:06,479
 structures but it's a nice way to think

306
00:06:05,909 --> 00:06:06,479
 

307
00:06:05,919 --> 00:06:10,560
 think through

308
00:06:06,469 --> 00:06:10,560
 

309
00:06:06,479 --> 00:06:10,560
 relationships relationship

310
00:06:10,629 --> 00:06:10,629
 

311
00:06:10,639 --> 00:06:13,919
 the entities in a relationship are

312
00:06:12,309 --> 00:06:13,919
 

313
00:06:12,319 --> 00:06:15,680
 represented by rectangles and the

314
00:06:13,909 --> 00:06:15,680
 

315
00:06:13,919 --> 00:06:18,800
 relationship itself by a circle

316
00:06:15,670 --> 00:06:18,800
 

317
00:06:15,680 --> 00:06:20,560
 and this forms a bipartite graph so

318
00:06:18,790 --> 00:06:20,560
 

319
00:06:18,800 --> 00:06:24,240
 where entities are connected to under

320
00:06:20,550 --> 00:06:24,240
 

321
00:06:20,560 --> 00:06:24,240
 other entities via relationship

322
00:06:25,590 --> 00:06:25,590
 

323
00:06:25,600 --> 00:06:28,800
 so implication is represented with

324
00:06:27,510 --> 00:06:28,800
 

325
00:06:27,520 --> 00:06:31,600
 directional edges

326
00:06:28,790 --> 00:06:31,600
 

327
00:06:28,800 --> 00:06:33,039
 so this is a shorthand for given

328
00:06:31,590 --> 00:06:33,039
 

329
00:06:31,600 --> 00:06:36,000
 entities

330
00:06:33,029 --> 00:06:36,000
 

331
00:06:33,039 --> 00:06:37,759
 b and c a is an entity such that the

332
00:06:35,990 --> 00:06:37,759
 

333
00:06:36,000 --> 00:06:41,120
 relationship holds

334
00:06:37,749 --> 00:06:41,120
 

335
00:06:37,759 --> 00:06:45,120
 so you can read this as b and c imply

336
00:06:41,110 --> 00:06:45,120
 

337
00:06:41,120 --> 00:06:47,199
 a this is also

338
00:06:45,110 --> 00:06:47,199
 

339
00:06:45,120 --> 00:06:48,479
 the notation that you would use for a

340
00:06:47,189 --> 00:06:48,479
 

341
00:06:47,199 --> 00:06:50,160
 function

342
00:06:48,469 --> 00:06:50,160
 

343
00:06:48,479 --> 00:06:51,759
 so if you replace the relationship with

344
00:06:50,150 --> 00:06:51,759
 

345
00:06:50,160 --> 00:06:53,280
 a function then you would say b and c

346
00:06:51,749 --> 00:06:53,280
 

347
00:06:51,759 --> 00:06:57,039
 are the arguments to function

348
00:06:53,270 --> 00:06:57,039
 

349
00:06:53,280 --> 00:06:57,039
 to the function and a is the result

350
00:06:58,950 --> 00:06:58,950
 

351
00:06:58,960 --> 00:07:04,880
 as soon as we have two entities we have

352
00:07:01,510 --> 00:07:04,880
 

353
00:07:01,520 --> 00:07:04,880
 an implicit relationship

354
00:07:05,430 --> 00:07:05,430
 

355
00:07:05,440 --> 00:07:12,160
 right a memory space is an entity

356
00:07:09,430 --> 00:07:12,160
 

357
00:07:09,440 --> 00:07:12,880
 and so when an object is copied or moved

358
00:07:12,150 --> 00:07:12,880
 

359
00:07:12,160 --> 00:07:14,960
 or

360
00:07:12,870 --> 00:07:14,960
 

361
00:07:12,880 --> 00:07:16,479
 right so a memory space is an entity so

362
00:07:14,950 --> 00:07:16,479
 

363
00:07:14,960 --> 00:07:17,199
 if we have an object in that memory

364
00:07:16,469 --> 00:07:17,199
 

365
00:07:16,479 --> 00:07:20,160
 space

366
00:07:17,189 --> 00:07:20,160
 

367
00:07:17,199 --> 00:07:21,440
 then that object is in a relationship

368
00:07:20,150 --> 00:07:21,440
 

369
00:07:20,160 --> 00:07:23,440
 with the memory space

370
00:07:21,430 --> 00:07:23,440
 

371
00:07:21,440 --> 00:07:26,000
 when an object is copied or moved any

372
00:07:23,430 --> 00:07:26,000
 

373
00:07:23,440 --> 00:07:28,479
 relationship that object was involved in

374
00:07:25,990 --> 00:07:28,479
 

375
00:07:26,000 --> 00:07:30,000
 is either maintained or severed meaning

376
00:07:28,469 --> 00:07:30,000
 

377
00:07:28,479 --> 00:07:33,919
 it would no longer hold

378
00:07:29,990 --> 00:07:33,919
 

379
00:07:30,000 --> 00:07:33,919
 with respect to the destination object

380
00:07:34,230 --> 00:07:34,230
 

381
00:07:34,240 --> 00:07:37,680
 when an object is destructed any

382
00:07:35,749 --> 00:07:37,680
 

383
00:07:35,759 --> 00:07:40,240
 relationship that object was involved in

384
00:07:37,670 --> 00:07:40,240
 

385
00:07:37,680 --> 00:07:40,240
 is severed

386
00:07:42,070 --> 00:07:42,070
 

387
00:07:42,080 --> 00:07:46,319
 witnessed relationships is when we

388
00:07:43,749 --> 00:07:46,319
 

389
00:07:43,759 --> 00:07:48,560
 create an object to represent the

390
00:07:46,309 --> 00:07:48,560
 

391
00:07:46,319 --> 00:07:50,319
 relationship

392
00:07:48,550 --> 00:07:50,319
 

393
00:07:48,560 --> 00:07:52,000
 so a witness relationship is a

394
00:07:50,309 --> 00:07:52,000
 

395
00:07:50,319 --> 00:07:56,000
 relationship represented by

396
00:07:51,990 --> 00:07:56,000
 

397
00:07:52,000 --> 00:07:58,240
 an object as an object a witness

398
00:07:55,990 --> 00:07:58,240
 

399
00:07:56,000 --> 00:08:00,960
 relationship is copyable and a quality

400
00:07:58,230 --> 00:08:00,960
 

401
00:07:58,240 --> 00:08:00,960
 comparable

402
00:08:01,909 --> 00:08:01,909
 

403
00:08:01,919 --> 00:08:06,240
 and when an object is copied or moved

404
00:08:04,230 --> 00:08:06,240
 

405
00:08:04,240 --> 00:08:08,160
 any witness relationship that object was

406
00:08:06,230 --> 00:08:08,160
 

407
00:08:06,240 --> 00:08:11,680
 involved in is either maintained

408
00:08:08,150 --> 00:08:11,680
 

409
00:08:08,160 --> 00:08:13,599
 severed or invalidated right so

410
00:08:11,670 --> 00:08:13,599
 

411
00:08:11,680 --> 00:08:15,520
 an example here that you guys might be

412
00:08:13,589 --> 00:08:15,520
 

413
00:08:13,599 --> 00:08:20,080
 familiar with would be

414
00:08:15,510 --> 00:08:20,080
 

415
00:08:15,520 --> 00:08:22,479
 uh iterators into a vector

416
00:08:20,070 --> 00:08:22,479
 

417
00:08:20,080 --> 00:08:23,680
 if the vector resizes that that's going

418
00:08:22,469 --> 00:08:23,680
 

419
00:08:22,479 --> 00:08:25,360
 to end up moving

420
00:08:23,670 --> 00:08:25,360
 

421
00:08:23,680 --> 00:08:27,599
 the underlying contents of the vector

422
00:08:25,350 --> 00:08:27,599
 

423
00:08:25,360 --> 00:08:30,319
 someplace else and that would invalidate

424
00:08:27,589 --> 00:08:30,319
 

425
00:08:27,599 --> 00:08:30,319
 our iterators

426
00:08:31,749 --> 00:08:31,749
 

427
00:08:31,759 --> 00:08:35,120
 when an object is destructed any

428
00:08:33,430 --> 00:08:35,120
 

429
00:08:33,440 --> 00:08:38,640
 witnessed relationship that object was

430
00:08:35,110 --> 00:08:38,640
 

431
00:08:35,120 --> 00:08:38,640
 involved in is either severed or

432
00:08:38,829 --> 00:08:38,829
 

433
00:08:38,839 --> 00:08:41,839
 invalidated

434
00:08:42,230 --> 00:08:42,230
 

435
00:08:42,240 --> 00:08:48,160
 now we may choose not to implement copy

436
00:08:44,790 --> 00:08:48,160
 

437
00:08:44,800 --> 00:08:51,200
 or move for a witnessed relationship

438
00:08:48,150 --> 00:08:51,200
 

439
00:08:48,160 --> 00:08:53,120
 because of the side effect of the

440
00:08:51,190 --> 00:08:53,120
 

441
00:08:51,200 --> 00:08:56,640
 the relationship being invalidated if we

442
00:08:53,110 --> 00:08:56,640
 

443
00:08:53,120 --> 00:08:56,640
 copy or move something within it

444
00:08:56,949 --> 00:08:56,949
 

445
00:08:56,959 --> 00:09:03,839
 this is how we get iterator

446
00:09:00,470 --> 00:09:03,839
 

447
00:09:00,480 --> 00:09:05,760
 in invalidation at a distance right

448
00:09:03,829 --> 00:09:05,760
 

449
00:09:03,839 --> 00:09:07,839
 right without modifying the iterator

450
00:09:05,750 --> 00:09:07,839
 

451
00:09:05,760 --> 00:09:10,160
 itself just modifying what the iterator

452
00:09:07,829 --> 00:09:10,160
 

453
00:09:07,839 --> 00:09:13,920
 points to it invalidates the iterator

454
00:09:10,150 --> 00:09:13,920
 

455
00:09:10,160 --> 00:09:13,920
 without actually changing the iterator

456
00:09:15,590 --> 00:09:15,590
 

457
00:09:15,600 --> 00:09:19,360
 so that's a lot of terminology but

458
00:09:17,350 --> 00:09:19,360
 

459
00:09:17,360 --> 00:09:21,519
 that's just to introduce the pieces of

460
00:09:19,350 --> 00:09:21,519
 

461
00:09:19,360 --> 00:09:23,200
 this game

462
00:09:21,509 --> 00:09:23,200
 

463
00:09:21,519 --> 00:09:24,720
 so now let's talk a little bit about the

464
00:09:23,190 --> 00:09:24,720
 

465
00:09:23,200 --> 00:09:29,920
 board the

466
00:09:24,710 --> 00:09:29,920
 

467
00:09:24,720 --> 00:09:29,920
 board in this game are structures

468
00:09:30,070 --> 00:09:30,070
 

469
00:09:30,080 --> 00:09:34,560
 right a structure on a set consists of

470
00:09:32,710 --> 00:09:34,560
 

471
00:09:32,720 --> 00:09:37,200
 additional entities

472
00:09:34,550 --> 00:09:37,200
 

473
00:09:34,560 --> 00:09:38,560
 that in some manner relate to the set

474
00:09:37,190 --> 00:09:38,560
 

475
00:09:37,200 --> 00:09:40,080
 endowing the collection with

476
00:09:38,550 --> 00:09:40,080
 

477
00:09:38,560 --> 00:09:41,440
 significance or meaning

478
00:09:40,070 --> 00:09:41,440
 

479
00:09:40,080 --> 00:09:43,550
 that's the definition of what a

480
00:09:41,430 --> 00:09:43,550
 

481
00:09:41,440 --> 00:09:44,880
 structure is

482
00:09:43,540 --> 00:09:44,880
 

483
00:09:43,550 --> 00:09:49,279
[Laughter]

484
00:09:44,870 --> 00:09:49,279
 

485
00:09:44,880 --> 00:09:52,240
 so let's look at a very simple structure

486
00:09:49,269 --> 00:09:52,240
 

487
00:09:49,279 --> 00:09:52,880
 this is a void slide represents nothing

488
00:09:52,230 --> 00:09:52,880
 

489
00:09:52,240 --> 00:09:55,600
 not even

490
00:09:52,870 --> 00:09:55,600
 

491
00:09:52,880 --> 00:09:56,800
 space right there's no space there's no

492
00:09:55,590 --> 00:09:56,800
 

493
00:09:55,600 --> 00:09:59,839
 time

494
00:09:56,790 --> 00:09:59,839
 

495
00:09:56,800 --> 00:10:01,920
 there's nothing in this slide and

496
00:09:59,829 --> 00:10:01,920
 

497
00:09:59,839 --> 00:10:03,680
 into this slide we're going to put some

498
00:10:01,910 --> 00:10:03,680
 

499
00:10:01,920 --> 00:10:06,880
 bits

500
00:10:03,670 --> 00:10:06,880
 

501
00:10:03,680 --> 00:10:10,640
 now these bits

502
00:10:06,870 --> 00:10:10,640
 

503
00:10:06,880 --> 00:10:10,640
 might represent four bananas

504
00:10:10,710 --> 00:10:10,710
 

505
00:10:10,720 --> 00:10:14,320
 right or they might represent the color

506
00:10:12,550 --> 00:10:14,320
 

507
00:10:12,560 --> 00:10:16,079
 blue

508
00:10:14,310 --> 00:10:16,079
 

509
00:10:14,320 --> 00:10:19,680
 or they might represent just the

510
00:10:16,069 --> 00:10:19,680
 

511
00:10:16,079 --> 00:10:23,360
 abstract number four

512
00:10:19,670 --> 00:10:23,360
 

513
00:10:19,680 --> 00:10:26,160
 okay so that's what's known as a

514
00:10:23,350 --> 00:10:26,160
 

515
00:10:23,360 --> 00:10:30,720
 representational relationship

516
00:10:26,150 --> 00:10:30,720
 

517
00:10:26,160 --> 00:10:30,720
 now the space in which these bits occupy

518
00:10:31,110 --> 00:10:31,110
 

519
00:10:31,120 --> 00:10:37,360
 might be able to represent say a number

520
00:10:33,430 --> 00:10:37,360
 

521
00:10:33,440 --> 00:10:37,360
 in the range of negative eight to seven

522
00:10:38,470 --> 00:10:38,470
 

523
00:10:38,480 --> 00:10:42,959
 we might have then two objects that both

524
00:10:41,910 --> 00:10:42,959
 

525
00:10:41,920 --> 00:10:44,640
 could represent

526
00:10:42,949 --> 00:10:44,640
 

527
00:10:42,959 --> 00:10:46,480
 numbers in the range of negative eight

528
00:10:44,630 --> 00:10:46,480
 

529
00:10:44,640 --> 00:10:50,079
 to seven and we would say that these two

530
00:10:46,470 --> 00:10:50,079
 

531
00:10:46,480 --> 00:10:50,079
 objects then have the same type

532
00:10:51,750 --> 00:10:51,750
 

533
00:10:51,760 --> 00:10:55,519
 now those two objects themselves could

534
00:10:53,670 --> 00:10:55,519
 

535
00:10:53,680 --> 00:11:01,839
 have a relationship with each other

536
00:10:55,509 --> 00:11:01,839
 

537
00:10:55,519 --> 00:11:01,839
 such as 4 is greater than 3.

538
00:11:02,790 --> 00:11:02,790
 

539
00:11:02,800 --> 00:11:07,600
 they also have a relationship because

540
00:11:05,110 --> 00:11:07,600
 

541
00:11:05,120 --> 00:11:11,920
 they both have a representation

542
00:11:07,590 --> 00:11:11,920
 

543
00:11:07,600 --> 00:11:15,440
 so the hash of one value in this case

544
00:11:11,910 --> 00:11:15,440
 

545
00:11:11,920 --> 00:11:18,640
 r4 does not equal the hash of 3.

546
00:11:15,430 --> 00:11:18,640
 

547
00:11:15,440 --> 00:11:18,640
 that's another relationship

548
00:11:19,750 --> 00:11:19,750
 

549
00:11:19,760 --> 00:11:24,079
 now in the real world our objects don't

550
00:11:22,150 --> 00:11:24,079
 

551
00:11:22,160 --> 00:11:26,800
 exist in a void they exist inside of a

552
00:11:24,069 --> 00:11:26,800
 

553
00:11:24,079 --> 00:11:26,800
 memory space

554
00:11:27,110 --> 00:11:27,110
 

555
00:11:27,120 --> 00:11:30,880
 okay there are other bits in this memory

556
00:11:29,030 --> 00:11:30,880
 

557
00:11:29,040 --> 00:11:33,360
 space which may or may not represent

558
00:11:30,870 --> 00:11:33,360
 

559
00:11:30,880 --> 00:11:33,360
 objects

560
00:11:35,350 --> 00:11:35,350
 

561
00:11:35,360 --> 00:11:43,839
 now because they exist in a memory space

562
00:11:39,750 --> 00:11:43,839
 

563
00:11:39,760 --> 00:11:43,839
 our objects have a location

564
00:11:44,389 --> 00:11:44,389
 

565
00:11:44,399 --> 00:11:49,600
 right and in this case our first object

566
00:11:47,829 --> 00:11:49,600
 

567
00:11:47,839 --> 00:11:51,519
 is before the after

568
00:11:49,590 --> 00:11:51,519
 

569
00:11:49,600 --> 00:11:57,839
 before the second object within that

570
00:11:51,509 --> 00:11:57,839
 

571
00:11:51,519 --> 00:11:57,839
 memory space

572
00:11:59,030 --> 00:11:59,030
 

573
00:11:59,040 --> 00:12:04,160
 now i can sort my objects which is

574
00:12:02,230 --> 00:12:04,160
 

575
00:12:02,240 --> 00:12:06,720
 taking the relationship between the

576
00:12:04,150 --> 00:12:06,720
 

577
00:12:04,160 --> 00:12:09,600
 values and representing that

578
00:12:06,710 --> 00:12:09,600
 

579
00:12:06,720 --> 00:12:11,839
 by their location within the address

580
00:12:09,590 --> 00:12:11,839
 

581
00:12:09,600 --> 00:12:11,839
 space

582
00:12:14,550 --> 00:12:14,550
 

583
00:12:14,560 --> 00:12:19,200
 i can also define other operations on

584
00:12:16,470 --> 00:12:19,200
 

585
00:12:16,480 --> 00:12:21,360
 these objects

586
00:12:19,190 --> 00:12:21,360
 

587
00:12:19,200 --> 00:12:25,839
 which yield additional values which can

588
00:12:21,350 --> 00:12:25,839
 

589
00:12:21,360 --> 00:12:25,839
 be constructed within my address space

590
00:12:28,710 --> 00:12:28,710
 

591
00:12:28,720 --> 00:12:32,560
 now let's talk a little bit about safety

592
00:12:32,790 --> 00:12:32,790
 

593
00:12:32,800 --> 00:12:39,360
 so an object instance without meaning

594
00:12:37,190 --> 00:12:39,360
 

595
00:12:37,200 --> 00:12:40,800
 right that doesn't represent anything at

596
00:12:39,350 --> 00:12:40,800
 

597
00:12:39,360 --> 00:12:45,760
 a given point in time

598
00:12:40,790 --> 00:12:45,760
 

599
00:12:40,800 --> 00:12:45,760
 is invalid think of an invalid iterator

600
00:12:46,949 --> 00:12:46,949
 

601
00:12:46,959 --> 00:12:51,920
 an object in an invalid state must

602
00:12:49,350 --> 00:12:51,920
 

603
00:12:49,360 --> 00:12:52,720
 either be restored to a valid state or

604
00:12:51,910 --> 00:12:52,720
 

605
00:12:51,920 --> 00:12:54,320
 destroyed

606
00:12:52,710 --> 00:12:54,320
 

607
00:12:52,720 --> 00:12:56,880
 at some point in your application you

608
00:12:54,310 --> 00:12:56,880
 

609
00:12:54,320 --> 00:12:58,800
 don't want objects in an invalid state

610
00:12:56,870 --> 00:12:58,800
 

611
00:12:56,880 --> 00:13:00,639
 to escape throughout your system if you

612
00:12:58,790 --> 00:13:00,639
 

613
00:12:58,800 --> 00:13:03,600
 start performing other operations on

614
00:13:00,629 --> 00:13:03,600
 

615
00:13:00,639 --> 00:13:04,160
 invalid objects you get invalid results

616
00:13:03,590 --> 00:13:04,160
 

617
00:13:03,600 --> 00:13:07,440
 and

618
00:13:04,150 --> 00:13:07,440
 

619
00:13:04,160 --> 00:13:10,720
 eventually your application is just

620
00:13:07,430 --> 00:13:10,720
 

621
00:13:07,440 --> 00:13:13,040
 emitting uh no output whatsoever or bad

622
00:13:10,710 --> 00:13:13,040
 

623
00:13:10,720 --> 00:13:13,040
 output

624
00:13:13,829 --> 00:13:13,829
 

625
00:13:13,839 --> 00:13:17,279
 so this is related to the idea of a

626
00:13:15,750 --> 00:13:17,279
 

627
00:13:15,760 --> 00:13:19,760
 partially formed object

628
00:13:17,269 --> 00:13:19,760
 

629
00:13:17,279 --> 00:13:20,800
 if you've ever read alec and paul

630
00:13:19,750 --> 00:13:20,800
 

631
00:13:19,760 --> 00:13:22,800
 mcjones books

632
00:13:20,790 --> 00:13:22,800
 

633
00:13:20,800 --> 00:13:26,480
 elements of programming they define this

634
00:13:22,790 --> 00:13:26,480
 

635
00:13:22,800 --> 00:13:26,480
 as a partially formed object

636
00:13:26,710 --> 00:13:26,710
 

637
00:13:26,720 --> 00:13:30,240
 an operation which leaves an object in

638
00:13:28,790 --> 00:13:30,240
 

639
00:13:28,800 --> 00:13:35,279
 an invalid state

640
00:13:30,230 --> 00:13:35,279
 

641
00:13:30,240 --> 00:13:37,760
 we call an unsafe operation

642
00:13:35,269 --> 00:13:37,760
 

643
00:13:35,279 --> 00:13:38,639
 std move in this sense is an unsafe

644
00:13:37,750 --> 00:13:38,639
 

645
00:13:37,760 --> 00:13:42,079
 operation

646
00:13:38,629 --> 00:13:42,079
 

647
00:13:38,639 --> 00:13:44,399
 by unsafe i don't mean bad okay

648
00:13:42,069 --> 00:13:44,399
 

649
00:13:42,079 --> 00:13:45,760
 i don't mean that it's somehow evil but

650
00:13:44,389 --> 00:13:45,760
 

651
00:13:44,399 --> 00:13:49,440
 if say i

652
00:13:45,750 --> 00:13:49,440
 

653
00:13:45,760 --> 00:13:52,240
 stood move a string from

654
00:13:49,430 --> 00:13:52,240
 

655
00:13:49,440 --> 00:13:53,760
 one place to another the string that was

656
00:13:52,230 --> 00:13:53,760
 

657
00:13:52,240 --> 00:13:56,959
 moved from

658
00:13:53,750 --> 00:13:56,959
 

659
00:13:53,760 --> 00:14:00,079
 is in an unspecified state meaning it no

660
00:13:56,949 --> 00:14:00,079
 

661
00:13:56,959 --> 00:14:00,079
 longer represents

662
00:14:01,110 --> 00:14:01,110
 

663
00:14:01,120 --> 00:14:04,480
 it any object

664
00:14:04,790 --> 00:14:04,790
 

665
00:14:04,800 --> 00:14:07,680
 or any entity

666
00:14:08,389 --> 00:14:08,389
 

667
00:14:08,399 --> 00:14:13,120
 now c plus plus 20 introduces

668
00:14:11,430 --> 00:14:13,120
 

669
00:14:11,440 --> 00:14:15,360
 two new features specifically about

670
00:14:13,110 --> 00:14:15,360
 

671
00:14:13,120 --> 00:14:16,800
 relationships at least when i started

672
00:14:15,350 --> 00:14:16,800
 

673
00:14:15,360 --> 00:14:18,399
 working on these slides that was the

674
00:14:16,790 --> 00:14:18,399
 

675
00:14:16,800 --> 00:14:21,760
 case

676
00:14:18,389 --> 00:14:21,760
 

677
00:14:18,399 --> 00:14:23,360
 the first one is concepts

678
00:14:21,750 --> 00:14:23,360
 

679
00:14:21,760 --> 00:14:25,600
 and the second one was going to be

680
00:14:23,350 --> 00:14:25,600
 

681
00:14:23,360 --> 00:14:27,360
 contracts so i lied

682
00:14:25,590 --> 00:14:27,360
 

683
00:14:25,600 --> 00:14:29,600
 c plus plus 20 introduced one new

684
00:14:27,350 --> 00:14:29,600
 

685
00:14:27,360 --> 00:14:32,240
 feature specifically about relationships

686
00:14:29,590 --> 00:14:32,240
 

687
00:14:29,600 --> 00:14:32,240
 concepts

688
00:14:35,350 --> 00:14:35,350
 

689
00:14:35,360 --> 00:14:39,440
 the idea of concepts came out of this

690
00:14:38,790 --> 00:14:39,440
 

691
00:14:38,800 --> 00:14:41,279
 paper

692
00:14:39,430 --> 00:14:41,279
 

693
00:14:39,440 --> 00:14:43,519
 this is where the term concepts was

694
00:14:41,269 --> 00:14:43,519
 

695
00:14:41,279 --> 00:14:47,360
 coined

696
00:14:43,509 --> 00:14:47,360
 

697
00:14:43,519 --> 00:14:50,560
 uh and it has its roots in logic

698
00:14:47,350 --> 00:14:50,560
 

699
00:14:47,360 --> 00:14:52,480
 which was developed by tony horror

700
00:14:50,550 --> 00:14:52,480
 

701
00:14:50,560 --> 00:14:54,720
 so this paper's titled is fundamentals

702
00:14:52,470 --> 00:14:54,720
 

703
00:14:52,480 --> 00:14:59,839
 of generic programming it was written by

704
00:14:54,710 --> 00:14:59,839
 

705
00:14:54,720 --> 00:15:02,480
 james dennard and alex stepanov

706
00:14:59,829 --> 00:15:02,480
 

707
00:14:59,839 --> 00:15:04,160
 and here's how they introduce concepts

708
00:15:02,470 --> 00:15:04,160
 

709
00:15:02,480 --> 00:15:06,320
 we call the set of axioms

710
00:15:04,150 --> 00:15:06,320
 

711
00:15:04,160 --> 00:15:07,680
 satisfied by a data type and a set of

712
00:15:06,310 --> 00:15:07,680
 

713
00:15:06,320 --> 00:15:13,839
 operations on it

714
00:15:07,670 --> 00:15:13,839
 

715
00:15:07,680 --> 00:15:13,839
 a concept

716
00:15:14,710 --> 00:15:14,710
 

717
00:15:14,720 --> 00:15:19,760
 all right this is where the idea comes

718
00:15:17,430 --> 00:15:19,760
 

719
00:15:17,440 --> 00:15:19,760
 from

720
00:15:20,230 --> 00:15:20,230
 

721
00:15:20,240 --> 00:15:25,680
 this paper by c by tony hor

722
00:15:23,750 --> 00:15:25,680
 

723
00:15:23,760 --> 00:15:28,240
 an axiomatic basis for computer

724
00:15:25,670 --> 00:15:28,240
 

725
00:15:25,680 --> 00:15:28,240
 programming

726
00:15:31,269 --> 00:15:31,269
 

727
00:15:31,279 --> 00:15:34,480
 so let's take a look at what a concept

728
00:15:33,829 --> 00:15:34,480
 

729
00:15:33,839 --> 00:15:37,680
 is

730
00:15:34,470 --> 00:15:37,680
 

731
00:15:34,480 --> 00:15:38,639
 we'll start with a quality two objects

732
00:15:37,670 --> 00:15:38,639
 

733
00:15:37,680 --> 00:15:40,959
 are equal

734
00:15:38,629 --> 00:15:40,959
 

735
00:15:38,639 --> 00:15:43,920
 if and only if their values correspond

736
00:15:40,949 --> 00:15:43,920
 

737
00:15:40,959 --> 00:15:43,920
 to the same entity

738
00:15:45,110 --> 00:15:45,110
 

739
00:15:45,120 --> 00:15:48,880
 from this definition we can derive the

740
00:15:47,509 --> 00:15:48,880
 

741
00:15:47,519 --> 00:15:52,240
 following properties

742
00:15:48,870 --> 00:15:52,240
 

743
00:15:48,880 --> 00:15:55,839
 we have reflexivity symmetry

744
00:15:52,230 --> 00:15:55,839
 

745
00:15:52,240 --> 00:15:55,839
 and transitivity

746
00:16:01,350 --> 00:16:01,350
 

747
00:16:01,360 --> 00:16:04,560
 axioms follow from the definition a

748
00:16:03,910 --> 00:16:04,560
 

749
00:16:03,920 --> 00:16:06,959
 connect

750
00:16:04,550 --> 00:16:06,959
 

751
00:16:04,560 --> 00:16:09,199
 a collection of connected axioms form an

752
00:16:06,949 --> 00:16:09,199
 

753
00:16:06,959 --> 00:16:11,440
 algebraic structure

754
00:16:09,189 --> 00:16:11,440
 

755
00:16:09,199 --> 00:16:14,079
 connected type requirements form a

756
00:16:11,430 --> 00:16:14,079
 

757
00:16:11,440 --> 00:16:14,079
 concept

758
00:16:17,189 --> 00:16:17,189
 

759
00:16:17,199 --> 00:16:23,839
 so let's take a look at copy

760
00:16:20,230 --> 00:16:23,839
 

761
00:16:20,240 --> 00:16:23,839
 properties of copy and assignment

762
00:16:24,069 --> 00:16:24,069
 

763
00:16:24,079 --> 00:16:28,160
 so the notation here if we say b is

764
00:16:26,710 --> 00:16:28,160
 

765
00:16:26,720 --> 00:16:31,360
 copied into a

766
00:16:28,150 --> 00:16:31,360
 

767
00:16:28,160 --> 00:16:36,720
 that implies a is equal to b our copies

768
00:16:31,350 --> 00:16:36,720
 

769
00:16:31,360 --> 00:16:40,240
 have to be equal if

770
00:16:36,710 --> 00:16:40,240
 

771
00:16:36,720 --> 00:16:43,360
 a is equal to b and

772
00:16:40,230 --> 00:16:43,360
 

773
00:16:40,240 --> 00:16:43,360
 both are equal to c

774
00:16:43,670 --> 00:16:43,670
 

775
00:16:43,680 --> 00:16:50,240
 and d is not equal to a then

776
00:16:47,110 --> 00:16:50,240
 

777
00:16:47,120 --> 00:16:53,600
 copying d into a implies

778
00:16:50,230 --> 00:16:53,600
 

779
00:16:50,240 --> 00:16:54,959
 that a does not equal b and b is still

780
00:16:53,590 --> 00:16:54,959
 

781
00:16:53,600 --> 00:16:57,279
 equal to c

782
00:16:54,949 --> 00:16:57,279
 

783
00:16:54,959 --> 00:17:00,480
 so put another way copies have to be

784
00:16:57,269 --> 00:17:00,480
 

785
00:16:57,279 --> 00:17:00,480
 logically disjoint

786
00:17:00,790 --> 00:17:00,790
 

787
00:17:00,800 --> 00:17:04,079
 if you notice in order to define copy we

788
00:17:03,350 --> 00:17:04,079
 

789
00:17:03,360 --> 00:17:06,799
 have to pull

790
00:17:04,069 --> 00:17:06,799
 

791
00:17:04,079 --> 00:17:09,360
 in a quality copy is connected to

792
00:17:06,789 --> 00:17:09,360
 

793
00:17:06,799 --> 00:17:09,360
 equality

794
00:17:11,270 --> 00:17:11,270
 

795
00:17:11,280 --> 00:17:16,959
 now natural total order is

796
00:17:14,549 --> 00:17:16,959
 

797
00:17:14,559 --> 00:17:19,120
 another relationship the natural total

798
00:17:16,949 --> 00:17:19,120
 

799
00:17:16,959 --> 00:17:21,360
 order is a total order that respects

800
00:17:19,110 --> 00:17:21,360
 

801
00:17:19,120 --> 00:17:22,240
 the other fundamental operations of the

802
00:17:21,350 --> 00:17:22,240
 

803
00:17:21,360 --> 00:17:24,000
 type

804
00:17:22,230 --> 00:17:24,000
 

805
00:17:22,240 --> 00:17:25,280
 a total order has the following

806
00:17:23,990 --> 00:17:25,280
 

807
00:17:24,000 --> 00:17:27,520
 properties

808
00:17:25,270 --> 00:17:27,520
 

809
00:17:25,280 --> 00:17:30,880
 it obeys the trichotomy law which means

810
00:17:27,510 --> 00:17:30,880
 

811
00:17:27,520 --> 00:17:34,000
 that either something is less than

812
00:17:30,870 --> 00:17:34,000
 

813
00:17:30,880 --> 00:17:35,120
 uh another object that object is less

814
00:17:33,990 --> 00:17:35,120
 

815
00:17:34,000 --> 00:17:39,039
 than the first object

816
00:17:35,110 --> 00:17:39,039
 

817
00:17:35,120 --> 00:17:40,640
 or the two are equal it also obeys the

818
00:17:39,029 --> 00:17:40,640
 

819
00:17:39,039 --> 00:17:43,360
 transitivity law

820
00:17:40,630 --> 00:17:43,360
 

821
00:17:40,640 --> 00:17:44,320
 meaning that if a is less than b and b

822
00:17:43,350 --> 00:17:44,320
 

823
00:17:43,360 --> 00:17:48,400
 is less than c

824
00:17:44,310 --> 00:17:48,400
 

825
00:17:44,320 --> 00:17:48,400
 then that implies that a is less than c

826
00:17:51,350 --> 00:17:51,350
 

827
00:17:51,360 --> 00:17:54,559
 here example with our integers less than

828
00:17:54,150 --> 00:17:54,559
 

829
00:17:54,160 --> 00:17:58,480
 is

830
00:17:54,549 --> 00:17:58,480
 

831
00:17:54,559 --> 00:18:02,320
 consistent with addition so for all a's

832
00:17:58,470 --> 00:18:02,320
 

833
00:17:58,480 --> 00:18:02,320
 for all integer value a's in

834
00:18:03,029 --> 00:18:03,029
 

835
00:18:03,039 --> 00:18:06,720
 n is less than n plus one

836
00:18:09,909 --> 00:18:09,909
 

837
00:18:09,919 --> 00:18:16,559
 now concepts are

838
00:18:13,029 --> 00:18:16,559
 

839
00:18:13,039 --> 00:18:18,320
 quantified axioms or quantified axioms

840
00:18:16,549 --> 00:18:18,320
 

841
00:18:16,559 --> 00:18:19,600
 are generally not actionable so a

842
00:18:18,310 --> 00:18:19,600
 

843
00:18:18,320 --> 00:18:23,120
 quantified axiom

844
00:18:19,590 --> 00:18:23,120
 

845
00:18:19,600 --> 00:18:26,559
 is uh for all a

846
00:18:23,110 --> 00:18:26,559
 

847
00:18:23,120 --> 00:18:28,640
 or for all elements in a set

848
00:18:26,549 --> 00:18:28,640
 

849
00:18:26,559 --> 00:18:30,240
 so how do we represent those within a

850
00:18:28,630 --> 00:18:30,240
 

851
00:18:28,640 --> 00:18:33,039
 language

852
00:18:30,230 --> 00:18:33,039
 

853
00:18:30,240 --> 00:18:35,360
 well within c plus plus 20 what we do is

854
00:18:33,029 --> 00:18:35,360
 

855
00:18:33,039 --> 00:18:38,320
 we associate the semantics with the name

856
00:18:35,350 --> 00:18:38,320
 

857
00:18:35,360 --> 00:18:38,320
 of an operation

858
00:18:38,470 --> 00:18:38,470
 

859
00:18:38,480 --> 00:18:44,799
 right software

860
00:18:42,310 --> 00:18:44,799
 

861
00:18:42,320 --> 00:18:46,480
 is defined on algebraic structures

862
00:18:44,789 --> 00:18:46,480
 

863
00:18:44,799 --> 00:18:49,440
 that's what software

864
00:18:46,470 --> 00:18:49,440
 

865
00:18:46,480 --> 00:18:49,440
 fundamentally is

866
00:18:51,029 --> 00:18:51,029
 

867
00:18:51,039 --> 00:18:55,200
 i think it's important to also

868
00:18:53,029 --> 00:18:55,200
 

869
00:18:53,039 --> 00:18:58,160
 understand contracts and how they differ

870
00:18:55,190 --> 00:18:58,160
 

871
00:18:55,200 --> 00:18:58,160
 from concepts

872
00:18:58,470 --> 00:18:58,470
 

873
00:18:58,480 --> 00:19:04,880
 contracts was

874
00:19:01,510 --> 00:19:04,880
 

875
00:19:01,520 --> 00:19:07,760
 first coined by bertrand meyer in this

876
00:19:04,870 --> 00:19:07,760
 

877
00:19:04,880 --> 00:19:10,080
 paper applying design by contracts

878
00:19:07,750 --> 00:19:10,080
 

879
00:19:07,760 --> 00:19:11,200
 it also has its roots though in

880
00:19:10,070 --> 00:19:11,200
 

881
00:19:10,080 --> 00:19:14,880
 horologic

882
00:19:11,190 --> 00:19:14,880
 

883
00:19:11,200 --> 00:19:18,080
 from tony horse paper

884
00:19:14,870 --> 00:19:18,080
 

885
00:19:14,880 --> 00:19:18,080
 that's a picture of bertrand

886
00:19:22,950 --> 00:19:22,950
 

887
00:19:22,960 --> 00:19:27,039
 contracts were originally part of the

888
00:19:24,710 --> 00:19:27,039
 

889
00:19:24,720 --> 00:19:29,200
 eiffel programming language

890
00:19:27,029 --> 00:19:29,200
 

891
00:19:27,039 --> 00:19:31,200
 and contracts allow the specification of

892
00:19:29,190 --> 00:19:31,200
 

893
00:19:29,200 --> 00:19:33,919
 constraints

894
00:19:31,190 --> 00:19:33,919
 

895
00:19:31,200 --> 00:19:35,360
 preconditions for a function used

896
00:19:33,909 --> 00:19:35,360
 

897
00:19:33,919 --> 00:19:38,320
 require clause

898
00:19:35,350 --> 00:19:38,320
 

899
00:19:35,360 --> 00:19:39,280
 post conditions used in ensure clause

900
00:19:38,310 --> 00:19:39,280
 

901
00:19:38,320 --> 00:19:40,720
 and

902
00:19:39,270 --> 00:19:40,720
 

903
00:19:39,280 --> 00:19:43,840
 class and variants could also be

904
00:19:40,710 --> 00:19:43,840
 

905
00:19:40,720 --> 00:19:43,840
 specified on a class

906
00:19:47,270 --> 00:19:47,270
 

907
00:19:47,280 --> 00:19:53,840
 contracts are actionable predicates on

908
00:19:50,830 --> 00:19:53,840
 

909
00:19:50,840 --> 00:19:53,840
 values

910
00:19:54,310 --> 00:19:54,310
 

911
00:19:54,320 --> 00:19:59,840
 now bertrand myers understood the

912
00:19:57,750 --> 00:19:59,840
 

913
00:19:57,760 --> 00:20:02,480
 limitations of that

914
00:19:59,830 --> 00:20:02,480
 

915
00:19:59,840 --> 00:20:04,000
 and this is a quote from his paper in

916
00:20:02,470 --> 00:20:04,000
 

917
00:20:02,480 --> 00:20:05,840
 some cases

918
00:20:03,990 --> 00:20:05,840
 

919
00:20:04,000 --> 00:20:07,440
 one might want to use quantified

920
00:20:05,830 --> 00:20:07,440
 

921
00:20:05,840 --> 00:20:10,720
 expressions of the form

922
00:20:07,430 --> 00:20:10,720
 

923
00:20:07,440 --> 00:20:13,280
 for all x of type t p x holds

924
00:20:10,710 --> 00:20:13,280
 

925
00:20:10,720 --> 00:20:14,480
 or there exists x of type t such that p

926
00:20:13,270 --> 00:20:14,480
 

927
00:20:13,280 --> 00:20:17,200
 x holds

928
00:20:14,470 --> 00:20:17,200
 

929
00:20:14,480 --> 00:20:19,039
 where p is a certain boolean property

930
00:20:17,190 --> 00:20:19,039
 

931
00:20:17,200 --> 00:20:21,840
 such expressions are not available in

932
00:20:19,029 --> 00:20:21,840
 

933
00:20:19,039 --> 00:20:21,840
 eiffel

934
00:20:22,710 --> 00:20:22,710
 

935
00:20:22,720 --> 00:20:26,159
 so concepts describe relationships

936
00:20:24,549 --> 00:20:26,159
 

937
00:20:24,559 --> 00:20:28,080
 between operations on a type

938
00:20:26,149 --> 00:20:28,080
 

939
00:20:26,159 --> 00:20:29,520
 and contracts describe relationships

940
00:20:28,070 --> 00:20:29,520
 

941
00:20:28,080 --> 00:20:32,559
 between values

942
00:20:29,510 --> 00:20:32,559
 

943
00:20:29,520 --> 00:20:33,440
 the distinction is not always clear for

944
00:20:32,549 --> 00:20:33,440
 

945
00:20:32,559 --> 00:20:36,000
 example

946
00:20:33,430 --> 00:20:36,000
 

947
00:20:33,440 --> 00:20:36,799
 the comparison operation passed to std

948
00:20:35,990 --> 00:20:36,799
 

949
00:20:36,000 --> 00:20:38,799
 sort

950
00:20:36,789 --> 00:20:38,799
 

951
00:20:36,799 --> 00:20:42,400
 must implement a strict weak ordering

952
00:20:38,789 --> 00:20:42,400
 

953
00:20:38,799 --> 00:20:44,400
 relation over the values being sorted

954
00:20:42,390 --> 00:20:44,400
 

955
00:20:42,400 --> 00:20:45,679
 all right so is that a precondition or

956
00:20:44,390 --> 00:20:45,679
 

957
00:20:44,400 --> 00:20:48,159
 is that a concept

958
00:20:45,669 --> 00:20:48,159
 

959
00:20:45,679 --> 00:20:50,480
 it falls a bit in between maybe it's

960
00:20:48,149 --> 00:20:50,480
 

961
00:20:48,159 --> 00:20:50,480
 both

962
00:20:51,990 --> 00:20:51,990
 

963
00:20:52,000 --> 00:20:55,679
 concepts are used as a compile time

964
00:20:54,870 --> 00:20:55,679
 

965
00:20:54,880 --> 00:20:59,200
 constraint

966
00:20:55,669 --> 00:20:59,200
 

967
00:20:55,679 --> 00:20:59,200
 to select an operation

968
00:20:59,830 --> 00:20:59,830
 

969
00:20:59,840 --> 00:21:03,760
 contracts assert at run time if an

970
00:21:02,230 --> 00:21:03,760
 

971
00:21:02,240 --> 00:21:05,760
 operations preconditions

972
00:21:03,750 --> 00:21:05,760
 

973
00:21:03,760 --> 00:21:08,960
 are not met or their post conditions or

974
00:21:05,750 --> 00:21:08,960
 

975
00:21:05,760 --> 00:21:08,960
 invariants are violated

976
00:21:09,590 --> 00:21:09,590
 

977
00:21:09,600 --> 00:21:13,520
 a run time constraint to select an

978
00:21:11,830 --> 00:21:13,520
 

979
00:21:11,840 --> 00:21:16,960
 appropriate operation is known as

980
00:21:13,510 --> 00:21:16,960
 

981
00:21:13,520 --> 00:21:20,480
 pattern matching

982
00:21:16,950 --> 00:21:20,480
 

983
00:21:16,960 --> 00:21:23,919
 right so in c plus plus 20

984
00:21:20,470 --> 00:21:23,919
 

985
00:21:20,480 --> 00:21:27,520
 we have something like this

986
00:21:23,909 --> 00:21:27,520
 

987
00:21:23,919 --> 00:21:30,880
 where we say that we have

988
00:21:27,510 --> 00:21:30,880
 

989
00:21:27,520 --> 00:21:33,600
 a function which takes a variable i

990
00:21:30,870 --> 00:21:33,600
 

991
00:21:30,880 --> 00:21:35,520
 and the double requires clause there

992
00:21:33,590 --> 00:21:35,520
 

993
00:21:33,600 --> 00:21:36,480
 allows us to say that this is a valid

994
00:21:35,510 --> 00:21:36,480
 

995
00:21:35,520 --> 00:21:39,840
 expression

996
00:21:36,470 --> 00:21:39,840
 

997
00:21:36,480 --> 00:21:43,039
 that not i is uh

998
00:21:39,830 --> 00:21:43,039
 

999
00:21:39,840 --> 00:21:45,039
 less than zero although that's a valid

1000
00:21:43,029 --> 00:21:45,039
 

1001
00:21:43,039 --> 00:21:45,919
 expression it doesn't actually compare

1002
00:21:45,029 --> 00:21:45,919
 

1003
00:21:45,039 --> 00:21:48,240
 any values

1004
00:21:45,909 --> 00:21:48,240
 

1005
00:21:45,919 --> 00:21:50,240
 it's just saying that there must be a

1006
00:21:48,230 --> 00:21:50,240
 

1007
00:21:48,240 --> 00:21:51,600
 less than operator there must be a not

1008
00:21:50,230 --> 00:21:51,600
 

1009
00:21:50,240 --> 00:21:52,720
 operator on the result of that

1010
00:21:51,590 --> 00:21:52,720
 

1011
00:21:51,600 --> 00:21:54,640
 expression

1012
00:21:52,710 --> 00:21:54,640
 

1013
00:21:52,720 --> 00:21:56,480
 and that the less than operator has to

1014
00:21:54,630 --> 00:21:56,480
 

1015
00:21:54,640 --> 00:21:58,640
 take i on one side and is

1016
00:21:56,470 --> 00:21:58,640
 

1017
00:21:56,480 --> 00:22:00,480
 and a constant zero on the other to be

1018
00:21:58,630 --> 00:22:00,480
 

1019
00:21:58,640 --> 00:22:02,400
 valid

1020
00:22:00,470 --> 00:22:02,400
 

1021
00:22:00,480 --> 00:22:04,480
 the semantics of that come through in

1022
00:22:02,390 --> 00:22:04,480
 

1023
00:22:02,400 --> 00:22:06,720
 the definition of what less than and not

1024
00:22:04,470 --> 00:22:06,720
 

1025
00:22:04,480 --> 00:22:06,720
 mean

1026
00:22:08,149 --> 00:22:08,149
 

1027
00:22:08,159 --> 00:22:12,080
 if we had contracts we could write

1028
00:22:09,909 --> 00:22:12,080
 

1029
00:22:09,919 --> 00:22:13,840
 something like this

1030
00:22:12,070 --> 00:22:13,840
 

1031
00:22:12,080 --> 00:22:16,559
 that we have a function f that takes an

1032
00:22:13,830 --> 00:22:16,559
 

1033
00:22:13,840 --> 00:22:20,640
 int i and that we expect

1034
00:22:16,549 --> 00:22:20,640
 

1035
00:22:16,559 --> 00:22:23,440
 that i that i is not less than zero

1036
00:22:20,630 --> 00:22:23,440
 

1037
00:22:20,640 --> 00:22:27,840
 in this case if that were were violated

1038
00:22:23,430 --> 00:22:27,840
 

1039
00:22:23,440 --> 00:22:27,840
 the program would assert

1040
00:22:28,710 --> 00:22:28,710
 

1041
00:22:28,720 --> 00:22:32,880
 now one could imagine

1042
00:22:33,590 --> 00:22:33,590
 

1043
00:22:33,600 --> 00:22:37,840
 another form of this which would be just

1044
00:22:36,470 --> 00:22:37,840
 

1045
00:22:36,480 --> 00:22:40,480
 to combine the two

1046
00:22:37,830 --> 00:22:40,480
 

1047
00:22:37,840 --> 00:22:42,640
 where i could say that i had a function

1048
00:22:40,470 --> 00:22:42,640
 

1049
00:22:40,480 --> 00:22:46,480
 f that takes an integer i

1050
00:22:42,630 --> 00:22:46,480
 

1051
00:22:42,640 --> 00:22:46,480
 that required that

1052
00:22:48,310 --> 00:22:48,310
 

1053
00:22:48,320 --> 00:22:53,200
 my i is not less than zero and so if i

1054
00:22:51,270 --> 00:22:53,200
 

1055
00:22:51,280 --> 00:22:56,000
 try to call this function with a value

1056
00:22:53,190 --> 00:22:56,000
 

1057
00:22:53,200 --> 00:22:59,039
 where i was not less than zero

1058
00:22:55,990 --> 00:22:59,039
 

1059
00:22:56,000 --> 00:23:02,159
 the function wouldn't be found and

1060
00:22:59,029 --> 00:23:02,159
 

1061
00:22:59,039 --> 00:23:06,840
 and at runtime we would look for

1062
00:23:02,149 --> 00:23:06,840
 

1063
00:23:02,159 --> 00:23:09,840
 a function where the required clause did

1064
00:23:06,830 --> 00:23:09,840
 

1065
00:23:06,840 --> 00:23:09,840
 match

1066
00:23:12,230 --> 00:23:12,230
 

1067
00:23:12,240 --> 00:23:15,440
 so let's talk a little bit about a very

1068
00:23:14,230 --> 00:23:15,440
 

1069
00:23:14,240 --> 00:23:17,679
 important relationship

1070
00:23:15,430 --> 00:23:17,679
 

1071
00:23:15,440 --> 00:23:23,840
 known as the whole part relationship in

1072
00:23:17,669 --> 00:23:23,840
 

1073
00:23:17,679 --> 00:23:23,840
 composite objects

1074
00:23:24,310 --> 00:23:24,310
 

1075
00:23:24,320 --> 00:23:28,559
 right we talked before about

1076
00:23:28,789 --> 00:23:28,789
 

1077
00:23:28,799 --> 00:23:34,000
 the semantics of copy and equality

1078
00:23:32,149 --> 00:23:34,000
 

1079
00:23:32,159 --> 00:23:36,080
 in a whole part relationship what we

1080
00:23:33,990 --> 00:23:36,080
 

1081
00:23:34,000 --> 00:23:38,400
 have is a whole object

1082
00:23:36,070 --> 00:23:38,400
 

1083
00:23:36,080 --> 00:23:39,679
 that's composed of parts those parts can

1084
00:23:38,390 --> 00:23:39,679
 

1085
00:23:38,400 --> 00:23:42,720
 either be local

1086
00:23:39,669 --> 00:23:42,720
 

1087
00:23:39,679 --> 00:23:44,960
 or they can be remote

1088
00:23:42,710 --> 00:23:44,960
 

1089
00:23:42,720 --> 00:23:44,960
 so

1090
00:23:46,470 --> 00:23:46,470
 

1091
00:23:46,480 --> 00:23:50,640
 within a whole part relationship the

1092
00:23:48,149 --> 00:23:50,640
 

1093
00:23:48,159 --> 00:23:53,840
 object is connected

1094
00:23:50,630 --> 00:23:53,840
 

1095
00:23:50,640 --> 00:23:53,840
 it's non-circular

1096
00:23:54,070 --> 00:23:54,070
 

1097
00:23:54,080 --> 00:24:00,000
 that's not allowed it's logically

1098
00:23:57,430 --> 00:24:00,000
 

1099
00:23:57,440 --> 00:24:03,039
 disjoint

1100
00:23:59,990 --> 00:24:03,039
 

1101
00:24:00,000 --> 00:24:05,600
 so that's not allowed and it's an

1102
00:24:03,029 --> 00:24:05,600
 

1103
00:24:03,039 --> 00:24:07,520
 owning relationship so if i copy the

1104
00:24:05,590 --> 00:24:07,520
 

1105
00:24:05,600 --> 00:24:10,799
 object

1106
00:24:07,510 --> 00:24:10,799
 

1107
00:24:07,520 --> 00:24:10,799
 all of the parts are copied

1108
00:24:11,190 --> 00:24:11,190
 

1109
00:24:11,200 --> 00:24:18,880
 and if i destroy an object it just

1110
00:24:13,350 --> 00:24:18,880
 

1111
00:24:13,360 --> 00:24:20,799
 destroys the one object

1112
00:24:18,870 --> 00:24:20,799
 

1113
00:24:18,880 --> 00:24:21,919
 the standard containers are composite

1114
00:24:20,789 --> 00:24:21,919
 

1115
00:24:20,799 --> 00:24:23,840
 objects

1116
00:24:21,909 --> 00:24:23,840
 

1117
00:24:21,919 --> 00:24:26,000
 composite objects allow us to reason

1118
00:24:23,830 --> 00:24:26,000
 

1119
00:24:23,840 --> 00:24:29,039
 about a collection of objects as if it

1120
00:24:25,990 --> 00:24:29,039
 

1121
00:24:26,000 --> 00:24:29,039
 were a single entity

1122
00:24:31,350 --> 00:24:31,350
 

1123
00:24:31,360 --> 00:24:34,960
 this is why in my data structures talk i

1124
00:24:33,990 --> 00:24:34,960
 

1125
00:24:34,000 --> 00:24:38,559
 have the goal

1126
00:24:34,950 --> 00:24:38,559
 

1127
00:24:34,960 --> 00:24:42,400
 no incidental data structures right

1128
00:24:38,549 --> 00:24:42,400
 

1129
00:24:38,559 --> 00:24:45,360
 here is a view class that contains a

1130
00:24:42,390 --> 00:24:45,360
 

1131
00:24:42,400 --> 00:24:48,960
 shared pointer to other view classes

1132
00:24:45,350 --> 00:24:48,960
 

1133
00:24:45,360 --> 00:24:49,760
 and it's got a weak pointer to its

1134
00:24:48,950 --> 00:24:49,760
 

1135
00:24:48,960 --> 00:24:53,120
 parent

1136
00:24:49,750 --> 00:24:53,120
 

1137
00:24:49,760 --> 00:24:53,120
 forming a hierarchy

1138
00:24:53,350 --> 00:24:53,350
 

1139
00:24:53,360 --> 00:25:00,400
 instead i recommend using a container

1140
00:24:56,789 --> 00:25:00,400
 

1141
00:24:56,799 --> 00:25:03,279
 something like adobe forest which is a

1142
00:25:00,390 --> 00:25:03,279
 

1143
00:25:00,400 --> 00:25:06,559
 container class within the asl libraries

1144
00:25:03,269 --> 00:25:06,559
 

1145
00:25:03,279 --> 00:25:06,559
 to represent a hierarchy

1146
00:25:07,830 --> 00:25:07,830
 

1147
00:25:07,840 --> 00:25:11,520
 and now we can reason about that

1148
00:25:09,590 --> 00:25:11,520
 

1149
00:25:09,600 --> 00:25:15,840
 collection of views as if it were a

1150
00:25:11,510 --> 00:25:15,840
 

1151
00:25:11,520 --> 00:25:15,840
 single object

1152
00:25:17,029 --> 00:25:17,029
 

1153
00:25:17,039 --> 00:25:24,080
 in my c plus seasoning talk i introduced

1154
00:25:20,950 --> 00:25:24,080
 

1155
00:25:20,960 --> 00:25:26,320
 the idea of no raw loops

1156
00:25:24,070 --> 00:25:26,320
 

1157
00:25:24,080 --> 00:25:27,200
 and i gave this example this was actual

1158
00:25:26,310 --> 00:25:27,200
 

1159
00:25:26,320 --> 00:25:30,880
 code

1160
00:25:27,190 --> 00:25:30,880
 

1161
00:25:27,200 --> 00:25:30,880
 that was taken from

1162
00:25:30,950 --> 00:25:30,950
 

1163
00:25:30,960 --> 00:25:38,080
 the chromium code base

1164
00:25:35,350 --> 00:25:38,080
 

1165
00:25:35,360 --> 00:25:38,480
 and it might take you a while to figure

1166
00:25:38,070 --> 00:25:38,480
 

1167
00:25:38,080 --> 00:25:41,039
 out

1168
00:25:38,470 --> 00:25:41,039
 

1169
00:25:38,480 --> 00:25:43,039
 exactly what this piece of code is doing

1170
00:25:41,029 --> 00:25:43,039
 

1171
00:25:41,039 --> 00:25:45,039
 and if i told you that this was plopped

1172
00:25:43,029 --> 00:25:45,039
 

1173
00:25:43,039 --> 00:25:46,720
 into the middle of a

1174
00:25:45,029 --> 00:25:46,720
 

1175
00:25:45,039 --> 00:25:48,559
 several hundred line function it would

1176
00:25:46,710 --> 00:25:48,559
 

1177
00:25:46,720 --> 00:25:50,960
 probably take you even more time to make

1178
00:25:48,549 --> 00:25:50,960
 

1179
00:25:48,559 --> 00:25:55,120
 any sense of it

1180
00:25:50,950 --> 00:25:55,120
 

1181
00:25:50,960 --> 00:25:57,520
 well that whole thing is a rotate

1182
00:25:55,110 --> 00:25:57,520
 

1183
00:25:55,120 --> 00:25:59,840
 but once we recognize that and we write

1184
00:25:57,510 --> 00:25:59,840
 

1185
00:25:57,520 --> 00:26:03,360
 the algorithm

1186
00:25:59,830 --> 00:26:03,360
 

1187
00:25:59,840 --> 00:26:06,720
 as a separate entity then that means

1188
00:26:03,350 --> 00:26:06,720
 

1189
00:26:03,360 --> 00:26:09,039
 that we can reason about that as

1190
00:26:06,710 --> 00:26:09,039
 

1191
00:26:06,720 --> 00:26:11,840
 a single relationship within our body of

1192
00:26:09,029 --> 00:26:11,840
 

1193
00:26:09,039 --> 00:26:11,840
 code

1194
00:26:14,549 --> 00:26:14,549
 

1195
00:26:14,559 --> 00:26:21,919
 so now we've looked at at the pieces

1196
00:26:18,230 --> 00:26:21,919
 

1197
00:26:18,240 --> 00:26:23,520
 and the board so we understand what

1198
00:26:21,909 --> 00:26:23,520
 

1199
00:26:21,919 --> 00:26:25,440
 relationships are and we understand what

1200
00:26:23,510 --> 00:26:25,440
 

1201
00:26:23,520 --> 00:26:29,679
 structures are

1202
00:26:25,430 --> 00:26:29,679
 

1203
00:26:25,440 --> 00:26:29,679
 so the next piece is architecture

1204
00:26:33,190 --> 00:26:33,190
 

1205
00:26:33,200 --> 00:26:39,200
 i don't know how many times i have gone

1206
00:26:36,230 --> 00:26:39,200
 

1207
00:26:36,240 --> 00:26:41,279
 into a meeting where somebody's going to

1208
00:26:39,190 --> 00:26:41,279
 

1209
00:26:39,200 --> 00:26:44,240
 tell me about the architecture

1210
00:26:41,269 --> 00:26:44,240
 

1211
00:26:41,279 --> 00:26:46,320
 of their component and this is the

1212
00:26:44,230 --> 00:26:46,320
 

1213
00:26:44,240 --> 00:26:48,159
 presentation i get

1214
00:26:46,310 --> 00:26:48,159
 

1215
00:26:46,320 --> 00:26:52,080
 they say well there are these things

1216
00:26:48,149 --> 00:26:52,080
 

1217
00:26:48,159 --> 00:26:54,320
 that my component depends on

1218
00:26:52,070 --> 00:26:54,320
 

1219
00:26:52,080 --> 00:26:56,960
 and then there's the piece that i'm

1220
00:26:54,310 --> 00:26:56,960
 

1221
00:26:54,320 --> 00:26:56,960
 going to build

1222
00:26:57,029 --> 00:26:57,029
 

1223
00:26:57,039 --> 00:27:01,840
 and then there's all the stuff that's

1224
00:26:58,549 --> 00:27:01,840
 

1225
00:26:58,559 --> 00:27:01,840
 going to be built on top of me

1226
00:27:01,990 --> 00:27:01,990
 

1227
00:27:02,000 --> 00:27:08,960
 so this is not architecture

1228
00:27:06,789 --> 00:27:08,960
 

1229
00:27:06,799 --> 00:27:10,799
 i can draw this diagram about just about

1230
00:27:08,950 --> 00:27:10,799
 

1231
00:27:08,960 --> 00:27:12,480
 anything

1232
00:27:10,789 --> 00:27:12,480
 

1233
00:27:10,799 --> 00:27:14,640
 i can say to build a house i'm going to

1234
00:27:12,470 --> 00:27:14,640
 

1235
00:27:12,480 --> 00:27:17,760
 build the foundation

1236
00:27:14,630 --> 00:27:17,760
 

1237
00:27:14,640 --> 00:27:21,840
 and then i'm going to build the house

1238
00:27:17,750 --> 00:27:21,840
 

1239
00:27:17,760 --> 00:27:21,840
 and then i'm going to put the roof on it

1240
00:27:23,190 --> 00:27:23,190
 

1241
00:27:23,200 --> 00:27:28,159
 but the presentation that i would

1242
00:27:25,269 --> 00:27:28,159
 

1243
00:27:25,279 --> 00:27:28,159
 probably get

1244
00:27:29,669 --> 00:27:29,669
 

1245
00:27:29,679 --> 00:27:32,840
 would look more like this well to build

1246
00:27:31,510 --> 00:27:32,840
 

1247
00:27:31,520 --> 00:27:35,520
 a house we're going to get all the

1248
00:27:32,830 --> 00:27:35,520
 

1249
00:27:32,840 --> 00:27:38,720
 materials

1250
00:27:35,510 --> 00:27:38,720
 

1251
00:27:35,520 --> 00:27:38,720
 and then we're going to build the house

1252
00:27:39,269 --> 00:27:39,269
 

1253
00:27:39,279 --> 00:27:42,960
 and then the family is going to live in

1254
00:27:40,549 --> 00:27:42,960
 

1255
00:27:40,559 --> 00:27:45,279
 the house right

1256
00:27:42,950 --> 00:27:45,279
 

1257
00:27:42,960 --> 00:27:48,320
 so this really doesn't tell you much at

1258
00:27:45,269 --> 00:27:48,320
 

1259
00:27:45,279 --> 00:27:49,840
 all about the architecture

1260
00:27:48,310 --> 00:27:49,840
 

1261
00:27:48,320 --> 00:27:51,919
 sometimes i'll ask could you give me

1262
00:27:49,830 --> 00:27:51,919
 

1263
00:27:49,840 --> 00:27:55,520
 some more detail

1264
00:27:51,909 --> 00:27:55,520
 

1265
00:27:51,919 --> 00:27:56,640
 in which case i'll get this well yes for

1266
00:27:55,510 --> 00:27:56,640
 

1267
00:27:55,520 --> 00:27:59,039
 materials we're going to have some

1268
00:27:56,630 --> 00:27:59,039
 

1269
00:27:56,640 --> 00:27:59,039
 lumber

1270
00:27:59,110 --> 00:27:59,110
 

1271
00:27:59,120 --> 00:28:06,720
 and then some sheetrock

1272
00:28:02,470 --> 00:28:06,720
 

1273
00:28:02,480 --> 00:28:10,480
 and some gravel and i'll ask gravel

1274
00:28:06,710 --> 00:28:10,480
 

1275
00:28:06,720 --> 00:28:12,159
 well yes it's it's really concrete

1276
00:28:10,470 --> 00:28:12,159
 

1277
00:28:10,480 --> 00:28:16,799
 but it started out as gravel and

1278
00:28:12,149 --> 00:28:16,799
 

1279
00:28:12,159 --> 00:28:18,240
 everybody just still calls it gravel

1280
00:28:16,789 --> 00:28:18,240
 

1281
00:28:16,799 --> 00:28:20,720
 and so for the house we're going to have

1282
00:28:18,230 --> 00:28:20,720
 

1283
00:28:18,240 --> 00:28:20,720
 walls

1284
00:28:21,029 --> 00:28:21,029
 

1285
00:28:21,039 --> 00:28:26,080
 and we're going to have utilities and

1286
00:28:23,750 --> 00:28:26,080
 

1287
00:28:23,760 --> 00:28:28,960
 and by utilities

1288
00:28:26,070 --> 00:28:28,960
 

1289
00:28:26,080 --> 00:28:30,080
 do you mean you know power and

1290
00:28:28,950 --> 00:28:30,080
 

1291
00:28:28,960 --> 00:28:32,320
 electrical

1292
00:28:30,070 --> 00:28:32,320
 

1293
00:28:30,080 --> 00:28:34,720
 they'll say no no no all the

1294
00:28:32,310 --> 00:28:34,720
 

1295
00:28:32,320 --> 00:28:36,159
 miscellaneous stuff that's not the walls

1296
00:28:34,710 --> 00:28:36,159
 

1297
00:28:34,720 --> 00:28:38,080
 we're going to throw that into our

1298
00:28:36,149 --> 00:28:38,080
 

1299
00:28:36,159 --> 00:28:40,559
 utility library that's where that's

1300
00:28:38,070 --> 00:28:40,559
 

1301
00:28:38,080 --> 00:28:40,559
 going to be

1302
00:28:40,789 --> 00:28:40,789
 

1303
00:28:40,799 --> 00:28:46,960
 and we're going to have carpet

1304
00:28:44,149 --> 00:28:46,960
 

1305
00:28:44,159 --> 00:28:48,399
 and i'll ask well really you're going to

1306
00:28:46,950 --> 00:28:48,399
 

1307
00:28:46,960 --> 00:28:49,679
 make your own carpet they'll say yeah

1308
00:28:48,389 --> 00:28:49,679
 

1309
00:28:48,399 --> 00:28:51,279
 well we couldn't find any carpet of the

1310
00:28:49,669 --> 00:28:51,279
 

1311
00:28:49,679 --> 00:28:52,640
 right color

1312
00:28:51,269 --> 00:28:52,640
 

1313
00:28:51,279 --> 00:28:54,159
 so we're going to make our own carpet

1314
00:28:52,630 --> 00:28:54,159
 

1315
00:28:52,640 --> 00:28:55,919
 how hard could it be it's just a lot of

1316
00:28:54,149 --> 00:28:55,919
 

1317
00:28:54,159 --> 00:28:56,399
 fiber glued together so we think that's

1318
00:28:55,909 --> 00:28:56,399
 

1319
00:28:55,919 --> 00:28:58,080
 going to

1320
00:28:56,389 --> 00:28:58,080
 

1321
00:28:56,399 --> 00:29:00,399
 be pretty easy and not take too much

1322
00:28:58,070 --> 00:29:00,399
 

1323
00:28:58,080 --> 00:29:00,399
 time

1324
00:29:01,029 --> 00:29:01,029
 

1325
00:29:01,039 --> 00:29:04,559
 and i'll ask okay well what about the

1326
00:29:02,470 --> 00:29:04,559
 

1327
00:29:02,480 --> 00:29:07,919
 family they'll say we're going to have

1328
00:29:04,549 --> 00:29:07,919
 

1329
00:29:04,559 --> 00:29:07,919
 two adults living in our house

1330
00:29:08,070 --> 00:29:08,070
 

1331
00:29:08,080 --> 00:29:15,200
 one child and an iguana

1332
00:29:13,190 --> 00:29:15,200
 

1333
00:29:13,200 --> 00:29:16,799
 like an iguana that seems unusual

1334
00:29:15,190 --> 00:29:16,799
 

1335
00:29:15,200 --> 00:29:18,880
 they'll say yeah well our designer has

1336
00:29:16,789 --> 00:29:18,880
 

1337
00:29:16,799 --> 00:29:19,760
 an iguana so that's the placeholder that

1338
00:29:18,870 --> 00:29:19,760
 

1339
00:29:18,880 --> 00:29:23,440
 we're using for

1340
00:29:19,750 --> 00:29:23,440
 

1341
00:29:19,760 --> 00:29:23,440
 any pet in all of our designs

1342
00:29:23,990 --> 00:29:23,990
 

1343
00:29:24,000 --> 00:29:28,080
 i'm sure some of you have been through

1344
00:29:26,310 --> 00:29:28,080
 

1345
00:29:26,320 --> 00:29:30,799
 an architecture meeting

1346
00:29:28,070 --> 00:29:30,799
 

1347
00:29:28,080 --> 00:29:30,799
 of this kind

1348
00:29:31,510 --> 00:29:31,510
 

1349
00:29:31,520 --> 00:29:34,720
 now we would like to think that software

1350
00:29:33,830 --> 00:29:34,720
 

1351
00:29:33,840 --> 00:29:36,320
 architecture

1352
00:29:34,710 --> 00:29:36,320
 

1353
00:29:34,720 --> 00:29:38,080
 looks like this like building

1354
00:29:36,310 --> 00:29:38,080
 

1355
00:29:36,320 --> 00:29:40,159
 architectures where you have these

1356
00:29:38,070 --> 00:29:40,159
 

1357
00:29:38,080 --> 00:29:41,840
 beautiful diagrams that get developed

1358
00:29:40,149 --> 00:29:41,840
 

1359
00:29:40,159 --> 00:29:44,080
 before you even start

1360
00:29:41,830 --> 00:29:44,080
 

1361
00:29:41,840 --> 00:29:45,440
 building and a complete plan going

1362
00:29:44,070 --> 00:29:45,440
 

1363
00:29:44,080 --> 00:29:48,799
 forward

1364
00:29:45,430 --> 00:29:48,799
 

1365
00:29:45,440 --> 00:29:50,480
 but in reality software arc or whenever

1366
00:29:48,789 --> 00:29:50,480
 

1367
00:29:48,799 --> 00:29:52,840
 i put that up people say oh yes well we

1368
00:29:50,470 --> 00:29:52,840
 

1369
00:29:50,480 --> 00:29:56,320
 use uml

1370
00:29:52,830 --> 00:29:56,320
 

1371
00:29:52,840 --> 00:29:58,640
 um uh uh which is nice it's at least not

1372
00:29:56,310 --> 00:29:58,640
 

1373
00:29:56,320 --> 00:30:01,679
 a content free

1374
00:29:58,630 --> 00:30:01,679
 

1375
00:29:58,640 --> 00:30:03,039
 diagram like a layer cake diagram

1376
00:30:01,669 --> 00:30:03,039
 

1377
00:30:01,679 --> 00:30:05,440
 but really that doesn't tell the whole

1378
00:30:03,029 --> 00:30:05,440
 

1379
00:30:03,039 --> 00:30:07,760
 story either right you have some uml but

1380
00:30:05,430 --> 00:30:07,760
 

1381
00:30:05,440 --> 00:30:09,360
 you also need er diagrams and flowcharts

1382
00:30:07,750 --> 00:30:09,360
 

1383
00:30:07,760 --> 00:30:11,919
 and dependency graphs and

1384
00:30:09,350 --> 00:30:11,919
 

1385
00:30:09,360 --> 00:30:13,520
 swim lanes and state machines and

1386
00:30:11,909 --> 00:30:13,520
 

1387
00:30:11,919 --> 00:30:16,320
 there's a lot more information that goes

1388
00:30:13,510 --> 00:30:16,320
 

1389
00:30:13,520 --> 00:30:18,000
 into the architecture

1390
00:30:16,310 --> 00:30:18,000
 

1391
00:30:16,320 --> 00:30:19,760
 most software architecture looks more

1392
00:30:17,990 --> 00:30:19,760
 

1393
00:30:18,000 --> 00:30:23,520
 like this

1394
00:30:19,750 --> 00:30:23,520
 

1395
00:30:19,760 --> 00:30:27,840
 and in fact i think if you walk into

1396
00:30:23,510 --> 00:30:27,840
 

1397
00:30:23,520 --> 00:30:27,840
 a senior architect

1398
00:30:28,070 --> 00:30:28,070
 

1399
00:30:28,080 --> 00:30:31,840
 architect's office of somebody who works

1400
00:30:30,710 --> 00:30:31,840
 

1401
00:30:30,720 --> 00:30:35,360
 on a big product

1402
00:30:31,830 --> 00:30:35,360
 

1403
00:30:31,840 --> 00:30:37,039
 and ask him how the software in that

1404
00:30:35,350 --> 00:30:37,039
 

1405
00:30:35,360 --> 00:30:38,480
 product works

1406
00:30:37,029 --> 00:30:38,480
 

1407
00:30:37,039 --> 00:30:41,200
 he's going to go up to the white board

1408
00:30:38,470 --> 00:30:41,200
 

1409
00:30:38,480 --> 00:30:44,080
 with a red marker and draw a diagram

1410
00:30:41,190 --> 00:30:44,080
 

1411
00:30:41,200 --> 00:30:46,080
 that's going to look something like that

1412
00:30:44,070 --> 00:30:46,080
 

1413
00:30:44,080 --> 00:30:48,320
 in fact if you walked into my office and

1414
00:30:46,070 --> 00:30:48,320
 

1415
00:30:46,080 --> 00:30:50,080
 asked me how photoshop worked

1416
00:30:48,310 --> 00:30:50,080
 

1417
00:30:48,320 --> 00:30:51,760
 i would give you a presentation

1418
00:30:50,070 --> 00:30:51,760
 

1419
00:30:50,080 --> 00:30:53,360
 something like this

1420
00:30:51,750 --> 00:30:53,360
 

1421
00:30:51,760 --> 00:30:55,760
 i would say well let's start with a

1422
00:30:53,350 --> 00:30:55,760
 

1423
00:30:53,360 --> 00:30:57,440
 document so a photoshop document you

1424
00:30:55,750 --> 00:30:57,440
 

1425
00:30:55,760 --> 00:30:59,919
 think about it as an image

1426
00:30:57,430 --> 00:30:59,919
 

1427
00:30:57,440 --> 00:31:01,519
 but an image is composed of multiple

1428
00:30:59,909 --> 00:31:01,519
 

1429
00:30:59,919 --> 00:31:03,039
 layers

1430
00:31:01,509 --> 00:31:03,039
 

1431
00:31:01,519 --> 00:31:04,640
 and those layers are composed of

1432
00:31:03,029 --> 00:31:04,640
 

1433
00:31:03,039 --> 00:31:07,279
 multiple channels

1434
00:31:04,630 --> 00:31:07,279
 

1435
00:31:04,640 --> 00:31:10,559
 and well we break those channels up into

1436
00:31:07,269 --> 00:31:10,559
 

1437
00:31:07,279 --> 00:31:10,559
 a whole bunch of tiles

1438
00:31:10,789 --> 00:31:10,789
 

1439
00:31:10,799 --> 00:31:14,240
 now between the layers those tiles don't

1440
00:31:12,789 --> 00:31:14,240
 

1441
00:31:12,799 --> 00:31:16,480
 necessarily align

1442
00:31:14,230 --> 00:31:16,480
 

1443
00:31:14,240 --> 00:31:17,360
 because we want you to be able to to

1444
00:31:16,470 --> 00:31:17,360
 

1445
00:31:16,480 --> 00:31:19,600
 drag

1446
00:31:17,350 --> 00:31:19,600
 

1447
00:31:17,360 --> 00:31:21,919
 a layer layer around without having to

1448
00:31:19,590 --> 00:31:21,919
 

1449
00:31:19,600 --> 00:31:25,440
 move all the memory

1450
00:31:21,909 --> 00:31:25,440
 

1451
00:31:21,919 --> 00:31:28,960
 now for each one

1452
00:31:25,430 --> 00:31:28,960
 

1453
00:31:25,440 --> 00:31:31,519
 of of those channels

1454
00:31:28,950 --> 00:31:31,519
 

1455
00:31:28,960 --> 00:31:32,399
 we build a mipmap which is a downsampled

1456
00:31:31,509 --> 00:31:32,399
 

1457
00:31:31,519 --> 00:31:34,480
 pyramid

1458
00:31:32,389 --> 00:31:34,480
 

1459
00:31:32,399 --> 00:31:36,559
 of all of those so that we can render at

1460
00:31:34,470 --> 00:31:36,559
 

1461
00:31:34,480 --> 00:31:39,919
 various resolutions

1462
00:31:36,549 --> 00:31:39,919
 

1463
00:31:36,559 --> 00:31:42,960
 very quickly oh and by the way

1464
00:31:39,909 --> 00:31:42,960
 

1465
00:31:39,919 --> 00:31:45,919
 all of those tiles are managed by a copy

1466
00:31:42,950 --> 00:31:45,919
 

1467
00:31:42,960 --> 00:31:47,440
 on right mechanism so every time you do

1468
00:31:45,909 --> 00:31:47,440
 

1469
00:31:45,919 --> 00:31:48,000
 an operation on your document we're

1470
00:31:47,430 --> 00:31:48,000
 

1471
00:31:47,440 --> 00:31:50,240
 really just

1472
00:31:47,990 --> 00:31:50,240
 

1473
00:31:48,000 --> 00:31:51,600
 tearing an entire copy of the document

1474
00:31:50,230 --> 00:31:51,600
 

1475
00:31:50,240 --> 00:31:57,519
 and just modifying the

1476
00:31:51,590 --> 00:31:57,519
 

1477
00:31:51,600 --> 00:32:00,720
 the the tiles that you actually changed

1478
00:31:57,509 --> 00:32:00,720
 

1479
00:31:57,519 --> 00:32:05,120
 now all of those tiles

1480
00:32:00,710 --> 00:32:05,120
 

1481
00:32:00,720 --> 00:32:07,679
 those are fed into our

1482
00:32:05,110 --> 00:32:07,679
 

1483
00:32:05,120 --> 00:32:08,159
 compositing engine and the compositing

1484
00:32:07,669 --> 00:32:08,159
 

1485
00:32:07,679 --> 00:32:11,200
 engine

1486
00:32:08,149 --> 00:32:11,200
 

1487
00:32:08,159 --> 00:32:13,120
 is a hierarchical graph where it's

1488
00:32:11,190 --> 00:32:13,120
 

1489
00:32:11,200 --> 00:32:15,679
 compositing everything from

1490
00:32:13,110 --> 00:32:15,679
 

1491
00:32:13,120 --> 00:32:16,640
 in the layers below it with the next

1492
00:32:15,669 --> 00:32:16,640
 

1493
00:32:15,679 --> 00:32:18,960
 layer up

1494
00:32:16,630 --> 00:32:18,960
 

1495
00:32:16,640 --> 00:32:20,720
 and so on and so forth now it's not

1496
00:32:18,950 --> 00:32:20,720
 

1497
00:32:18,960 --> 00:32:22,559
 quite so unbalanced as you would think

1498
00:32:20,710 --> 00:32:22,559
 

1499
00:32:20,720 --> 00:32:24,320
 here because any particular layer can be

1500
00:32:22,549 --> 00:32:24,320
 

1501
00:32:22,559 --> 00:32:26,480
 part of a layer group so it can have its

1502
00:32:24,310 --> 00:32:26,480
 

1503
00:32:24,320 --> 00:32:28,640
 own tree hanging off of it

1504
00:32:26,470 --> 00:32:28,640
 

1505
00:32:26,480 --> 00:32:30,960
 oh and by the way these layers aren't

1506
00:32:28,630 --> 00:32:30,960
 

1507
00:32:28,640 --> 00:32:32,559
 necessarily just a tile layer of pixels

1508
00:32:30,950 --> 00:32:32,559
 

1509
00:32:30,960 --> 00:32:34,080
 but they could be fed from a generator

1510
00:32:32,549 --> 00:32:34,080
 

1511
00:32:32,559 --> 00:32:37,120
 so we can generate pixels from

1512
00:32:34,070 --> 00:32:37,120
 

1513
00:32:34,080 --> 00:32:40,240
 text or from vector artwork or from

1514
00:32:37,110 --> 00:32:40,240
 

1515
00:32:37,120 --> 00:32:44,880
 from a smart filter now

1516
00:32:40,230 --> 00:32:44,880
 

1517
00:32:40,240 --> 00:32:44,880
 as part of the compositing engine

1518
00:32:45,909 --> 00:32:45,909
 

1519
00:32:45,919 --> 00:32:49,440
 that data is also fed through an effects

1520
00:32:48,070 --> 00:32:49,440
 

1521
00:32:48,080 --> 00:32:51,600
 pipeline

1522
00:32:49,430 --> 00:32:51,600
 

1523
00:32:49,440 --> 00:32:52,960
 and so that's this operation where we

1524
00:32:51,590 --> 00:32:52,960
 

1525
00:32:51,600 --> 00:32:56,480
 take a tiny slice

1526
00:32:52,950 --> 00:32:56,480
 

1527
00:32:52,960 --> 00:32:58,000
 of of the image also known as a tile but

1528
00:32:56,470 --> 00:32:58,000
 

1529
00:32:56,480 --> 00:33:00,399
 this is a different tile it's much

1530
00:32:57,990 --> 00:33:00,399
 

1531
00:32:58,000 --> 00:33:02,720
 smaller tends to fit in l1 cache

1532
00:33:00,389 --> 00:33:02,720
 

1533
00:33:00,399 --> 00:33:04,000
 and we feed it through a pipeline of

1534
00:33:02,710 --> 00:33:04,000
 

1535
00:33:02,720 --> 00:33:06,000
 small kernels

1536
00:33:03,990 --> 00:33:06,000
 

1537
00:33:04,000 --> 00:33:08,080
 that can perform various operations like

1538
00:33:05,990 --> 00:33:08,080
 

1539
00:33:06,000 --> 00:33:09,120
 blurs and offsets and tinting and apply

1540
00:33:08,070 --> 00:33:09,120
 

1541
00:33:08,080 --> 00:33:10,640
 textures

1542
00:33:09,110 --> 00:33:10,640
 

1543
00:33:09,120 --> 00:33:12,320
 and that's how you get layer effects

1544
00:33:10,630 --> 00:33:12,320
 

1545
00:33:10,640 --> 00:33:15,600
 inside of photoshop

1546
00:33:12,310 --> 00:33:15,600
 

1547
00:33:12,320 --> 00:33:20,880
 like blur effects and and

1548
00:33:15,590 --> 00:33:20,880
 

1549
00:33:15,600 --> 00:33:20,880
 glows and embossing and beveling

1550
00:33:21,590 --> 00:33:21,590
 

1551
00:33:21,600 --> 00:33:27,360
 oh and that whole compositing engine

1552
00:33:25,029 --> 00:33:27,360
 

1553
00:33:25,039 --> 00:33:28,720
 is driven by our display system at least

1554
00:33:27,350 --> 00:33:28,720
 

1555
00:33:27,360 --> 00:33:30,480
 on mobile

1556
00:33:28,710 --> 00:33:30,480
 

1557
00:33:28,720 --> 00:33:32,320
 this is what the display system looks

1558
00:33:30,470 --> 00:33:32,320
 

1559
00:33:30,480 --> 00:33:34,399
 like we're rendering out to

1560
00:33:32,310 --> 00:33:34,399
 

1561
00:33:32,320 --> 00:33:36,080
 two layers this has nothing to do with

1562
00:33:34,389 --> 00:33:36,080
 

1563
00:33:34,399 --> 00:33:37,760
 the layers within the photoshop document

1564
00:33:36,070 --> 00:33:37,760
 

1565
00:33:36,080 --> 00:33:38,000
 one is background layer which is fairly

1566
00:33:37,750 --> 00:33:38,000
 

1567
00:33:37,760 --> 00:33:40,960
 low

1568
00:33:37,990 --> 00:33:40,960
 

1569
00:33:38,000 --> 00:33:42,559
 resolution and that covers the entire

1570
00:33:40,950 --> 00:33:42,559
 

1571
00:33:40,960 --> 00:33:44,000
 image that way you never see black as

1572
00:33:42,549 --> 00:33:44,000
 

1573
00:33:42,559 --> 00:33:46,559
 you're panning and zooming

1574
00:33:43,990 --> 00:33:46,559
 

1575
00:33:44,000 --> 00:33:49,279
 and the other is tracking the visible

1576
00:33:46,549 --> 00:33:49,279
 

1577
00:33:46,559 --> 00:33:52,480
 area but it's slightly behind

1578
00:33:49,269 --> 00:33:52,480
 

1579
00:33:49,279 --> 00:33:55,679
 that whole thing gets gets

1580
00:33:52,470 --> 00:33:55,679
 

1581
00:33:52,480 --> 00:33:59,120
 driven by our rendering system which is

1582
00:33:55,669 --> 00:33:59,120
 

1583
00:33:55,679 --> 00:34:01,279
 a state machine which is dynamically

1584
00:33:59,110 --> 00:34:01,279
 

1585
00:33:59,120 --> 00:34:03,600
 making requests to the compositing

1586
00:34:01,269 --> 00:34:03,600
 

1587
00:34:01,279 --> 00:34:05,919
 engine to render the pixels based on

1588
00:34:03,590 --> 00:34:05,919
 

1589
00:34:03,600 --> 00:34:09,040
 frame rate and it's written as a state

1590
00:34:05,909 --> 00:34:09,040
 

1591
00:34:05,919 --> 00:34:10,800
 state machine so that it can be adaptive

1592
00:34:09,030 --> 00:34:10,800
 

1593
00:34:09,040 --> 00:34:12,960
 based on the frame weights it's able to

1594
00:34:10,790 --> 00:34:12,960
 

1595
00:34:10,800 --> 00:34:14,960
 achieve it can select rendering from

1596
00:34:12,950 --> 00:34:14,960
 

1597
00:34:12,960 --> 00:34:17,359
 different levels of the pyramid

1598
00:34:14,950 --> 00:34:17,359
 

1599
00:34:14,960 --> 00:34:18,399
 to render faster but it's guaranteed

1600
00:34:17,349 --> 00:34:18,399
 

1601
00:34:17,359 --> 00:34:22,560
 that as this

1602
00:34:18,389 --> 00:34:22,560
 

1603
00:34:18,399 --> 00:34:23,679
 as the requests to render slow down it

1604
00:34:22,550 --> 00:34:23,679
 

1605
00:34:22,560 --> 00:34:26,639
 will always

1606
00:34:23,669 --> 00:34:26,639
 

1607
00:34:23,679 --> 00:34:27,839
 settle out on a final end state where

1608
00:34:26,629 --> 00:34:27,839
 

1609
00:34:26,639 --> 00:34:31,280
 you're looking at good

1610
00:34:27,829 --> 00:34:31,280
 

1611
00:34:27,839 --> 00:34:31,280
 pixels for the entire image

1612
00:34:31,669 --> 00:34:31,669
 

1613
00:34:31,679 --> 00:34:36,960
 oh so this is what the rendering looks

1614
00:34:34,310 --> 00:34:36,960
 

1615
00:34:34,320 --> 00:34:39,919
 like in a set of swim lanes because

1616
00:34:36,950 --> 00:34:39,919
 

1617
00:34:36,960 --> 00:34:41,280
 the compositor is running on one thread

1618
00:34:39,909 --> 00:34:41,280
 

1619
00:34:39,919 --> 00:34:44,000
 and the display system is

1620
00:34:41,270 --> 00:34:44,000
 

1621
00:34:41,280 --> 00:34:45,919
 running on a different thread and so

1622
00:34:43,990 --> 00:34:45,919
 

1623
00:34:44,000 --> 00:34:48,480
 that state machine is managing the

1624
00:34:45,909 --> 00:34:48,480
 

1625
00:34:45,919 --> 00:34:51,280
 interaction between those two threads

1626
00:34:48,470 --> 00:34:51,280
 

1627
00:34:48,480 --> 00:34:52,720
 making requests out to that compositing

1628
00:34:51,270 --> 00:34:52,720
 

1629
00:34:51,280 --> 00:34:55,359
 engine

1630
00:34:52,710 --> 00:34:55,359
 

1631
00:34:52,720 --> 00:34:55,919
 which by the way is written using a

1632
00:34:55,349 --> 00:34:55,919
 

1633
00:34:55,359 --> 00:34:58,320
 forest

1634
00:34:55,909 --> 00:34:58,320
 

1635
00:34:55,919 --> 00:34:58,960
 which is this data structure that i

1636
00:34:58,310 --> 00:34:58,960
 

1637
00:34:58,320 --> 00:35:02,400
 invented

1638
00:34:58,950 --> 00:35:02,400
 

1639
00:34:58,960 --> 00:35:04,720
 when i realized that my young son

1640
00:35:02,390 --> 00:35:04,720
 

1641
00:35:02,400 --> 00:35:05,920
 when he was playing with beads and shoe

1642
00:35:04,710 --> 00:35:05,920
 

1643
00:35:04,720 --> 00:35:08,800
 strings

1644
00:35:05,910 --> 00:35:08,800
 

1645
00:35:05,920 --> 00:35:10,320
 he had one shoe string that had a very

1646
00:35:08,790 --> 00:35:10,320
 

1647
00:35:08,800 --> 00:35:12,880
 tight knot that we couldn't get undone

1648
00:35:10,310 --> 00:35:12,880
 

1649
00:35:10,320 --> 00:35:14,560
 on one end and i realized that with that

1650
00:35:12,870 --> 00:35:14,560
 

1651
00:35:12,880 --> 00:35:15,760
 shoe string the only structure that you

1652
00:35:14,550 --> 00:35:15,760
 

1653
00:35:14,560 --> 00:35:17,200
 could make stringing it through the

1654
00:35:15,750 --> 00:35:17,200
 

1655
00:35:15,760 --> 00:35:19,040
 beads because you could only pass it

1656
00:35:17,190 --> 00:35:19,040
 

1657
00:35:17,200 --> 00:35:22,000
 through the beads one time

1658
00:35:19,030 --> 00:35:22,000
 

1659
00:35:19,040 --> 00:35:22,960
 was hierarchies and so it was a

1660
00:35:21,990 --> 00:35:22,960
 

1661
00:35:22,000 --> 00:35:24,880
 structure where

1662
00:35:22,950 --> 00:35:24,880
 

1663
00:35:22,960 --> 00:35:26,240
 it always enforces the constraint that

1664
00:35:24,870 --> 00:35:26,240
 

1665
00:35:24,880 --> 00:35:28,079
 everything you can build with it is a

1666
00:35:26,230 --> 00:35:28,079
 

1667
00:35:26,240 --> 00:35:29,920
 hierarchy

1668
00:35:28,069 --> 00:35:29,920
 

1669
00:35:28,079 --> 00:35:31,280
 and i mentioned the strings just because

1670
00:35:29,910 --> 00:35:31,280
 

1671
00:35:29,920 --> 00:35:34,880
 yes i'm this guy

1672
00:35:31,270 --> 00:35:34,880
 

1673
00:35:31,280 --> 00:35:36,240
 who in his office draws diagrams on his

1674
00:35:34,870 --> 00:35:36,240
 

1675
00:35:34,880 --> 00:35:38,480
 whiteboard that looks something like

1676
00:35:36,230 --> 00:35:38,480
 

1677
00:35:36,240 --> 00:35:38,480
 that

1678
00:35:41,030 --> 00:35:41,030
 

1679
00:35:41,040 --> 00:35:46,480
 so what is architecture so architecture

1680
00:35:43,910 --> 00:35:46,480
 

1681
00:35:43,920 --> 00:35:49,760
 is the art and practice of designing and

1682
00:35:46,470 --> 00:35:49,760
 

1683
00:35:46,480 --> 00:35:49,760
 constructing structures

1684
00:35:51,430 --> 00:35:51,430
 

1685
00:35:51,440 --> 00:35:55,599
 large structures are built by combining

1686
00:35:53,670 --> 00:35:55,599
 

1687
00:35:53,680 --> 00:35:59,839
 smaller structures which are built by

1688
00:35:55,589 --> 00:35:59,839
 

1689
00:35:55,599 --> 00:35:59,839
 combining even smaller structures

1690
00:36:01,670 --> 00:36:01,670
 

1691
00:36:01,680 --> 00:36:07,040
 before i move on you so you can't

1692
00:36:04,230 --> 00:36:07,040
 

1693
00:36:04,240 --> 00:36:09,040
 understand a large system as a whole

1694
00:36:07,030 --> 00:36:09,040
 

1695
00:36:07,040 --> 00:36:12,160
 unless you can understand each piece of

1696
00:36:09,030 --> 00:36:12,160
 

1697
00:36:09,040 --> 00:36:13,680
 it and how those pieces come together so

1698
00:36:12,150 --> 00:36:13,680
 

1699
00:36:12,160 --> 00:36:14,480
 when i went through the description of

1700
00:36:13,670 --> 00:36:14,480
 

1701
00:36:13,680 --> 00:36:17,680
 photoshop

1702
00:36:14,470 --> 00:36:17,680
 

1703
00:36:14,480 --> 00:36:19,200
 and how photoshop works nobody at this

1704
00:36:17,670 --> 00:36:19,200
 

1705
00:36:17,680 --> 00:36:21,280
 point i think can really get their head

1706
00:36:19,190 --> 00:36:21,280
 

1707
00:36:19,200 --> 00:36:22,960
 around how the entire thing works

1708
00:36:21,270 --> 00:36:22,960
 

1709
00:36:21,280 --> 00:36:25,920
 the only way that you can understand it

1710
00:36:22,950 --> 00:36:25,920
 

1711
00:36:22,960 --> 00:36:27,359
 is by understanding a piece at a time

1712
00:36:25,910 --> 00:36:27,359
 

1713
00:36:25,920 --> 00:36:28,320
 and so when you're architecting the

1714
00:36:27,349 --> 00:36:28,320
 

1715
00:36:27,359 --> 00:36:30,160
 system

1716
00:36:28,310 --> 00:36:30,160
 

1717
00:36:28,320 --> 00:36:32,640
 you have to figure out how do you keep

1718
00:36:30,150 --> 00:36:32,640
 

1719
00:36:30,160 --> 00:36:34,000
 decomposing pieces as they become larger

1720
00:36:32,630 --> 00:36:34,000
 

1721
00:36:32,640 --> 00:36:38,800
 and larger pieces

1722
00:36:33,990 --> 00:36:38,800
 

1723
00:36:34,000 --> 00:36:38,800
 into smaller and smaller pieces and

1724
00:36:39,589 --> 00:36:39,589
 

1725
00:36:39,599 --> 00:36:43,520
 building it up one layer at a time

1726
00:36:43,750 --> 00:36:43,750
 

1727
00:36:43,760 --> 00:36:47,359
 so let's take a look at how we can do

1728
00:36:45,990 --> 00:36:47,359
 

1729
00:36:46,000 --> 00:36:48,880
 that

1730
00:36:47,349 --> 00:36:48,880
 

1731
00:36:47,359 --> 00:36:50,720
 of course i can't take a very large

1732
00:36:48,870 --> 00:36:50,720
 

1733
00:36:48,880 --> 00:36:53,440
 system like photoshop and demonstrate

1734
00:36:50,710 --> 00:36:53,440
 

1735
00:36:50,720 --> 00:36:55,359
 here how we would decompose photoshop

1736
00:36:53,430 --> 00:36:55,359
 

1737
00:36:53,440 --> 00:36:57,119
 so let's take something much smaller and

1738
00:36:55,349 --> 00:36:57,119
 

1739
00:36:55,359 --> 00:36:59,760
 look at how we can decompose it into

1740
00:36:57,109 --> 00:36:59,760
 

1741
00:36:57,119 --> 00:37:03,599
 even something smaller

1742
00:36:59,750 --> 00:37:03,599
 

1743
00:36:59,760 --> 00:37:03,599
 so here was a task that i was given

1744
00:37:03,670 --> 00:37:03,670
 

1745
00:37:03,680 --> 00:37:07,520
 this was an actual thing for for

1746
00:37:05,829 --> 00:37:07,520
 

1747
00:37:05,839 --> 00:37:09,040
 photoshop on ipad which saves

1748
00:37:07,510 --> 00:37:09,040
 

1749
00:37:07,520 --> 00:37:11,440
 automatically

1750
00:37:09,030 --> 00:37:11,440
 

1751
00:37:09,040 --> 00:37:12,079
 so the task was we should save the

1752
00:37:11,430 --> 00:37:12,079
 

1753
00:37:11,440 --> 00:37:14,560
 document

1754
00:37:12,069 --> 00:37:14,560
 

1755
00:37:12,079 --> 00:37:15,599
 every five minutes after the application

1756
00:37:14,550 --> 00:37:15,599
 

1757
00:37:14,560 --> 00:37:19,280
 has been idle

1758
00:37:15,589 --> 00:37:19,280
 

1759
00:37:15,599 --> 00:37:19,280
 for at least five seconds

1760
00:37:20,829 --> 00:37:20,829
 

1761
00:37:20,839 --> 00:37:26,240
 okay let's take this save the document

1762
00:37:24,390 --> 00:37:26,240
 

1763
00:37:24,400 --> 00:37:28,240
 every five minutes piece out for a

1764
00:37:26,230 --> 00:37:28,240
 

1765
00:37:26,240 --> 00:37:30,640
 minute

1766
00:37:28,230 --> 00:37:30,640
 

1767
00:37:28,240 --> 00:37:32,400
 and let's rephrase this a little bit

1768
00:37:30,630 --> 00:37:32,400
 

1769
00:37:30,640 --> 00:37:35,520
 after the application has been

1770
00:37:32,390 --> 00:37:35,520
 

1771
00:37:32,400 --> 00:37:37,760
 idle for at least n seconds we need to

1772
00:37:35,510 --> 00:37:37,760
 

1773
00:37:35,520 --> 00:37:40,079
 do something

1774
00:37:37,750 --> 00:37:40,079
 

1775
00:37:37,760 --> 00:37:42,160
 okay the reason why i took out the every

1776
00:37:40,069 --> 00:37:42,160
 

1777
00:37:40,079 --> 00:37:44,720
 five minutes is that's fairly easy to

1778
00:37:42,150 --> 00:37:44,720
 

1779
00:37:42,160 --> 00:37:44,720
 construct

1780
00:37:46,150 --> 00:37:46,150
 

1781
00:37:46,160 --> 00:37:50,480
 so this was the first pass that i wrote

1782
00:37:48,470 --> 00:37:50,480
 

1783
00:37:48,480 --> 00:37:53,839
 for the code

1784
00:37:50,470 --> 00:37:53,839
 

1785
00:37:50,480 --> 00:37:55,839
 okay i said okay we're going to have a

1786
00:37:53,829 --> 00:37:55,839
 

1787
00:37:53,839 --> 00:37:58,560
 system clock

1788
00:37:55,829 --> 00:37:58,560
 

1789
00:37:55,839 --> 00:37:59,200
 time point that we're going to set the

1790
00:37:58,550 --> 00:37:59,200
 

1791
00:37:58,560 --> 00:38:00,880
 last

1792
00:37:59,190 --> 00:38:00,880
 

1793
00:37:59,200 --> 00:38:03,040
 at the last time point when the

1794
00:38:00,870 --> 00:38:03,040
 

1795
00:38:00,880 --> 00:38:06,800
 application was idle

1796
00:38:03,030 --> 00:38:06,800
 

1797
00:38:03,040 --> 00:38:08,320
 so so really what that means is every

1798
00:38:06,790 --> 00:38:08,320
 

1799
00:38:06,800 --> 00:38:10,000
 time we get

1800
00:38:08,310 --> 00:38:10,000
 

1801
00:38:08,320 --> 00:38:12,240
 an event from the user we're going to

1802
00:38:09,990 --> 00:38:12,240
 

1803
00:38:10,000 --> 00:38:17,200
 update that time point

1804
00:38:12,230 --> 00:38:17,200
 

1805
00:38:12,240 --> 00:38:21,599
 okay and then we're going to need

1806
00:38:17,190 --> 00:38:21,599
 

1807
00:38:17,200 --> 00:38:25,040
 some function call so that we can invoke

1808
00:38:21,589 --> 00:38:25,040
 

1809
00:38:21,599 --> 00:38:26,640
 a method after some duration

1810
00:38:25,030 --> 00:38:26,640
 

1811
00:38:25,040 --> 00:38:28,720
 right so we're going to call that invoke

1812
00:38:26,630 --> 00:38:28,720
 

1813
00:38:26,640 --> 00:38:31,359
 after so we need to be able to execute

1814
00:38:28,710 --> 00:38:31,359
 

1815
00:38:28,720 --> 00:38:34,800
 some function call

1816
00:38:31,349 --> 00:38:34,800
 

1817
00:38:31,359 --> 00:38:37,920
 after some duration mac and windows and

1818
00:38:34,790 --> 00:38:37,920
 

1819
00:38:34,800 --> 00:38:38,240
 linux all have os facilities to to do

1820
00:38:37,910 --> 00:38:38,240
 

1821
00:38:37,920 --> 00:38:41,839
 this

1822
00:38:38,230 --> 00:38:41,839
 

1823
00:38:38,240 --> 00:38:41,839
 so we'll just call it invoke after

1824
00:38:43,589 --> 00:38:43,589
 

1825
00:38:43,599 --> 00:38:51,440
 and so here's what we're going to do

1826
00:38:47,910 --> 00:38:51,440
 

1827
00:38:47,920 --> 00:38:53,200
 after uh we're going to call this

1828
00:38:51,430 --> 00:38:53,200
 

1829
00:38:51,440 --> 00:38:54,800
 this function after idle we're going to

1830
00:38:53,190 --> 00:38:54,800
 

1831
00:38:53,200 --> 00:38:57,359
 give it a task and we're going to give

1832
00:38:54,790 --> 00:38:57,359
 

1833
00:38:54,800 --> 00:39:01,680
 it the delay for how long after idle we

1834
00:38:57,349 --> 00:39:01,680
 

1835
00:38:57,359 --> 00:39:05,440
 want it to be

1836
00:39:01,670 --> 00:39:05,440
 

1837
00:39:01,680 --> 00:39:09,760
 so given the delay and the

1838
00:39:05,430 --> 00:39:09,760
 

1839
00:39:05,440 --> 00:39:12,720
 current time and the time for when we

1840
00:39:09,750 --> 00:39:12,720
 

1841
00:39:09,760 --> 00:39:12,720
 last saw an event

1842
00:39:12,950 --> 00:39:12,950
 

1843
00:39:12,960 --> 00:39:17,520
 we can calculate when this thing should

1844
00:39:15,190 --> 00:39:17,520
 

1845
00:39:15,200 --> 00:39:17,520
 happen

1846
00:39:19,030 --> 00:39:19,030
 

1847
00:39:19,040 --> 00:39:22,800
 and so then what we're going to do is

1848
00:39:21,589 --> 00:39:22,800
 

1849
00:39:21,599 --> 00:39:26,960
 we're going to say

1850
00:39:22,790 --> 00:39:26,960
 

1851
00:39:22,800 --> 00:39:30,160
 is that when now all right is is

1852
00:39:26,950 --> 00:39:30,160
 

1853
00:39:26,960 --> 00:39:31,200
 if zero is less than when then it would

1854
00:39:30,150 --> 00:39:31,200
 

1855
00:39:30,160 --> 00:39:33,920
 be now

1856
00:39:31,190 --> 00:39:33,920
 

1857
00:39:31,200 --> 00:39:36,240
 in which case we would execute it that

1858
00:39:33,910 --> 00:39:36,240
 

1859
00:39:33,920 --> 00:39:42,960
 would be the else clause

1860
00:39:36,230 --> 00:39:42,960
 

1861
00:39:36,240 --> 00:39:47,119
 oh sorry i went too far back

1862
00:39:42,950 --> 00:39:47,119
 

1863
00:39:42,960 --> 00:39:49,359
 okay uh but if it's not time yet

1864
00:39:47,109 --> 00:39:49,359
 

1865
00:39:47,119 --> 00:39:50,880
 right because if you think our last idle

1866
00:39:49,349 --> 00:39:50,880
 

1867
00:39:49,359 --> 00:39:53,119
 keeps getting updated

1868
00:39:50,870 --> 00:39:53,119
 

1869
00:39:50,880 --> 00:39:54,880
 uh then we're going to schedule this

1870
00:39:53,109 --> 00:39:54,880
 

1871
00:39:53,119 --> 00:39:56,800
 with invoke after

1872
00:39:54,870 --> 00:39:56,800
 

1873
00:39:54,880 --> 00:39:58,160
 and that's a recursive schedule there

1874
00:39:56,790 --> 00:39:58,160
 

1875
00:39:56,800 --> 00:40:01,040
 you can see we're going to schedule

1876
00:39:58,150 --> 00:40:01,040
 

1877
00:39:58,160 --> 00:40:01,040
 after idle again

1878
00:40:01,190 --> 00:40:01,190
 

1879
00:40:01,200 --> 00:40:03,920
 to try again

1880
00:40:05,430 --> 00:40:05,430
 

1881
00:40:05,440 --> 00:40:11,520
 so otherwise we'll execute the task

1882
00:40:08,790 --> 00:40:11,520
 

1883
00:40:08,800 --> 00:40:12,960
 and then we're done so that's not a huge

1884
00:40:11,510 --> 00:40:12,960
 

1885
00:40:11,520 --> 00:40:15,520
 piece of code and it's not horribly

1886
00:40:12,950 --> 00:40:15,520
 

1887
00:40:12,960 --> 00:40:15,520
 complex

1888
00:40:15,589 --> 00:40:15,589
 

1889
00:40:15,599 --> 00:40:20,480
 but here is how i tend to look at a

1890
00:40:17,589 --> 00:40:20,480
 

1891
00:40:17,599 --> 00:40:20,480
 piece of code like this

1892
00:40:21,190 --> 00:40:21,190
 

1893
00:40:21,200 --> 00:40:25,680
 what's the structure of it let's ignore

1894
00:40:24,150 --> 00:40:25,680
 

1895
00:40:24,160 --> 00:40:28,160
 the recursion part

1896
00:40:25,670 --> 00:40:28,160
 

1897
00:40:25,680 --> 00:40:28,160
 for now

1898
00:40:29,190 --> 00:40:29,190
 

1899
00:40:29,200 --> 00:40:33,359
 okay here's what the structure looks

1900
00:40:31,109 --> 00:40:33,359
 

1901
00:40:31,119 --> 00:40:33,359
 like

1902
00:40:33,990 --> 00:40:33,990
 

1903
00:40:34,000 --> 00:40:39,440
 we've got last idle and now and delay

1904
00:40:37,910 --> 00:40:39,440
 

1905
00:40:37,920 --> 00:40:45,119
 feeding in

1906
00:40:39,430 --> 00:40:45,119
 

1907
00:40:39,440 --> 00:40:45,119
 to an operation and we've got our task

1908
00:40:45,430 --> 00:40:45,430
 

1909
00:40:45,440 --> 00:40:50,400
 and that's going to feed in to our

1910
00:40:48,069 --> 00:40:50,400
 

1911
00:40:48,079 --> 00:40:51,680
 recursion there

1912
00:40:50,390 --> 00:40:51,680
 

1913
00:40:50,400 --> 00:40:54,400
 so those are the arguments and the

1914
00:40:51,670 --> 00:40:54,400
 

1915
00:40:51,680 --> 00:40:54,400
 dependencies

1916
00:40:56,630 --> 00:40:56,630
 

1917
00:40:56,640 --> 00:41:00,560
 so this particular problem is really

1918
00:40:58,230 --> 00:41:00,560
 

1919
00:40:58,240 --> 00:41:02,800
 divisible into two separate problems

1920
00:41:00,550 --> 00:41:02,800
 

1921
00:41:00,560 --> 00:41:05,200
 right we have two relationships in one

1922
00:41:02,790 --> 00:41:05,200
 

1923
00:41:02,800 --> 00:41:05,200
 function

1924
00:41:05,270 --> 00:41:05,270
 

1925
00:41:05,280 --> 00:41:08,560
 so can we split this up

1926
00:41:09,589 --> 00:41:09,589
 

1927
00:41:09,599 --> 00:41:13,920
 right this is that first relationship

1928
00:41:12,150 --> 00:41:13,920
 

1929
00:41:12,160 --> 00:41:16,000
 it's just a single expression

1930
00:41:13,910 --> 00:41:16,000
 

1931
00:41:13,920 --> 00:41:17,520
 so we don't think of this as necessarily

1932
00:41:15,990 --> 00:41:17,520
 

1933
00:41:16,000 --> 00:41:20,240
 being its own function

1934
00:41:17,510 --> 00:41:20,240
 

1935
00:41:17,520 --> 00:41:21,280
 but it really is if you think about this

1936
00:41:20,230 --> 00:41:21,280
 

1937
00:41:20,240 --> 00:41:24,720
 it's

1938
00:41:21,270 --> 00:41:24,720
 

1939
00:41:21,280 --> 00:41:24,720
 what exactly is this thing

1940
00:41:24,950 --> 00:41:24,950
 

1941
00:41:24,960 --> 00:41:28,319
 what this expression is is it's a clock

1942
00:41:27,910 --> 00:41:28,319
 

1943
00:41:27,920 --> 00:41:31,440
 like

1944
00:41:28,309 --> 00:41:31,440
 

1945
00:41:28,319 --> 00:41:31,440
 a kitchen clock

1946
00:41:31,510 --> 00:41:31,510
 

1947
00:41:31,520 --> 00:41:37,680
 you can add time to it and it ticks down

1948
00:41:35,349 --> 00:41:37,680
 

1949
00:41:35,359 --> 00:41:38,960
 and if your event happens it adds more

1950
00:41:37,670 --> 00:41:38,960
 

1951
00:41:37,680 --> 00:41:41,599
 time to it

1952
00:41:38,950 --> 00:41:41,599
 

1953
00:41:38,960 --> 00:41:45,040
 and it keeps ticking down but you can't

1954
00:41:41,589 --> 00:41:45,040
 

1955
00:41:41,599 --> 00:41:45,040
 force time to come off of it

1956
00:41:46,829 --> 00:41:46,829
 

1957
00:41:46,839 --> 00:41:52,319
 okay

1958
00:41:49,349 --> 00:41:52,319
 

1959
00:41:49,359 --> 00:41:52,319
 on expiration

1960
00:41:55,109 --> 00:41:55,109
 

1961
00:41:55,119 --> 00:42:01,760
 so this is the other piece

1962
00:41:58,470 --> 00:42:01,760
 

1963
00:41:58,480 --> 00:42:03,680
 that we have in that little little

1964
00:42:01,750 --> 00:42:03,680
 

1965
00:42:01,760 --> 00:42:07,440
 function

1966
00:42:03,670 --> 00:42:07,440
 

1967
00:42:03,680 --> 00:42:07,440
 so now we've got our timer

1968
00:42:08,470 --> 00:42:08,470
 

1969
00:42:08,480 --> 00:42:12,000
 okay and our task

1970
00:42:12,390 --> 00:42:12,390
 

1971
00:42:12,400 --> 00:42:16,480
 and so from our timer we can calculate

1972
00:42:14,950 --> 00:42:16,480
 

1973
00:42:14,960 --> 00:42:19,119
 the remaining amount of time that we

1974
00:42:16,470 --> 00:42:19,119
 

1975
00:42:16,480 --> 00:42:20,640
 have that's what it's returning

1976
00:42:19,109 --> 00:42:20,640
 

1977
00:42:19,119 --> 00:42:22,960
 and we're going to feed that to our

1978
00:42:20,630 --> 00:42:22,960
 

1979
00:42:20,640 --> 00:42:26,720
 scheduler

1980
00:42:22,950 --> 00:42:26,720
 

1981
00:42:22,960 --> 00:42:26,720
 so that gives this little algorithm

1982
00:42:27,270 --> 00:42:27,270
 

1983
00:42:27,280 --> 00:42:32,480
 we have on expiration

1984
00:42:30,950 --> 00:42:32,480
 

1985
00:42:30,960 --> 00:42:34,720
 we get the remaining amount of time from

1986
00:42:32,470 --> 00:42:34,720
 

1987
00:42:32,480 --> 00:42:38,000
 our timer

1988
00:42:34,710 --> 00:42:38,000
 

1989
00:42:34,720 --> 00:42:40,079
 we check to see if our timer's expired

1990
00:42:37,990 --> 00:42:40,079
 

1991
00:42:38,000 --> 00:42:43,200
 yet

1992
00:42:40,069 --> 00:42:43,200
 

1993
00:42:40,079 --> 00:42:46,240
 if it has not then we schedule

1994
00:42:43,190 --> 00:42:46,240
 

1995
00:42:43,200 --> 00:42:47,680
 this function recursively to execute

1996
00:42:46,230 --> 00:42:47,680
 

1997
00:42:46,240 --> 00:42:50,640
 again

1998
00:42:47,670 --> 00:42:50,640
 

1999
00:42:47,680 --> 00:42:52,960
 otherwise we perform the task and we're

2000
00:42:50,630 --> 00:42:52,960
 

2001
00:42:50,640 --> 00:42:52,960
 done

2002
00:42:53,510 --> 00:42:53,510
 

2003
00:42:53,520 --> 00:42:59,920
 okay and then we want to start

2004
00:42:58,309 --> 00:42:59,920
 

2005
00:42:58,319 --> 00:43:02,160
 this timer we could just call it

2006
00:42:59,910 --> 00:43:02,160
 

2007
00:42:59,920 --> 00:43:03,680
 directly but the problem with just

2008
00:43:02,150 --> 00:43:03,680
 

2009
00:43:02,160 --> 00:43:06,400
 calling it directly

2010
00:43:03,670 --> 00:43:06,400
 

2011
00:43:03,680 --> 00:43:07,920
 is that if the timer had already expired

2012
00:43:06,390 --> 00:43:07,920
 

2013
00:43:06,400 --> 00:43:11,280
 it would execute the task

2014
00:43:07,910 --> 00:43:11,280
 

2015
00:43:07,920 --> 00:43:13,280
 immediately the problem with doing that

2016
00:43:11,270 --> 00:43:13,280
 

2017
00:43:11,280 --> 00:43:15,520
 is that the execution context

2018
00:43:13,270 --> 00:43:15,520
 

2019
00:43:13,280 --> 00:43:18,319
 matters here's what happens in in real

2020
00:43:15,510 --> 00:43:18,319
 

2021
00:43:15,520 --> 00:43:18,319
 world code

2022
00:43:19,910 --> 00:43:19,910
 

2023
00:43:19,920 --> 00:43:25,119
 let's say for example i'm constructing a

2024
00:43:22,870 --> 00:43:25,119
 

2025
00:43:22,880 --> 00:43:29,040
 document and i want that document

2026
00:43:25,109 --> 00:43:29,040
 

2027
00:43:25,119 --> 00:43:31,440
 to save every time this timer expires

2028
00:43:29,030 --> 00:43:31,440
 

2029
00:43:29,040 --> 00:43:34,319
 i'm probably going to set up the timer

2030
00:43:31,430 --> 00:43:34,319
 

2031
00:43:31,440 --> 00:43:36,640
 in the constructor for the document

2032
00:43:34,309 --> 00:43:36,640
 

2033
00:43:34,319 --> 00:43:38,960
 if the timer's already expired at the

2034
00:43:36,630 --> 00:43:38,960
 

2035
00:43:36,640 --> 00:43:41,920
 time i'm constructing the document

2036
00:43:38,950 --> 00:43:41,920
 

2037
00:43:38,960 --> 00:43:43,359
 then i'm going to schedule then i'm

2038
00:43:41,910 --> 00:43:43,359
 

2039
00:43:41,920 --> 00:43:45,520
 going to save the document

2040
00:43:43,349 --> 00:43:45,520
 

2041
00:43:43,359 --> 00:43:46,640
 immediately on the same thread that i'm

2042
00:43:45,510 --> 00:43:46,640
 

2043
00:43:45,520 --> 00:43:49,520
 creating the document

2044
00:43:46,630 --> 00:43:49,520
 

2045
00:43:46,640 --> 00:43:51,119
 on that i haven't even finished

2046
00:43:49,510 --> 00:43:51,119
 

2047
00:43:49,520 --> 00:43:54,560
 constructing yet

2048
00:43:51,109 --> 00:43:54,560
 

2049
00:43:51,119 --> 00:43:56,800
 right now the problem is that that will

2050
00:43:54,550 --> 00:43:56,800
 

2051
00:43:54,560 --> 00:43:59,200
 probably

2052
00:43:56,790 --> 00:43:59,200
 

2053
00:43:56,800 --> 00:44:00,079
 only ever happen rarely the person who

2054
00:43:59,190 --> 00:44:00,079
 

2055
00:43:59,200 --> 00:44:01,760
 wrote the code

2056
00:44:00,069 --> 00:44:01,760
 

2057
00:44:00,079 --> 00:44:03,599
 every time they're writing it they're

2058
00:44:01,750 --> 00:44:03,599
 

2059
00:44:01,760 --> 00:44:05,200
 busy using the application they just

2060
00:44:03,589 --> 00:44:05,200
 

2061
00:44:03,599 --> 00:44:08,480
 created a new document

2062
00:44:05,190 --> 00:44:08,480
 

2063
00:44:05,200 --> 00:44:11,839
 so the document opens immediately and

2064
00:44:08,470 --> 00:44:11,839
 

2065
00:44:08,480 --> 00:44:12,560
 and the save gets scheduled at some time

2066
00:44:11,829 --> 00:44:12,560
 

2067
00:44:11,839 --> 00:44:14,079
 later

2068
00:44:12,550 --> 00:44:14,079
 

2069
00:44:12,560 --> 00:44:17,280
 now long after the document's

2070
00:44:14,069 --> 00:44:17,280
 

2071
00:44:14,079 --> 00:44:19,680
 constructed and everything works fine

2072
00:44:17,270 --> 00:44:19,680
 

2073
00:44:17,280 --> 00:44:21,520
 but at some point in the real world hand

2074
00:44:19,670 --> 00:44:21,520
 

2075
00:44:19,680 --> 00:44:23,839
 they select a new document but the

2076
00:44:21,510 --> 00:44:23,839
 

2077
00:44:21,520 --> 00:44:25,680
 system is busy and behind or it was

2078
00:44:23,829 --> 00:44:25,680
 

2079
00:44:23,839 --> 00:44:27,440
 scheduled as part of playing a script

2080
00:44:25,670 --> 00:44:27,440
 

2081
00:44:25,680 --> 00:44:29,760
 and events are queued up

2082
00:44:27,430 --> 00:44:29,760
 

2083
00:44:27,440 --> 00:44:31,599
 and so the documents in the middle of

2084
00:44:29,750 --> 00:44:31,599
 

2085
00:44:29,760 --> 00:44:34,640
 getting created

2086
00:44:31,589 --> 00:44:34,640
 

2087
00:44:31,599 --> 00:44:36,160
 the device is idle it immediately saves

2088
00:44:34,630 --> 00:44:36,160
 

2089
00:44:34,640 --> 00:44:39,440
 the document's not constructed

2090
00:44:36,150 --> 00:44:39,440
 

2091
00:44:36,160 --> 00:44:42,240
 and you crash so

2092
00:44:39,430 --> 00:44:42,240
 

2093
00:44:39,440 --> 00:44:43,359
 we want to make sure that we're always

2094
00:44:42,230 --> 00:44:43,359
 

2095
00:44:42,240 --> 00:44:46,000
 consistent and if

2096
00:44:43,349 --> 00:44:46,000
 

2097
00:44:43,359 --> 00:44:48,000
 code is executed if code is scheduled to

2098
00:44:45,990 --> 00:44:48,000
 

2099
00:44:46,000 --> 00:44:49,920
 execute within a given context

2100
00:44:47,990 --> 00:44:49,920
 

2101
00:44:48,000 --> 00:44:52,880
 we always schedule it to execute within

2102
00:44:49,910 --> 00:44:52,880
 

2103
00:44:49,920 --> 00:44:52,880
 the given context

2104
00:44:54,710 --> 00:44:54,710
 

2105
00:44:54,720 --> 00:44:58,480
 so architecture by looking at the

2106
00:44:57,270 --> 00:44:58,480
 

2107
00:44:57,280 --> 00:45:00,720
 structure of the function

2108
00:44:58,470 --> 00:45:00,720
 

2109
00:44:58,480 --> 00:45:03,280
 we can design a better function

2110
00:45:00,710 --> 00:45:03,280
 

2111
00:45:00,720 --> 00:45:05,440
 something that's decomposed

2112
00:45:03,270 --> 00:45:05,440
 

2113
00:45:03,280 --> 00:45:07,280
 note that are on expiration it has no

2114
00:45:05,430 --> 00:45:07,280
 

2115
00:45:05,440 --> 00:45:09,599
 external dependencies

2116
00:45:07,270 --> 00:45:09,599
 

2117
00:45:07,280 --> 00:45:11,599
 it doesn't depend on chrono it doesn't

2118
00:45:09,589 --> 00:45:11,599
 

2119
00:45:09,599 --> 00:45:13,599
 depend on std function

2120
00:45:11,589 --> 00:45:13,599
 

2121
00:45:11,599 --> 00:45:14,720
 it doesn't depend on invoke after or

2122
00:45:13,589 --> 00:45:14,720
 

2123
00:45:13,599 --> 00:45:17,280
 last idle

2124
00:45:14,710 --> 00:45:17,280
 

2125
00:45:14,720 --> 00:45:19,119
 it's just a little generic algorithm

2126
00:45:17,270 --> 00:45:19,119
 

2127
00:45:17,280 --> 00:45:21,839
 that we can plug into any system

2128
00:45:19,109 --> 00:45:21,839
 

2129
00:45:19,119 --> 00:45:24,319
 and we can reuse it anytime we want it

2130
00:45:21,829 --> 00:45:24,319
 

2131
00:45:21,839 --> 00:45:27,119
 to execute a function on the expiration

2132
00:45:24,309 --> 00:45:27,119
 

2133
00:45:24,319 --> 00:45:27,119
 of something else

2134
00:45:27,589 --> 00:45:27,589
 

2135
00:45:27,599 --> 00:45:30,800
 so the requirements are the semantics of

2136
00:45:29,670 --> 00:45:30,800
 

2137
00:45:29,680 --> 00:45:32,800
 the operations

2138
00:45:30,790 --> 00:45:32,800
 

2139
00:45:30,800 --> 00:45:35,359
 and the relationships between those

2140
00:45:32,790 --> 00:45:35,359
 

2141
00:45:32,800 --> 00:45:35,359
 arguments

2142
00:45:36,069 --> 00:45:36,069
 

2143
00:45:36,079 --> 00:45:42,720
 right so let's take a look at

2144
00:45:39,349 --> 00:45:42,720
 

2145
00:45:39,359 --> 00:45:45,760
 another example this is

2146
00:45:42,710 --> 00:45:45,760
 

2147
00:45:42,720 --> 00:45:49,200
 the problem of building a registry

2148
00:45:45,750 --> 00:45:49,200
 

2149
00:45:45,760 --> 00:45:50,880
 a registry is a container supporting the

2150
00:45:49,190 --> 00:45:50,880
 

2151
00:45:49,200 --> 00:45:53,280
 following operations

2152
00:45:50,870 --> 00:45:53,280
 

2153
00:45:50,880 --> 00:45:55,520
 in this case we can add an object and

2154
00:45:53,270 --> 00:45:55,520
 

2155
00:45:53,280 --> 00:45:58,800
 obtain a receipt

2156
00:45:55,510 --> 00:45:58,800
 

2157
00:45:55,520 --> 00:46:01,839
 right use of the receipt to retrieve or

2158
00:45:58,790 --> 00:46:01,839
 

2159
00:45:58,800 --> 00:46:01,839
 remove the object

2160
00:46:02,950 --> 00:46:02,950
 

2161
00:46:02,960 --> 00:46:07,440
 and we can operate on the objects in the

2162
00:46:04,870 --> 00:46:07,440
 

2163
00:46:04,880 --> 00:46:09,599
 registry

2164
00:46:07,430 --> 00:46:09,599
 

2165
00:46:07,440 --> 00:46:11,440
 so for example if you have a slot and

2166
00:46:09,589 --> 00:46:11,440
 

2167
00:46:09,599 --> 00:46:13,599
 signal handler

2168
00:46:11,430 --> 00:46:13,599
 

2169
00:46:11,440 --> 00:46:15,200
 this would be the the basic operations

2170
00:46:13,589 --> 00:46:15,200
 

2171
00:46:13,599 --> 00:46:17,680
 that you would have in your signal

2172
00:46:15,190 --> 00:46:17,680
 

2173
00:46:15,200 --> 00:46:17,680
 handler

2174
00:46:19,109 --> 00:46:19,109
 

2175
00:46:19,119 --> 00:46:22,240
 here's how i see most registries get

2176
00:46:21,510 --> 00:46:22,240
 

2177
00:46:21,520 --> 00:46:24,319
 written

2178
00:46:22,230 --> 00:46:24,319
 

2179
00:46:22,240 --> 00:46:29,280
 we've got an unordered map maybe we've

2180
00:46:24,309 --> 00:46:29,280
 

2181
00:46:24,319 --> 00:46:32,800
 got a fancier hash container than that

2182
00:46:29,270 --> 00:46:32,800
 

2183
00:46:29,280 --> 00:46:35,920
 we got an id which is going to be

2184
00:46:32,790 --> 00:46:35,920
 

2185
00:46:32,800 --> 00:46:39,760
 our receipt when we

2186
00:46:35,910 --> 00:46:39,760
 

2187
00:46:35,920 --> 00:46:43,440
 when when we put an element into the

2188
00:46:39,750 --> 00:46:43,440
 

2189
00:46:39,760 --> 00:46:46,640
 registry we get back a receipt

2190
00:46:43,430 --> 00:46:46,640
 

2191
00:46:43,440 --> 00:46:48,640
 all right there's putting an element in

2192
00:46:46,630 --> 00:46:48,640
 

2193
00:46:46,640 --> 00:46:51,680
 we can erase an element by just looking

2194
00:46:48,630 --> 00:46:51,680
 

2195
00:46:48,640 --> 00:46:53,680
 it up in the map and erasing it

2196
00:46:51,670 --> 00:46:53,680
 

2197
00:46:51,680 --> 00:46:55,520
 and we can iterate over all the items in

2198
00:46:53,670 --> 00:46:55,520
 

2199
00:46:53,680 --> 00:46:59,599
 the map

2200
00:46:55,510 --> 00:46:59,599
 

2201
00:46:55,520 --> 00:46:59,599
 so pretty straightforward pretty simple

2202
00:47:00,790 --> 00:47:00,790
 

2203
00:47:00,800 --> 00:47:05,839
 so why did i put this up well i was in

2204
00:47:04,150 --> 00:47:05,839
 

2205
00:47:04,160 --> 00:47:08,880
 russia

2206
00:47:05,829 --> 00:47:08,880
 

2207
00:47:05,839 --> 00:47:12,319
 actually preparing for this talk

2208
00:47:08,870 --> 00:47:12,319
 

2209
00:47:08,880 --> 00:47:14,240
 and at the hotel uh there was a

2210
00:47:12,309 --> 00:47:14,240
 

2211
00:47:12,319 --> 00:47:16,480
 coat room there are lots of coat rooms

2212
00:47:14,230 --> 00:47:16,480
 

2213
00:47:14,240 --> 00:47:18,480
 in russia i found

2214
00:47:16,470 --> 00:47:18,480
 

2215
00:47:16,480 --> 00:47:19,599
 uh not one that happened to look

2216
00:47:18,470 --> 00:47:19,599
 

2217
00:47:18,480 --> 00:47:22,960
 particularly like this

2218
00:47:19,589 --> 00:47:22,960
 

2219
00:47:19,599 --> 00:47:26,240
 in this coat room it was just uh

2220
00:47:22,950 --> 00:47:26,240
 

2221
00:47:22,960 --> 00:47:27,599
 uh uh bars with the coats directly on

2222
00:47:26,230 --> 00:47:27,599
 

2223
00:47:26,240 --> 00:47:31,040
 the bars

2224
00:47:27,589 --> 00:47:31,040
 

2225
00:47:27,599 --> 00:47:33,839
 at the at the hotel

2226
00:47:31,030 --> 00:47:33,839
 

2227
00:47:31,040 --> 00:47:34,640
 and i observed there's a queue of people

2228
00:47:33,829 --> 00:47:34,640
 

2229
00:47:33,839 --> 00:47:37,520
 walking up

2230
00:47:34,630 --> 00:47:37,520
 

2231
00:47:34,640 --> 00:47:38,720
 and as each person walks up they either

2232
00:47:37,510 --> 00:47:38,720
 

2233
00:47:37,520 --> 00:47:41,760
 hand them their jacket

2234
00:47:38,710 --> 00:47:41,760
 

2235
00:47:38,720 --> 00:47:44,880
 and get a receipt or they

2236
00:47:41,750 --> 00:47:44,880
 

2237
00:47:41,760 --> 00:47:44,880
 hand the code clerk

2238
00:47:45,349 --> 00:47:45,349
 

2239
00:47:45,359 --> 00:47:49,599
 their receipt and the coke clerk walks

2240
00:47:47,829 --> 00:47:49,599
 

2241
00:47:47,839 --> 00:47:52,720
 over to this rack

2242
00:47:49,589 --> 00:47:52,720
 

2243
00:47:49,599 --> 00:47:54,720
 and she looks briefly

2244
00:47:52,710 --> 00:47:54,720
 

2245
00:47:52,720 --> 00:47:56,720
 in the middle of all these jackets she

2246
00:47:54,710 --> 00:47:56,720
 

2247
00:47:54,720 --> 00:47:58,640
 thumbs through a couple of them

2248
00:47:56,710 --> 00:47:58,640
 

2249
00:47:56,720 --> 00:48:00,640
 pulls out the correct coat and hands it

2250
00:47:58,630 --> 00:48:00,640
 

2251
00:47:58,640 --> 00:48:01,920
 to the customer another customer comes

2252
00:48:00,630 --> 00:48:01,920
 

2253
00:48:00,640 --> 00:48:04,079
 up gives them their coat

2254
00:48:01,910 --> 00:48:04,079
 

2255
00:48:01,920 --> 00:48:06,559
 she just puts that coat on the end of

2256
00:48:04,069 --> 00:48:06,559
 

2257
00:48:04,079 --> 00:48:08,160
 the rack i'm like

2258
00:48:06,549 --> 00:48:08,160
 

2259
00:48:06,559 --> 00:48:09,920
 well how does this work she's always

2260
00:48:08,150 --> 00:48:09,920
 

2261
00:48:08,160 --> 00:48:13,040
 putting the coats on the end

2262
00:48:09,910 --> 00:48:13,040
 

2263
00:48:09,920 --> 00:48:16,720
 and she can always find the correct coat

2264
00:48:13,030 --> 00:48:16,720
 

2265
00:48:13,040 --> 00:48:20,559
 within the rack well this is the russian

2266
00:48:16,710 --> 00:48:20,559
 

2267
00:48:16,720 --> 00:48:22,400
 coat check algorithm

2268
00:48:20,549 --> 00:48:22,400
 

2269
00:48:20,559 --> 00:48:24,319
 it's probably the co-check algorithm in

2270
00:48:22,390 --> 00:48:24,319
 

2271
00:48:22,400 --> 00:48:25,599
 every country

2272
00:48:24,309 --> 00:48:25,599
 

2273
00:48:24,319 --> 00:48:27,520
 i wouldn't know that because i live in

2274
00:48:25,589 --> 00:48:27,520
 

2275
00:48:25,599 --> 00:48:29,440
 california and we don't have coats in

2276
00:48:27,510 --> 00:48:29,440
 

2277
00:48:27,520 --> 00:48:31,680
 california

2278
00:48:29,430 --> 00:48:31,680
 

2279
00:48:29,440 --> 00:48:33,119
 but here's how this works it's

2280
00:48:31,670 --> 00:48:33,119
 

2281
00:48:31,680 --> 00:48:35,280
 recognizing that receipts are

2282
00:48:33,109 --> 00:48:35,280
 

2283
00:48:33,119 --> 00:48:37,520
 ordered right that there's an underlying

2284
00:48:35,270 --> 00:48:37,520
 

2285
00:48:35,280 --> 00:48:40,640
 relationship going on here

2286
00:48:37,510 --> 00:48:40,640
 

2287
00:48:37,520 --> 00:48:44,559
 coats are always appended

2288
00:48:40,630 --> 00:48:44,559
 

2289
00:48:40,640 --> 00:48:46,400
 and you hand out a stub

2290
00:48:44,549 --> 00:48:46,400
 

2291
00:48:44,559 --> 00:48:47,599
 you can do a quick binary search to

2292
00:48:46,390 --> 00:48:47,599
 

2293
00:48:46,400 --> 00:48:52,000
 retrieve a coat

2294
00:48:47,589 --> 00:48:52,000
 

2295
00:48:47,599 --> 00:48:52,000
 by matching the receipt to the stub

2296
00:48:52,069 --> 00:48:52,069
 

2297
00:48:52,079 --> 00:48:57,200
 when more than half of the slots within

2298
00:48:55,349 --> 00:48:57,200
 

2299
00:48:55,359 --> 00:48:59,920
 the coat rack are empty

2300
00:48:57,190 --> 00:48:59,920
 

2301
00:48:57,200 --> 00:49:00,319
 the person managing the coat rack can

2302
00:48:59,910 --> 00:49:00,319
 

2303
00:48:59,920 --> 00:49:02,079
 just

2304
00:49:00,309 --> 00:49:02,079
 

2305
00:49:00,319 --> 00:49:03,920
 slide all the coats together and

2306
00:49:02,069 --> 00:49:03,920
 

2307
00:49:02,079 --> 00:49:07,040
 compress the rack and have more space on

2308
00:49:03,910 --> 00:49:07,040
 

2309
00:49:03,920 --> 00:49:07,040
 the end to put more coats

2310
00:49:07,910 --> 00:49:07,910
 

2311
00:49:07,920 --> 00:49:11,920
 coats are always ordered by the receipt

2312
00:49:09,910 --> 00:49:11,920
 

2313
00:49:09,920 --> 00:49:13,839
 stumps

2314
00:49:11,910 --> 00:49:13,839
 

2315
00:49:11,920 --> 00:49:17,839
 so as an additional useful property

2316
00:49:13,829 --> 00:49:17,839
 

2317
00:49:13,839 --> 00:49:17,839
 coats are always ordered by insertion

2318
00:49:18,150 --> 00:49:18,150
 

2319
00:49:18,160 --> 00:49:23,200
 so let's build one of these so to do

2320
00:49:20,870 --> 00:49:23,200
 

2321
00:49:20,880 --> 00:49:25,280
 that we're just going to use a vector

2322
00:49:23,190 --> 00:49:25,280
 

2323
00:49:23,200 --> 00:49:27,440
 and our vector here is going to use a

2324
00:49:25,270 --> 00:49:27,440
 

2325
00:49:25,280 --> 00:49:30,640
 size t that's going to be

2326
00:49:27,430 --> 00:49:30,640
 

2327
00:49:27,440 --> 00:49:36,480
 our receipt in our stub and

2328
00:49:30,630 --> 00:49:36,480
 

2329
00:49:30,640 --> 00:49:36,480
 an optional t for for placing our jacket

2330
00:49:36,710 --> 00:49:36,710
 

2331
00:49:36,720 --> 00:49:44,800
 oops hit the wrong key

2332
00:49:41,750 --> 00:49:44,800
 

2333
00:49:41,760 --> 00:49:48,720
 so to put

2334
00:49:44,790 --> 00:49:48,720
 

2335
00:49:44,800 --> 00:49:50,720
 a uh a jacket in

2336
00:49:48,710 --> 00:49:50,720
 

2337
00:49:48,720 --> 00:49:52,480
 we're just going to append it on the end

2338
00:49:50,710 --> 00:49:52,480
 

2339
00:49:50,720 --> 00:49:54,000
 so we can put in a bunch of jackets like

2340
00:49:52,470 --> 00:49:54,000
 

2341
00:49:52,480 --> 00:49:55,680
 that

2342
00:49:53,990 --> 00:49:55,680
 

2343
00:49:54,000 --> 00:49:57,280
 you notice we're not putting in just the

2344
00:49:55,670 --> 00:49:57,280
 

2345
00:49:55,680 --> 00:49:59,839
 jackets but we're also putting in the

2346
00:49:57,270 --> 00:49:59,839
 

2347
00:49:57,280 --> 00:49:59,839
 stubs

2348
00:50:02,390 --> 00:50:02,390
 

2349
00:50:02,400 --> 00:50:08,000
 to erase a given jacket we can do a

2350
00:50:05,030 --> 00:50:08,000
 

2351
00:50:05,040 --> 00:50:11,839
 binary search that's what lower bound is

2352
00:50:07,990 --> 00:50:11,839
 

2353
00:50:08,000 --> 00:50:12,880
 just comparing the first element which

2354
00:50:11,829 --> 00:50:12,880
 

2355
00:50:11,839 --> 00:50:15,599
 is our stub

2356
00:50:12,870 --> 00:50:15,599
 

2357
00:50:12,880 --> 00:50:16,800
 so that's our comparison operator there

2358
00:50:15,589 --> 00:50:16,800
 

2359
00:50:15,599 --> 00:50:19,200
 and

2360
00:50:16,790 --> 00:50:19,200
 

2361
00:50:16,800 --> 00:50:20,480
 if we didn't find the jacket we can tell

2362
00:50:19,190 --> 00:50:20,480
 

2363
00:50:19,200 --> 00:50:23,280
 the customer no jacket

2364
00:50:20,470 --> 00:50:23,280
 

2365
00:50:20,480 --> 00:50:23,280
 and just return

2366
00:50:24,150 --> 00:50:24,150
 

2367
00:50:24,160 --> 00:50:28,079
 otherwise it's an optional so we just go

2368
00:50:26,390 --> 00:50:28,079
 

2369
00:50:26,400 --> 00:50:29,359
 ahead and we delete the jacket remember

2370
00:50:28,069 --> 00:50:29,359
 

2371
00:50:28,079 --> 00:50:30,160
 we're just erasing here we're not

2372
00:50:29,349 --> 00:50:30,160
 

2373
00:50:29,359 --> 00:50:31,599
 returning

2374
00:50:30,150 --> 00:50:31,599
 

2375
00:50:30,160 --> 00:50:33,599
 to the customer but you could return it

2376
00:50:31,589 --> 00:50:33,599
 

2377
00:50:31,599 --> 00:50:37,760
 if you wanted to

2378
00:50:33,589 --> 00:50:37,760
 

2379
00:50:33,599 --> 00:50:41,839
 and then uh we also decrement our

2380
00:50:37,750 --> 00:50:41,839
 

2381
00:50:37,760 --> 00:50:41,839
 internal size count there

2382
00:50:43,270 --> 00:50:43,270
 

2383
00:50:43,280 --> 00:50:49,920
 so now if we've erased

2384
00:50:46,309 --> 00:50:49,920
 

2385
00:50:46,319 --> 00:50:52,160
 more than half the jackets okay

2386
00:50:49,910 --> 00:50:52,160
 

2387
00:50:49,920 --> 00:50:53,359
 then we go ahead and we remove them from

2388
00:50:52,150 --> 00:50:53,359
 

2389
00:50:52,160 --> 00:50:56,079
 the vector

2390
00:50:53,349 --> 00:50:56,079
 

2391
00:50:53,359 --> 00:50:57,280
 and we erase the empty slots in the

2392
00:50:56,069 --> 00:50:57,280
 

2393
00:50:56,079 --> 00:51:00,079
 vector

2394
00:50:57,270 --> 00:51:00,079
 

2395
00:50:57,280 --> 00:51:00,400
 so how does that work as customers come

2396
00:51:00,069 --> 00:51:00,400
 

2397
00:51:00,079 --> 00:51:03,680
 up

2398
00:51:00,390 --> 00:51:03,680
 

2399
00:51:00,400 --> 00:51:07,200
 they get their coats okay eventually

2400
00:51:03,670 --> 00:51:07,200
 

2401
00:51:03,680 --> 00:51:10,640
 more coats are gone than half

2402
00:51:07,190 --> 00:51:10,640
 

2403
00:51:07,200 --> 00:51:12,160
 and so we make a pass and we delete all

2404
00:51:10,630 --> 00:51:12,160
 

2405
00:51:10,640 --> 00:51:15,359
 the empty

2406
00:51:12,150 --> 00:51:15,359
 

2407
00:51:12,160 --> 00:51:17,119
 slots and compress our vector now notice

2408
00:51:15,349 --> 00:51:17,119
 

2409
00:51:15,359 --> 00:51:19,839
 our vector is still ordered

2410
00:51:17,109 --> 00:51:19,839
 

2411
00:51:17,119 --> 00:51:23,280
 right so it continues to work doing a

2412
00:51:19,829 --> 00:51:23,280
 

2413
00:51:19,839 --> 00:51:26,079
 binary search to look up new elements

2414
00:51:23,270 --> 00:51:26,079
 

2415
00:51:23,280 --> 00:51:28,160
 now we can go and add some more jackets

2416
00:51:26,069 --> 00:51:28,160
 

2417
00:51:26,079 --> 00:51:31,520
 and so on

2418
00:51:28,150 --> 00:51:31,520
 

2419
00:51:28,160 --> 00:51:34,839
 and we can iterate this registry

2420
00:51:31,510 --> 00:51:34,839
 

2421
00:51:31,520 --> 00:51:37,839
 just by looping through the vector very

2422
00:51:34,829 --> 00:51:37,839
 

2423
00:51:34,839 --> 00:51:37,839
 simple

2424
00:51:37,990 --> 00:51:37,990
 

2425
00:51:38,000 --> 00:51:44,160
 so how does this perform so

2426
00:51:41,109 --> 00:51:44,160
 

2427
00:51:41,119 --> 00:51:48,640
 so this is a looking at

2428
00:51:44,150 --> 00:51:48,640
 

2429
00:51:44,160 --> 00:51:51,839
 at inserts in a race over the entire

2430
00:51:48,630 --> 00:51:51,839
 

2431
00:51:48,640 --> 00:51:51,839
 entire container

2432
00:51:52,390 --> 00:51:52,390
 

2433
00:51:52,400 --> 00:51:56,240
 or how fast it is to to iterate with

2434
00:51:55,910 --> 00:51:56,240
 

2435
00:51:55,920 --> 00:51:58,480
 four

2436
00:51:56,230 --> 00:51:58,480
 

2437
00:51:56,240 --> 00:51:58,480
 each

2438
00:52:00,710 --> 00:52:00,710
 

2439
00:52:00,720 --> 00:52:08,640
 okay so there's a difference of 640

2440
00:52:04,950 --> 00:52:08,640
 

2441
00:52:04,960 --> 00:52:12,559
 between those two bars

2442
00:52:08,630 --> 00:52:12,559
 

2443
00:52:08,640 --> 00:52:15,280
 now what i didn't tell you in this graph

2444
00:52:12,549 --> 00:52:15,280
 

2445
00:52:12,559 --> 00:52:16,839
 is how many times i was doing it right

2446
00:52:15,270 --> 00:52:16,839
 

2447
00:52:15,280 --> 00:52:19,760
 you would think that that would make a

2448
00:52:16,829 --> 00:52:19,760
 

2449
00:52:16,839 --> 00:52:22,960
 difference

2450
00:52:19,750 --> 00:52:22,960
 

2451
00:52:19,760 --> 00:52:27,280
 it turns out it really doesn't

2452
00:52:22,950 --> 00:52:27,280
 

2453
00:52:22,960 --> 00:52:27,280
 okay if i have

2454
00:52:28,870 --> 00:52:28,870
 

2455
00:52:28,880 --> 00:52:32,000
 elements this is what the graph looks

2456
00:52:30,710 --> 00:52:32,000
 

2457
00:52:30,720 --> 00:52:36,960
 like based off number of

2458
00:52:31,990 --> 00:52:36,960
 

2459
00:52:32,000 --> 00:52:40,079
 elements and the number of allocations

2460
00:52:36,950 --> 00:52:40,079
 

2461
00:52:36,960 --> 00:52:43,280
 okay that's the time difference

2462
00:52:40,069 --> 00:52:43,280
 

2463
00:52:40,079 --> 00:52:46,319
 right there and that time difference

2464
00:52:43,270 --> 00:52:46,319
 

2465
00:52:43,280 --> 00:52:49,520
 grows linear out to about two

2466
00:52:46,309 --> 00:52:49,520
 

2467
00:52:46,319 --> 00:52:49,520
 to the 20 elements

2468
00:52:51,750 --> 00:52:51,750
 

2469
00:52:51,760 --> 00:52:54,960
 so the relationship here understanding

2470
00:52:54,549 --> 00:52:54,960
 

2471
00:52:54,559 --> 00:52:56,880
 that

2472
00:52:54,950 --> 00:52:56,880
 

2473
00:52:54,960 --> 00:52:59,119
 the receipts are always getting handed

2474
00:52:56,870 --> 00:52:59,119
 

2475
00:52:56,880 --> 00:53:01,839
 out in order can be exploited for

2476
00:52:59,109 --> 00:53:01,839
 

2477
00:52:59,119 --> 00:53:01,839
 performance

2478
00:53:02,230 --> 00:53:02,230
 

2479
00:53:02,240 --> 00:53:06,079
 understanding the relationship between

2480
00:53:03,829 --> 00:53:06,079
 

2481
00:53:03,839 --> 00:53:08,079
 the cost of operations is important

2482
00:53:06,069 --> 00:53:08,079
 

2483
00:53:06,079 --> 00:53:10,480
 understanding that a heap allocation for

2484
00:53:08,069 --> 00:53:10,480
 

2485
00:53:08,079 --> 00:53:12,720
 an element is much more expensive

2486
00:53:10,470 --> 00:53:12,720
 

2487
00:53:10,480 --> 00:53:15,839
 than the amortized constant time of

2488
00:53:12,710 --> 00:53:15,839
 

2489
00:53:12,720 --> 00:53:15,839
 putting items into a vector

2490
00:53:18,309 --> 00:53:18,309
 

2491
00:53:18,319 --> 00:53:22,640
 and now that brings us to

2492
00:53:23,430 --> 00:53:23,430
 

2493
00:53:23,440 --> 00:53:26,960
 back to our goal right remember we had

2494
00:53:26,390 --> 00:53:26,960
 

2495
00:53:26,400 --> 00:53:30,000
 this goal

2496
00:53:26,950 --> 00:53:30,000
 

2497
00:53:26,960 --> 00:53:32,880
 no contradictions

2498
00:53:29,990 --> 00:53:32,880
 

2499
00:53:30,000 --> 00:53:32,880
 what does that mean

2500
00:53:35,109 --> 00:53:35,109
 

2501
00:53:35,119 --> 00:53:40,079
 well if i were in an audience i would

2502
00:53:38,630 --> 00:53:40,079
 

2503
00:53:38,640 --> 00:53:42,800
 ask people to raise their hands

2504
00:53:40,069 --> 00:53:42,800
 

2505
00:53:40,079 --> 00:53:45,040
 you don't have to though how many people

2506
00:53:42,790 --> 00:53:45,040
 

2507
00:53:42,800 --> 00:53:48,480
 know what double entry bookkeeping is

2508
00:53:45,030 --> 00:53:48,480
 

2509
00:53:45,040 --> 00:53:48,480
 you can just answer to yourselves

2510
00:53:48,790 --> 00:53:48,790
 

2511
00:53:48,800 --> 00:53:52,640
 double entry bookkeeping is an

2512
00:53:50,390 --> 00:53:52,640
 

2513
00:53:50,400 --> 00:53:55,440
 accounting tool for error detection and

2514
00:53:52,630 --> 00:53:55,440
 

2515
00:53:52,640 --> 00:53:57,119
 fraud prevention

2516
00:53:55,430 --> 00:53:57,119
 

2517
00:53:55,440 --> 00:53:59,200
 it relies on something known as the

2518
00:53:57,109 --> 00:53:59,200
 

2519
00:53:57,119 --> 00:54:00,480
 accounting equation which is assets

2520
00:53:59,190 --> 00:54:00,480
 

2521
00:53:59,200 --> 00:54:04,480
 equals liability

2522
00:54:00,470 --> 00:54:04,480
 

2523
00:54:00,480 --> 00:54:07,599
 plus equity which is an example of

2524
00:54:04,470 --> 00:54:07,599
 

2525
00:54:04,480 --> 00:54:07,599
 equation reasoning

2526
00:54:08,549 --> 00:54:08,549
 

2527
00:54:08,559 --> 00:54:14,240
 it was pioneered in the 11th century by

2528
00:54:11,030 --> 00:54:14,240
 

2529
00:54:11,040 --> 00:54:16,240
 the jewish banking community

2530
00:54:14,230 --> 00:54:16,240
 

2531
00:54:14,240 --> 00:54:19,680
 likely developed independently in korea

2532
00:54:16,230 --> 00:54:19,680
 

2533
00:54:16,240 --> 00:54:19,680
 in about the same time period

2534
00:54:19,829 --> 00:54:19,829
 

2535
00:54:19,839 --> 00:54:24,079
 and in the 14th century double entry

2536
00:54:21,829 --> 00:54:24,079
 

2537
00:54:21,839 --> 00:54:26,720
 bookkeeping was adopted

2538
00:54:24,069 --> 00:54:26,720
 

2539
00:54:24,079 --> 00:54:29,440
 by the medici bank which is a name you

2540
00:54:26,710 --> 00:54:29,440
 

2541
00:54:26,720 --> 00:54:31,599
 might have heard of

2542
00:54:29,430 --> 00:54:31,599
 

2543
00:54:29,440 --> 00:54:33,520
 in fact double entry bookkeeping is

2544
00:54:31,589 --> 00:54:33,520
 

2545
00:54:31,599 --> 00:54:37,040
 credited with establishing the medici

2546
00:54:33,510 --> 00:54:37,040
 

2547
00:54:33,520 --> 00:54:38,880
 bank as reliable and trustworthy

2548
00:54:37,030 --> 00:54:38,880
 

2549
00:54:37,040 --> 00:54:43,280
 leading to the rise of one of the most

2550
00:54:38,870 --> 00:54:43,280
 

2551
00:54:38,880 --> 00:54:43,280
 powerful family dynasties in history

2552
00:54:44,789 --> 00:54:44,789
 

2553
00:54:44,799 --> 00:54:50,160
 double entry bookkeeping was codified by

2554
00:54:47,829 --> 00:54:50,160
 

2555
00:54:47,839 --> 00:54:51,599
 luca pacholi he's the father of

2556
00:54:50,150 --> 00:54:51,599
 

2557
00:54:50,160 --> 00:54:56,240
 accounting

2558
00:54:51,589 --> 00:54:56,240
 

2559
00:54:51,599 --> 00:54:56,240
 and it was codified in 1494.

2560
00:54:56,630 --> 00:54:56,630
 

2561
00:54:56,640 --> 00:55:02,079
 that's a picture of luca pacholi

2562
00:54:59,750 --> 00:55:02,079
 

2563
00:54:59,760 --> 00:55:04,480
 the other individual standing behind him

2564
00:55:02,069 --> 00:55:04,480
 

2565
00:55:02,079 --> 00:55:07,920
 is known as the perpetual student

2566
00:55:04,470 --> 00:55:07,920
 

2567
00:55:04,480 --> 00:55:09,839
 nobody's quite sure who he was uh

2568
00:55:07,910 --> 00:55:09,839
 

2569
00:55:07,920 --> 00:55:14,319
 but he made it may have been a friend of

2570
00:55:09,829 --> 00:55:14,319
 

2571
00:55:09,839 --> 00:55:14,319
 the the artists another artist drawer

2572
00:55:17,349 --> 00:55:17,349
 

2573
00:55:17,359 --> 00:55:22,400
 so double entry bookkeeping

2574
00:55:20,470 --> 00:55:22,400
 

2575
00:55:20,480 --> 00:55:23,520
 how does it work every transaction is

2576
00:55:22,390 --> 00:55:23,520
 

2577
00:55:22,400 --> 00:55:26,160
 entered twice

2578
00:55:23,510 --> 00:55:26,160
 

2579
00:55:23,520 --> 00:55:27,680
 into at least two separate accounts

2580
00:55:26,150 --> 00:55:27,680
 

2581
00:55:26,160 --> 00:55:29,839
 there are five standard accounts

2582
00:55:27,670 --> 00:55:29,839
 

2583
00:55:27,680 --> 00:55:32,160
 assets capital liabilities revenues and

2584
00:55:29,829 --> 00:55:32,160
 

2585
00:55:29,839 --> 00:55:34,319
 expenses

2586
00:55:32,150 --> 00:55:34,319
 

2587
00:55:32,160 --> 00:55:36,160
 addition this ensures the mechanical

2588
00:55:34,309 --> 00:55:36,160
 

2589
00:55:34,319 --> 00:55:38,400
 process of entering a transaction is

2590
00:55:36,150 --> 00:55:38,400
 

2591
00:55:36,160 --> 00:55:40,079
 done in two distinct ways

2592
00:55:38,390 --> 00:55:40,079
 

2593
00:55:38,400 --> 00:55:41,839
 right every transaction is entered into

2594
00:55:40,069 --> 00:55:41,839
 

2595
00:55:40,079 --> 00:55:44,000
 two accounts but there's not just two

2596
00:55:41,829 --> 00:55:44,000
 

2597
00:55:41,839 --> 00:55:47,119
 accounts there's five accounts

2598
00:55:43,990 --> 00:55:47,119
 

2599
00:55:44,000 --> 00:55:48,720
 so for any you know pair of transactions

2600
00:55:47,109 --> 00:55:48,720
 

2601
00:55:47,119 --> 00:55:52,240
 they might span

2602
00:55:48,710 --> 00:55:52,240
 

2603
00:55:48,720 --> 00:55:54,799
 two different accounts if the accounting

2604
00:55:52,230 --> 00:55:54,799
 

2605
00:55:52,240 --> 00:55:57,440
 equation is not satisfied then we have a

2606
00:55:54,789 --> 00:55:57,440
 

2607
00:55:54,799 --> 00:56:00,480
 contradiction

2608
00:55:57,430 --> 00:56:00,480
 

2609
00:55:57,440 --> 00:56:02,880
 so what's a contradiction

2610
00:56:00,470 --> 00:56:02,880
 

2611
00:56:00,480 --> 00:56:04,319
 well that's when two relationships apply

2612
00:56:02,870 --> 00:56:04,319
 

2613
00:56:02,880 --> 00:56:07,440
 imply the same entity

2614
00:56:04,309 --> 00:56:07,440
 

2615
00:56:04,319 --> 00:56:07,440
 has different values

2616
00:56:07,910 --> 00:56:07,910
 

2617
00:56:07,920 --> 00:56:14,000
 relationships are consistent if they

2618
00:56:09,829 --> 00:56:14,000
 

2619
00:56:09,839 --> 00:56:17,040
 imply the same entity has the same value

2620
00:56:13,990 --> 00:56:17,040
 

2621
00:56:14,000 --> 00:56:20,400
 right so if we have two relationships

2622
00:56:17,030 --> 00:56:20,400
 

2623
00:56:17,040 --> 00:56:24,880
 both implying the same entity

2624
00:56:20,390 --> 00:56:24,880
 

2625
00:56:20,400 --> 00:56:24,880
 that has to be the same value

2626
00:56:25,190 --> 00:56:25,190
 

2627
00:56:25,200 --> 00:56:31,839
 so this happens to be the exact same

2628
00:56:26,950 --> 00:56:31,839
 

2629
00:56:26,960 --> 00:56:31,839
 structure that we have for a data race

2630
00:56:34,390 --> 00:56:34,390
 

2631
00:56:34,400 --> 00:56:37,839
 when two or more threads access the same

2632
00:56:36,309 --> 00:56:37,839
 

2633
00:56:36,319 --> 00:56:39,040
 object concurrently and at least one

2634
00:56:37,829 --> 00:56:39,040
 

2635
00:56:37,839 --> 00:56:42,160
 thread is writing

2636
00:56:39,030 --> 00:56:42,160
 

2637
00:56:39,040 --> 00:56:42,160
 we have a contradiction

2638
00:56:43,670 --> 00:56:43,670
 

2639
00:56:43,680 --> 00:56:47,760
 we could resolve the race with a mutex

2640
00:56:46,549 --> 00:56:47,760
 

2641
00:56:46,559 --> 00:56:48,960
 right we can put an additional

2642
00:56:47,750 --> 00:56:48,960
 

2643
00:56:47,760 --> 00:56:51,839
 relationship in

2644
00:56:48,950 --> 00:56:51,839
 

2645
00:56:48,960 --> 00:56:51,839
 so we have now

2646
00:56:52,390 --> 00:56:52,390
 

2647
00:56:52,400 --> 00:56:56,720
 our two relationships write out two

2648
00:56:55,510 --> 00:56:56,720
 

2649
00:56:55,520 --> 00:56:59,040
 separate values

2650
00:56:56,710 --> 00:56:59,040
 

2651
00:56:56,720 --> 00:57:00,640
 those get fed into a mutex the mutex

2652
00:56:59,030 --> 00:57:00,640
 

2653
00:56:59,040 --> 00:57:05,200
 decides which one wins

2654
00:57:00,630 --> 00:57:05,200
 

2655
00:57:00,640 --> 00:57:05,200
 and imposes that as our resulting object

2656
00:57:05,349 --> 00:57:05,349
 

2657
00:57:05,359 --> 00:57:09,119
 but what does that relationship mean

2658
00:57:09,670 --> 00:57:09,670
 

2659
00:57:09,680 --> 00:57:13,359
 right it's a last one in wins

2660
00:57:12,549 --> 00:57:13,359
 

2661
00:57:12,559 --> 00:57:15,680
 relationship

2662
00:57:13,349 --> 00:57:15,680
 

2663
00:57:13,359 --> 00:57:16,799
 which is kind of an odd relationship and

2664
00:57:15,670 --> 00:57:16,799
 

2665
00:57:15,680 --> 00:57:20,000
 it's certainly a very difficult

2666
00:57:16,789 --> 00:57:20,000
 

2667
00:57:16,799 --> 00:57:24,480
 relationship to reason about so when

2668
00:57:19,990 --> 00:57:24,480
 

2669
00:57:20,000 --> 00:57:28,000
 i point out a data race in a code review

2670
00:57:24,470 --> 00:57:28,000
 

2671
00:57:24,480 --> 00:57:30,720
 and the engineer says oh well that's

2672
00:57:27,990 --> 00:57:30,720
 

2673
00:57:28,000 --> 00:57:34,799
 easy and they throw in a mutex

2674
00:57:30,710 --> 00:57:34,799
 

2675
00:57:30,720 --> 00:57:37,599
 this is usually my expression

2676
00:57:34,789 --> 00:57:37,599
 

2677
00:57:34,799 --> 00:57:39,359
 is this does this fix the problem does

2678
00:57:37,589 --> 00:57:39,359
 

2679
00:57:37,599 --> 00:57:42,720
 it not fix the problem

2680
00:57:39,349 --> 00:57:42,720
 

2681
00:57:39,359 --> 00:57:43,599
 i don't know right what's the actual

2682
00:57:42,710 --> 00:57:43,599
 

2683
00:57:42,720 --> 00:57:46,960
 relationship

2684
00:57:43,589 --> 00:57:46,960
 

2685
00:57:43,599 --> 00:57:46,960
 between those two values

2686
00:57:48,150 --> 00:57:48,150
 

2687
00:57:48,160 --> 00:57:51,280
 which is a goal from one to my other

2688
00:57:50,630 --> 00:57:51,280
 

2689
00:57:50,640 --> 00:57:53,359
 talks

2690
00:57:51,270 --> 00:57:53,359
 

2691
00:57:51,280 --> 00:57:54,559
 no raw synchronization primitives that

2692
00:57:53,349 --> 00:57:54,559
 

2693
00:57:53,359 --> 00:57:57,760
 also first appeared in my c

2694
00:57:54,549 --> 00:57:57,760
 

2695
00:57:54,559 --> 00:57:57,760
 plus plus seasoning talk

2696
00:57:57,910 --> 00:57:57,910
 

2697
00:57:57,920 --> 00:58:03,119
 right null pointer dereferences are

2698
00:58:00,150 --> 00:58:03,119
 

2699
00:58:00,160 --> 00:58:06,160
 another example of a contradiction

2700
00:58:03,109 --> 00:58:06,160
 

2701
00:58:03,119 --> 00:58:07,040
 right if i do p equals member i get a

2702
00:58:06,150 --> 00:58:07,040
 

2703
00:58:06,160 --> 00:58:10,079
 sigport

2704
00:58:07,030 --> 00:58:10,079
 

2705
00:58:07,040 --> 00:58:12,559
 if p was null right

2706
00:58:10,069 --> 00:58:12,559
 

2707
00:58:10,079 --> 00:58:14,240
 right why well i've got this underlying

2708
00:58:12,549 --> 00:58:14,240
 

2709
00:58:12,559 --> 00:58:15,599
 rule that says i can't dereference a

2710
00:58:14,230 --> 00:58:15,599
 

2711
00:58:14,240 --> 00:58:17,839
 null pointer

2712
00:58:15,589 --> 00:58:17,839
 

2713
00:58:15,599 --> 00:58:18,799
 if i dereference a null pointer i've got

2714
00:58:17,829 --> 00:58:18,799
 

2715
00:58:17,839 --> 00:58:23,119
 a contradiction

2716
00:58:18,789 --> 00:58:23,119
 

2717
00:58:18,799 --> 00:58:26,480
 and i get undefined behavior

2718
00:58:23,109 --> 00:58:26,480
 

2719
00:58:23,119 --> 00:58:28,400
 right how can i fix that well i could

2720
00:58:26,470 --> 00:58:28,400
 

2721
00:58:26,480 --> 00:58:30,559
 check to see if the pointer is null or

2722
00:58:28,390 --> 00:58:30,559
 

2723
00:58:28,400 --> 00:58:33,760
 not

2724
00:58:30,549 --> 00:58:33,760
 

2725
00:58:30,559 --> 00:58:33,760
 before i dereference it

2726
00:58:34,789 --> 00:58:34,789
 

2727
00:58:34,799 --> 00:58:39,040
 right i can say if p then p member

2728
00:58:41,589 --> 00:58:41,589
 

2729
00:58:41,599 --> 00:58:47,200
 the graceful handling of nothing as a

2730
00:58:44,069 --> 00:58:47,200
 

2731
00:58:44,079 --> 00:58:52,559
 limit is important

2732
00:58:47,190 --> 00:58:52,559
 

2733
00:58:47,200 --> 00:58:52,559
 we have empty ranges such as xero etc

2734
00:58:57,030 --> 00:58:57,030
 

2735
00:58:57,040 --> 00:59:01,280
 but frequently you know removing

2736
00:58:59,430 --> 00:59:01,280
 

2737
00:58:59,440 --> 00:59:03,440
 sections of code to avoid a crash is

2738
00:59:01,270 --> 00:59:03,440
 

2739
00:59:01,280 --> 00:59:06,559
 likely only moving the contradiction

2740
00:59:03,430 --> 00:59:06,559
 

2741
00:59:03,440 --> 00:59:07,440
 someplace else and i'll give answers

2742
00:59:06,549 --> 00:59:07,440
 

2743
00:59:06,559 --> 00:59:10,880
 like this

2744
00:59:07,430 --> 00:59:10,880
 

2745
00:59:07,440 --> 00:59:12,720
 just saying that if p don't do the thing

2746
00:59:10,870 --> 00:59:12,720
 

2747
00:59:10,880 --> 00:59:14,160
 right you just removed conditionally a

2748
00:59:12,710 --> 00:59:14,160
 

2749
00:59:12,720 --> 00:59:16,720
 section of code

2750
00:59:14,150 --> 00:59:16,720
 

2751
00:59:14,160 --> 00:59:19,839
 and you didn't really think through what

2752
00:59:16,710 --> 00:59:19,839
 

2753
00:59:16,720 --> 00:59:19,839
 is the underlying relationship

2754
00:59:21,589 --> 00:59:21,589
 

2755
00:59:21,599 --> 00:59:26,400
 so pro tip use spr strong preconditions

2756
00:59:25,190 --> 00:59:26,400
 

2757
00:59:25,200 --> 00:59:28,319
 to move the issue

2758
00:59:26,390 --> 00:59:28,319
 

2759
00:59:26,400 --> 00:59:30,319
 up to the caller right if you can

2760
00:59:28,309 --> 00:59:30,319
 

2761
00:59:28,319 --> 00:59:32,160
 resolve these issues at a higher level

2762
00:59:30,309 --> 00:59:32,160
 

2763
00:59:30,319 --> 00:59:33,680
 you're probably doing a better job than

2764
00:59:32,150 --> 00:59:33,680
 

2765
00:59:32,160 --> 00:59:34,960
 trying to make the decision at a lower

2766
00:59:33,670 --> 00:59:34,960
 

2767
00:59:33,680 --> 00:59:36,720
 level

2768
00:59:34,950 --> 00:59:36,720
 

2769
00:59:34,960 --> 00:59:38,160
 so transform a function that's taking a

2770
00:59:36,710 --> 00:59:38,160
 

2771
00:59:36,720 --> 00:59:40,319
 pointer and then dereferencing the

2772
00:59:38,150 --> 00:59:40,319
 

2773
00:59:38,160 --> 00:59:42,400
 pointer if you can

2774
00:59:40,309 --> 00:59:42,400
 

2775
00:59:40,319 --> 00:59:44,240
 into a function that takes a reference

2776
00:59:42,390 --> 00:59:44,240
 

2777
00:59:42,400 --> 00:59:45,599
 and now it becomes the caller's job to

2778
00:59:44,230 --> 00:59:45,599
 

2779
00:59:44,240 --> 00:59:47,839
 make sure they're handing you a valid

2780
00:59:45,589 --> 00:59:47,839
 

2781
00:59:45,599 --> 00:59:47,839
 reference

2782
00:59:51,349 --> 00:59:51,349
 

2783
00:59:51,359 --> 00:59:54,880
 two functions setting the same value

2784
00:59:53,270 --> 00:59:54,880
 

2785
00:59:53,280 --> 00:59:58,799
 through a shared pointer

2786
00:59:54,870 --> 00:59:58,799
 

2787
00:59:54,880 --> 01:00:01,040
 that can also be a contradiction right

2788
00:59:58,789 --> 01:00:01,040
 

2789
00:59:58,799 --> 01:00:04,160
 i can set the property someplace else i

2790
01:00:01,030 --> 01:00:04,160
 

2791
01:00:01,040 --> 01:00:07,040
 call pset property

2792
01:00:04,150 --> 01:00:07,040
 

2793
01:00:04,160 --> 01:00:08,720
 what does that even mean maybe the

2794
01:00:07,030 --> 01:00:08,720
 

2795
01:00:07,040 --> 01:00:10,240
 code's redundant maybe i should only be

2796
01:00:08,710 --> 01:00:10,240
 

2797
01:00:08,720 --> 01:00:13,280
 setting it from one

2798
01:00:10,230 --> 01:00:13,280
 

2799
01:00:10,240 --> 01:00:15,280
 place and not the other

2800
01:00:13,270 --> 01:00:15,280
 

2801
01:00:13,280 --> 01:00:17,520
 maybe what there really is is a single

2802
01:00:15,270 --> 01:00:17,520
 

2803
01:00:15,280 --> 01:00:18,960
 relationship and this is different flows

2804
01:00:17,510 --> 01:00:18,960
 

2805
01:00:17,520 --> 01:00:20,079
 through that one relationship right

2806
01:00:18,950 --> 01:00:20,079
 

2807
01:00:18,960 --> 01:00:21,599
 remember relationships are

2808
01:00:20,069 --> 01:00:21,599
 

2809
01:00:20,079 --> 01:00:25,040
 bi-directional

2810
01:00:21,589 --> 01:00:25,040
 

2811
01:00:21,599 --> 01:00:27,760
 so maybe uh i go one way

2812
01:00:25,030 --> 01:00:27,760
 

2813
01:00:25,040 --> 01:00:30,400
 when i'm calculating a times b and a is

2814
01:00:27,750 --> 01:00:30,400
 

2815
01:00:27,760 --> 01:00:32,400
 changed and i'm following the other path

2816
01:00:30,390 --> 01:00:32,400
 

2817
01:00:30,400 --> 01:00:35,440
 to represent the relationship a times b

2818
01:00:32,390 --> 01:00:35,440
 

2819
01:00:32,400 --> 01:00:35,440
 when b is changed

2820
01:00:35,670 --> 01:00:35,670
 

2821
01:00:35,680 --> 01:00:40,000
 maybe they're mutually exclusive and

2822
01:00:41,430 --> 01:00:41,430
 

2823
01:00:41,440 --> 01:00:46,240
 it's a mutually exclusive relationship

2824
01:00:43,510 --> 01:00:46,240
 

2825
01:00:43,520 --> 01:00:48,319
 with non-local control

2826
01:00:46,230 --> 01:00:48,319
 

2827
01:00:46,240 --> 01:00:51,680
 right maybe it really does imply last

2828
01:00:48,309 --> 01:00:51,680
 

2829
01:00:48,319 --> 01:00:51,680
 one in wind's relationship

2830
01:00:54,309 --> 01:00:54,309
 

2831
01:00:54,319 --> 01:00:57,760
 connecting two shared pointers like this

2832
01:00:55,990 --> 01:00:57,760
 

2833
01:00:56,000 --> 01:01:00,960
 create an incidental

2834
01:00:57,750 --> 01:01:00,960
 

2835
01:00:57,760 --> 01:01:03,200
 algorithm right or maybe this is an

2836
01:01:00,950 --> 01:01:03,200
 

2837
01:01:00,960 --> 01:01:04,640
 incidental algorithm where the property

2838
01:01:03,190 --> 01:01:04,640
 

2839
01:01:03,200 --> 01:01:06,000
 is going to be changing over time from

2840
01:01:04,630 --> 01:01:06,000
 

2841
01:01:04,640 --> 01:01:06,480
 different places in the code and it's

2842
01:01:05,990 --> 01:01:06,480
 

2843
01:01:06,000 --> 01:01:10,160
 going to

2844
01:01:06,470 --> 01:01:10,160
 

2845
01:01:06,480 --> 01:01:13,119
 converge to a correct value

2846
01:01:10,150 --> 01:01:13,119
 

2847
01:01:10,160 --> 01:01:13,760
 right the property here is not a simple

2848
01:01:13,109 --> 01:01:13,760
 

2849
01:01:13,119 --> 01:01:14,880
 property

2850
01:01:13,750 --> 01:01:14,880
 

2851
01:01:13,760 --> 01:01:17,040
 maybe the property is not a simple

2852
01:01:14,870 --> 01:01:17,040
 

2853
01:01:14,880 --> 01:01:20,079
 property maybe it's a stream a trigger

2854
01:01:17,030 --> 01:01:20,079
 

2855
01:01:17,040 --> 01:01:24,880
 or a latch of some kind

2856
01:01:20,069 --> 01:01:24,880
 

2857
01:01:20,079 --> 01:01:26,720
 or maybe it's just wrong

2858
01:01:24,870 --> 01:01:26,720
 

2859
01:01:24,880 --> 01:01:28,160
 all right so when i see shared pointers

2860
01:01:26,710 --> 01:01:28,160
 

2861
01:01:26,720 --> 01:01:31,119
 in a code review

2862
01:01:28,150 --> 01:01:31,119
 

2863
01:01:28,160 --> 01:01:31,119
 that's my expression

2864
01:01:31,589 --> 01:01:31,589
 

2865
01:01:31,599 --> 01:01:40,720
 no raw pointers

2866
01:01:38,069 --> 01:01:40,720
 

2867
01:01:38,079 --> 01:01:42,240
 consider the essential relationships

2868
01:01:40,710 --> 01:01:42,240
 

2869
01:01:40,720 --> 01:01:44,720
 this is what you need to learn to play

2870
01:01:42,230 --> 01:01:44,720
 

2871
01:01:42,240 --> 01:01:44,720
 the game

2872
01:01:45,190 --> 01:01:45,190
 

2873
01:01:45,200 --> 01:01:48,640
 learn to see the structure in your code

2874
01:01:47,670 --> 01:01:48,640
 

2875
01:01:47,680 --> 01:01:51,280
 take it apart

2876
01:01:48,630 --> 01:01:51,280
 

2877
01:01:48,640 --> 01:01:54,880
 draw it out on a whiteboard learn to

2878
01:01:51,270 --> 01:01:54,880
 

2879
01:01:51,280 --> 01:01:57,920
 read to decompose it and recompose it

2880
01:01:54,870 --> 01:01:57,920
 

2881
01:01:54,880 --> 01:01:57,920
 architecture code

2882
01:01:58,710 --> 01:01:58,710
 

2883
01:01:58,720 --> 01:02:02,960
 and that's the end of my talk if you'd

2884
01:02:01,270 --> 01:02:02,960
 

2885
01:02:01,280 --> 01:02:04,000
 like to see more of my talks they can be

2886
01:02:02,950 --> 01:02:04,000
 

2887
01:02:02,960 --> 01:02:06,520
 found

2888
01:02:03,990 --> 01:02:06,520
 

2889
01:02:04,000 --> 01:02:08,240
 on my website which is

2890
01:02:06,510 --> 01:02:08,240
 

2891
01:02:06,520 --> 01:02:10,480
 seanparent.stlab.cc

2892
01:02:08,230 --> 01:02:10,480
 

2893
01:02:08,240 --> 01:02:13,280
 and there's a link at the top for papers

2894
01:02:10,470 --> 01:02:13,280
 

2895
01:02:10,480 --> 01:02:13,280
 and presentations

2896
01:02:14,390 --> 01:02:14,390
 

2897
01:02:14,400 --> 01:02:17,440
 i also want to point out photoshop is

2898
01:02:16,309 --> 01:02:17,440
 

2899
01:02:16,319 --> 01:02:19,520
 hiring

2900
01:02:17,430 --> 01:02:19,520
 

2901
01:02:17,440 --> 01:02:21,280
 i think we have eight open positions

2902
01:02:19,510 --> 01:02:21,280
 

2903
01:02:19,520 --> 01:02:24,480
 right now and

2904
01:02:21,270 --> 01:02:24,480
 

2905
01:02:21,280 --> 01:02:26,079
 in fact there may be an open position to

2906
01:02:24,470 --> 01:02:26,079
 

2907
01:02:24,480 --> 01:02:29,119
 be working directly with me

2908
01:02:26,069 --> 01:02:29,119
 

2909
01:02:26,079 --> 01:02:31,760
 so please check out the website and if

2910
01:02:29,109 --> 01:02:31,760
 

2911
01:02:29,119 --> 01:02:36,079
 one of those positions interests you

2912
01:02:31,750 --> 01:02:36,079
 

2913
01:02:31,760 --> 01:02:36,079
 submit your resume or your cv

2914
01:02:37,910 --> 01:02:37,910
 

2915
01:02:37,920 --> 01:02:44,319
 thank you and i will open it up to see

2916
01:02:41,829 --> 01:02:44,319
 

2917
01:02:41,839 --> 01:02:46,200
 if there's any questions

2918
01:02:44,309 --> 01:02:46,200
 

2919
01:02:44,319 --> 01:02:49,520
 ah so somebody asked why no raw

2920
01:02:46,190 --> 01:02:49,520
 

2921
01:02:46,200 --> 01:02:53,200
 synchronization primitives the meaning

2922
01:02:49,510 --> 01:02:53,200
 

2923
01:02:49,520 --> 01:02:56,799
 right so first when i say

2924
01:02:53,190 --> 01:02:56,799
 

2925
01:02:53,200 --> 01:02:58,960
 raw what i mean is

2926
01:02:56,789 --> 01:02:58,960
 

2927
01:02:56,799 --> 01:03:00,000
 is a relatively primitive construct that

2928
01:02:58,950 --> 01:03:00,000
 

2929
01:02:58,960 --> 01:03:04,160
 just appears

2930
01:02:59,990 --> 01:03:04,160
 

2931
01:03:00,000 --> 01:03:05,280
 say within a large larger function or

2932
01:03:04,150 --> 01:03:05,280
 

2933
01:03:04,160 --> 01:03:06,880
 member function or

2934
01:03:05,270 --> 01:03:06,880
 

2935
01:03:05,280 --> 01:03:10,000
 dropped into the middle of some piece of

2936
01:03:06,870 --> 01:03:10,000
 

2937
01:03:06,880 --> 01:03:12,160
 code so when i say no raw loops

2938
01:03:09,990 --> 01:03:12,160
 

2939
01:03:10,000 --> 01:03:13,839
 right what i mean is don't it's not

2940
01:03:12,150 --> 01:03:13,839
 

2941
01:03:12,160 --> 01:03:15,280
 don't ever write a loop you

2942
01:03:13,829 --> 01:03:15,280
 

2943
01:03:13,839 --> 01:03:17,280
 write lots of loops but when you are

2944
01:03:15,270 --> 01:03:17,280
 

2945
01:03:15,280 --> 01:03:20,720
 writing a loop encapsulate it into

2946
01:03:17,270 --> 01:03:20,720
 

2947
01:03:17,280 --> 01:03:21,520
 a separate algorithm raw synchronization

2948
01:03:20,710 --> 01:03:21,520
 

2949
01:03:20,720 --> 01:03:25,280
 primitives

2950
01:03:21,510 --> 01:03:25,280
 

2951
01:03:21,520 --> 01:03:25,280
 in this case are

2952
01:03:27,349 --> 01:03:27,349
 

2953
01:03:27,359 --> 01:03:34,559
 things like mutexes semaphores

2954
01:03:31,589 --> 01:03:34,559
 

2955
01:03:31,599 --> 01:03:35,119
 condition variables those are very

2956
01:03:34,549 --> 01:03:35,119
 

2957
01:03:34,559 --> 01:03:37,039
 difficult

2958
01:03:35,109 --> 01:03:37,039
 

2959
01:03:35,119 --> 01:03:40,640
 to use correctly and very difficult to

2960
01:03:37,029 --> 01:03:40,640
 

2961
01:03:37,039 --> 01:03:42,200
 get right instead you want

2962
01:03:40,630 --> 01:03:42,200
 

2963
01:03:40,640 --> 01:03:45,200
 higher level primitives you want

2964
01:03:42,190 --> 01:03:45,200
 

2965
01:03:42,200 --> 01:03:48,480
 continuations you want

2966
01:03:45,190 --> 01:03:48,480
 

2967
01:03:45,200 --> 01:03:48,480
 communication channels

2968
01:03:49,430 --> 01:03:49,430
 

2969
01:03:49,440 --> 01:03:53,920
 you want things that operate at at a

2970
01:03:52,630 --> 01:03:53,920
 

2971
01:03:52,640 --> 01:03:57,520
 much higher level

2972
01:03:53,910 --> 01:03:57,520
 

2973
01:03:53,920 --> 01:03:59,920
 than just throwing in mutexes

2974
01:03:57,510 --> 01:03:59,920
 

2975
01:03:57,520 --> 01:04:02,240
 so similarly when i say no raw pointers

2976
01:03:59,910 --> 01:04:02,240
 

2977
01:03:59,920 --> 01:04:05,680
 people frequently interpret that to mean

2978
01:04:02,230 --> 01:04:05,680
 

2979
01:04:02,240 --> 01:04:06,640
 like a t star but no even a shared

2980
01:04:05,670 --> 01:04:06,640
 

2981
01:04:05,680 --> 01:04:09,760
 pointer

2982
01:04:06,630 --> 01:04:09,760
 

2983
01:04:06,640 --> 01:04:11,599
 class is a raw pointer

2984
01:04:09,750 --> 01:04:11,599
 

2985
01:04:09,760 --> 01:04:13,440
 in the sense that i now have pointer

2986
01:04:11,589 --> 01:04:13,440
 

2987
01:04:11,599 --> 01:04:16,720
 semantics that aren't encapsulated

2988
01:04:13,430 --> 01:04:16,720
 

2989
01:04:13,440 --> 01:04:19,280
 behind a class with value semantics

2990
01:04:16,710 --> 01:04:19,280
 

2991
01:04:16,720 --> 01:04:21,119
 so what i said uh somebody posted here

2992
01:04:19,270 --> 01:04:21,119
 

2993
01:04:19,280 --> 01:04:23,280
 oh i don't understand how mutex can't

2994
01:04:21,109 --> 01:04:23,280
 

2995
01:04:21,119 --> 01:04:26,000
 solve a race condition oh mutex solves a

2996
01:04:23,270 --> 01:04:26,000
 

2997
01:04:23,280 --> 01:04:30,559
 data race condition but a mutex

2998
01:04:25,990 --> 01:04:30,559
 

2999
01:04:26,000 --> 01:04:33,599
 will equally as likely solve a um

3000
01:04:30,549 --> 01:04:33,599
 

3001
01:04:30,559 --> 01:04:34,240
 or create a logical race condition so if

3002
01:04:33,589 --> 01:04:34,240
 

3003
01:04:33,599 --> 01:04:37,440
 you

3004
01:04:34,230 --> 01:04:37,440
 

3005
01:04:34,240 --> 01:04:39,200
 uh watch my concurrency talk i give an

3006
01:04:37,430 --> 01:04:39,200
 

3007
01:04:37,440 --> 01:04:42,319
 example

3008
01:04:39,190 --> 01:04:42,319
 

3009
01:04:39,200 --> 01:04:46,240
 a reference counted class

3010
01:04:42,309 --> 01:04:46,240
 

3011
01:04:42,319 --> 01:04:48,559
 and memory leaking because

3012
01:04:46,230 --> 01:04:48,559
 

3013
01:04:46,240 --> 01:04:49,599
 i check the reference count once to see

3014
01:04:48,549 --> 01:04:49,599
 

3015
01:04:48,559 --> 01:04:52,880
 if the

3016
01:04:49,589 --> 01:04:52,880
 

3017
01:04:49,599 --> 01:04:56,799
 if the object is uniquely owned and then

3018
01:04:52,870 --> 01:04:56,799
 

3019
01:04:52,880 --> 01:04:56,799
 if it's not uniquely owned

3020
01:04:59,109 --> 01:04:59,109
 

3021
01:04:59,119 --> 01:05:04,079
 i go ahead and i give up the reference

3022
01:05:02,150 --> 01:05:04,079
 

3023
01:05:02,160 --> 01:05:05,599
 decrementing it but i don't check to see

3024
01:05:04,069 --> 01:05:05,599
 

3025
01:05:04,079 --> 01:05:07,200
 if it went to zero

3026
01:05:05,589 --> 01:05:07,200
 

3027
01:05:05,599 --> 01:05:09,200
 because by checking to see if it was

3028
01:05:07,190 --> 01:05:09,200
 

3029
01:05:07,200 --> 01:05:10,480
 uniquely owned it had to either be 1 or

3030
01:05:09,190 --> 01:05:10,480
 

3031
01:05:09,200 --> 01:05:14,400
 greater than 1

3032
01:05:10,470 --> 01:05:14,400
 

3033
01:05:10,480 --> 01:05:14,400
 assuming that it was greater than 1

3034
01:05:15,670 --> 01:05:15,670
 

3035
01:05:15,680 --> 01:05:19,520
 or knowing that it was greater than 1 at

3036
01:05:17,109 --> 01:05:19,520
 

3037
01:05:17,119 --> 01:05:21,760
 one point doesn't tell me on the next

3038
01:05:19,510 --> 01:05:21,760
 

3039
01:05:19,520 --> 01:05:24,960
 line looking at that atomic

3040
01:05:21,750 --> 01:05:24,960
 

3041
01:05:21,760 --> 01:05:27,599
 that now it could be b1

3042
01:05:24,950 --> 01:05:27,599
 

3043
01:05:24,960 --> 01:05:29,520
 and so so you end up even though you

3044
01:05:27,589 --> 01:05:29,520
 

3045
01:05:27,599 --> 01:05:30,960
 have an atomic you end up with a logical

3046
01:05:29,510 --> 01:05:30,960
 

3047
01:05:29,520 --> 01:05:37,839
 race and in that case the

3048
01:05:30,950 --> 01:05:37,839
 

3049
01:05:30,960 --> 01:05:37,839
 the problem was leaking memory

3050
01:05:41,029 --> 01:05:41,029
 

3051
01:05:41,039 --> 01:05:44,799
 uh so we said on two occasions i

3052
01:05:43,829 --> 01:05:44,799
 

3053
01:05:43,839 --> 01:05:47,920
 referred to any

3054
01:05:44,789 --> 01:05:47,920
 

3055
01:05:44,799 --> 01:05:50,559
 senior architect as he uh

3056
01:05:47,910 --> 01:05:50,559
 

3057
01:05:47,920 --> 01:05:51,680
 my sincere apologies for that i

3058
01:05:50,549 --> 01:05:51,680
 

3059
01:05:50,559 --> 01:05:56,319
 certainly work with

3060
01:05:51,670 --> 01:05:56,319
 

3061
01:05:51,680 --> 01:05:56,319
 some some wonderful female architects so

3062
01:05:56,390 --> 01:05:56,390
 

3063
01:05:56,400 --> 01:05:59,920
 i should say they that's a new question

3064
01:05:58,950 --> 01:05:59,920
 

3065
01:05:58,960 --> 01:06:01,680
 are there any

3066
01:05:59,910 --> 01:06:01,680
 

3067
01:05:59,920 --> 01:06:05,119
 learning materials you would partici

3068
01:06:01,670 --> 01:06:05,119
 

3069
01:06:01,680 --> 01:06:07,920
 particularly recommend

3070
01:06:05,109 --> 01:06:07,920
 

3071
01:06:05,119 --> 01:06:07,920
 uh you know

3072
01:06:10,230 --> 01:06:10,230
 

3073
01:06:10,240 --> 01:06:12,880
 that's uh

3074
01:06:15,510 --> 01:06:15,510
 

3075
01:06:15,520 --> 01:06:22,000
 uh that's

3076
01:06:18,630 --> 01:06:22,000
 

3077
01:06:18,640 --> 01:06:22,960
 that's that's interesting uh you know my

3078
01:06:21,990 --> 01:06:22,960
 

3079
01:06:22,000 --> 01:06:25,920
 usual go-to

3080
01:06:22,950 --> 01:06:25,920
 

3081
01:06:22,960 --> 01:06:26,240
 is is elements of programming uh but

3082
01:06:25,910 --> 01:06:26,240
 

3083
01:06:25,920 --> 01:06:28,480
 it's

3084
01:06:26,230 --> 01:06:28,480
 

3085
01:06:26,240 --> 01:06:29,839
 it's a fairly difficult book to get

3086
01:06:28,470 --> 01:06:29,839
 

3087
01:06:28,480 --> 01:06:31,359
 through it is now

3088
01:06:29,829 --> 01:06:31,359
 

3089
01:06:29,839 --> 01:06:32,480
 an open source book so you can just

3090
01:06:31,349 --> 01:06:32,480
 

3091
01:06:31,359 --> 01:06:33,440
 google for it and you'll find the

3092
01:06:32,470 --> 01:06:33,440
 

3093
01:06:32,480 --> 01:06:35,520
 website and

3094
01:06:33,430 --> 01:06:35,520
 

3095
01:06:33,440 --> 01:06:37,760
 and it's it's no longer being published

3096
01:06:35,510 --> 01:06:37,760
 

3097
01:06:35,520 --> 01:06:40,960
 but you can just download the pdf and

3098
01:06:37,750 --> 01:06:40,960
 

3099
01:06:37,760 --> 01:06:40,960
 and work through that

3100
01:06:42,470 --> 01:06:42,470
 

3101
01:06:42,480 --> 01:06:47,680
 so so i think that's a great book if you

3102
01:06:44,470 --> 01:06:47,680
 

3103
01:06:44,480 --> 01:06:51,280
 want to understand kind of

3104
01:06:47,670 --> 01:06:51,280
 

3105
01:06:47,680 --> 01:06:53,440
 at uh you know less mathematical level

3106
01:06:51,270 --> 01:06:53,440
 

3107
01:06:51,280 --> 01:06:56,880
 the ideas that went into that book

3108
01:06:53,430 --> 01:06:56,880
 

3109
01:06:53,440 --> 01:06:58,960
 alex stepanov's from

3110
01:06:56,870 --> 01:06:58,960
 

3111
01:06:56,880 --> 01:07:00,000
 mathematics to generic programming is a

3112
01:06:58,950 --> 01:07:00,000
 

3113
01:06:58,960 --> 01:07:03,119
 very good book that's

3114
01:06:59,990 --> 01:07:03,119
 

3115
01:07:00,000 --> 01:07:06,480
 a much easier easier read

3116
01:07:03,109 --> 01:07:06,480
 

3117
01:07:03,119 --> 01:07:09,520
 so so that's a good entry point but no

3118
01:07:06,470 --> 01:07:09,520
 

3119
01:07:06,480 --> 01:07:12,799
 i don't have a lot of good good

3120
01:07:09,510 --> 01:07:12,799
 

3121
01:07:09,520 --> 01:07:14,400
 references to point at somebody asked

3122
01:07:12,789 --> 01:07:14,400
 

3123
01:07:12,799 --> 01:07:16,880
 do i always look at everything from an

3124
01:07:14,390 --> 01:07:16,880
 

3125
01:07:14,400 --> 01:07:19,920
 architecture perspective

3126
01:07:16,870 --> 01:07:19,920
 

3127
01:07:16,880 --> 01:07:23,039
 i do in the sense that

3128
01:07:19,910 --> 01:07:23,039
 

3129
01:07:19,920 --> 01:07:26,319
 i always look at

3130
01:07:23,029 --> 01:07:26,319
 

3131
01:07:23,039 --> 01:07:27,520
 the relationships between the functions

3132
01:07:26,309 --> 01:07:27,520
 

3133
01:07:26,319 --> 01:07:28,960
 and the objects

3134
01:07:27,510 --> 01:07:28,960
 

3135
01:07:27,520 --> 01:07:30,880
 that i'm dealing with and how these

3136
01:07:28,950 --> 01:07:30,880
 

3137
01:07:28,960 --> 01:07:34,720
 systems come together

3138
01:07:30,870 --> 01:07:34,720
 

3139
01:07:30,880 --> 01:07:36,799
 and when i'm doing code reviews uh

3140
01:07:34,710 --> 01:07:36,799
 

3141
01:07:34,720 --> 01:07:38,720
 i've mentioned before the first thing i

3142
01:07:36,789 --> 01:07:38,720
 

3143
01:07:36,799 --> 01:07:40,000
 do is i scan the code for loops and i

3144
01:07:38,710 --> 01:07:40,000
 

3145
01:07:38,720 --> 01:07:42,240
 usually start at the loops because

3146
01:07:39,990 --> 01:07:42,240
 

3147
01:07:40,000 --> 01:07:45,520
 that's usually where the problems are

3148
01:07:42,230 --> 01:07:45,520
 

3149
01:07:42,240 --> 01:07:49,359
 the second place will be conditionals

3150
01:07:45,510 --> 01:07:49,359
 

3151
01:07:45,520 --> 01:07:51,280
 and and uh those are the places where

3152
01:07:49,349 --> 01:07:51,280
 

3153
01:07:49,359 --> 01:07:54,880
 you're going to end up with

3154
01:07:51,270 --> 01:07:54,880
 

3155
01:07:51,280 --> 01:07:55,359
 with you know contradictions or logic

3156
01:07:54,870 --> 01:07:55,359
 

3157
01:07:54,880 --> 01:07:58,640
 errors

3158
01:07:55,349 --> 01:07:58,640
 

3159
01:07:55,359 --> 01:08:00,720
 errors of some kind uh

3160
01:07:58,630 --> 01:08:00,720
 

3161
01:07:58,640 --> 01:08:02,640
 and you know when i'm writing my own

3162
01:08:00,710 --> 01:08:02,640
 

3163
01:08:00,720 --> 01:08:04,720
 code i'm i'm always looking at

3164
01:08:02,630 --> 01:08:04,720
 

3165
01:08:02,640 --> 01:08:06,640
 can i decompose this into smaller parts

3166
01:08:04,710 --> 01:08:06,640
 

3167
01:08:04,720 --> 01:08:08,160
 to build up the larger parts and how

3168
01:08:06,630 --> 01:08:08,160
 

3169
01:08:06,640 --> 01:08:11,280
 does this compose to build

3170
01:08:08,150 --> 01:08:11,280
 

3171
01:08:08,160 --> 01:08:15,200
 a larger system

3172
01:08:11,270 --> 01:08:15,200
 

3173
01:08:11,280 --> 01:08:15,200
 let's see other questions that are here

3174
01:08:18,390 --> 01:08:18,390
 

3175
01:08:18,400 --> 01:08:22,159
 do they often lead to small refactorings

3176
01:08:20,470 --> 01:08:22,159
 

3177
01:08:20,480 --> 01:08:26,000
 or do you need to perform potentially

3178
01:08:22,149 --> 01:08:26,000
 

3179
01:08:22,159 --> 01:08:26,000
 large and practical refactorings

3180
01:08:26,950 --> 01:08:26,950
 

3181
01:08:26,960 --> 01:08:29,759
 you know sometimes

3182
01:08:31,189 --> 01:08:31,189
 

3183
01:08:31,199 --> 01:08:35,679
 you do have a need to to approach

3184
01:08:35,990 --> 01:08:35,990
 

3185
01:08:36,000 --> 01:08:40,719
 large refactorings to fix a system and

3186
01:08:38,870 --> 01:08:40,719
 

3187
01:08:38,880 --> 01:08:42,960
 this is one of the

3188
01:08:40,709 --> 01:08:42,960
 

3189
01:08:40,719 --> 01:08:44,640
 the current problems that i find with

3190
01:08:42,950 --> 01:08:44,640
 

3191
01:08:42,960 --> 01:08:46,000
 continuous deployment is it makes it

3192
01:08:44,630 --> 01:08:46,000
 

3193
01:08:44,640 --> 01:08:51,279
 very difficult to step back

3194
01:08:45,990 --> 01:08:51,279
 

3195
01:08:46,000 --> 01:08:51,279
 and do a large overhaul on a significant

3196
01:08:51,349 --> 01:08:51,349
 

3197
01:08:51,359 --> 01:08:55,279
 application and so a lot of times you're

3198
01:08:53,829 --> 01:08:55,279
 

3199
01:08:53,839 --> 01:08:57,920
 left with trying to

3200
01:08:55,269 --> 01:08:57,920
 

3201
01:08:55,279 --> 01:09:00,640
 make compromises and rebuild it small

3202
01:08:57,910 --> 01:09:00,640
 

3203
01:08:57,920 --> 01:09:03,199
 pieces at a time from the inside out

3204
01:09:00,630 --> 01:09:03,199
 

3205
01:09:00,640 --> 01:09:04,880
 um uh you know and you got to keep all

3206
01:09:03,189 --> 01:09:04,880
 

3207
01:09:03,199 --> 01:09:06,319
 your your unit tests running and

3208
01:09:04,870 --> 01:09:06,319
 

3209
01:09:04,880 --> 01:09:07,120
 everything else going which makes it

3210
01:09:06,309 --> 01:09:07,120
 

3211
01:09:06,319 --> 01:09:10,239
 very difficult

3212
01:09:07,110 --> 01:09:10,239
 

3213
01:09:07,120 --> 01:09:11,839
 to actually

3214
01:09:10,229 --> 01:09:11,839
 

3215
01:09:10,239 --> 01:09:14,239
 create a system where you can capitalize

3216
01:09:11,829 --> 01:09:14,239
 

3217
01:09:11,839 --> 01:09:16,319
 on the new architecture

3218
01:09:14,229 --> 01:09:16,319
 

3219
01:09:14,239 --> 01:09:18,799
 another approach that you can take is

3220
01:09:16,309 --> 01:09:18,799
 

3221
01:09:16,319 --> 01:09:22,319
 what we did with photoshop for mobile

3222
01:09:18,789 --> 01:09:22,319
 

3223
01:09:18,799 --> 01:09:25,520
 which was basically take the

3224
01:09:22,309 --> 01:09:25,520
 

3225
01:09:22,319 --> 01:09:26,239
 entire application as one node in your

3226
01:09:25,510 --> 01:09:26,239
 

3227
01:09:25,520 --> 01:09:29,679
 relationship

3228
01:09:26,229 --> 01:09:29,679
 

3229
01:09:26,239 --> 01:09:32,159
 graph and and and

3230
01:09:29,669 --> 01:09:32,159
 

3231
01:09:29,679 --> 01:09:33,759
 and effectively build a new application

3232
01:09:32,149 --> 01:09:33,759
 

3233
01:09:32,159 --> 01:09:36,799
 on top of it

3234
01:09:33,749 --> 01:09:36,799
 

3235
01:09:33,759 --> 01:09:40,560
 so what i mean by that is the way

3236
01:09:36,789 --> 01:09:40,560
 

3237
01:09:36,799 --> 01:09:41,440
 photoshop on ipad works is we took all

3238
01:09:40,550 --> 01:09:41,440
 

3239
01:09:40,560 --> 01:09:44,080
 of photoshop

3240
01:09:41,430 --> 01:09:44,080
 

3241
01:09:41,440 --> 01:09:45,839
 including all the ui constructs but we

3242
01:09:44,070 --> 01:09:45,839
 

3243
01:09:44,080 --> 01:09:48,080
 just stripped off the visual aspects of

3244
01:09:45,829 --> 01:09:48,080
 

3245
01:09:45,839 --> 01:09:51,199
 the ui

3246
01:09:48,070 --> 01:09:51,199
 

3247
01:09:48,080 --> 01:09:53,679
 and threw that into its own thread and

3248
01:09:51,189 --> 01:09:53,679
 

3249
01:09:51,199 --> 01:09:54,480
 every place where there was ui that

3250
01:09:53,669 --> 01:09:54,480
 

3251
01:09:53,679 --> 01:09:58,560
 became

3252
01:09:54,470 --> 01:09:58,560
 

3253
01:09:54,480 --> 01:09:59,520
 a as a collection of observable

3254
01:09:58,550 --> 01:09:59,520
 

3255
01:09:58,560 --> 01:10:00,880
 properties

3256
01:09:59,510 --> 01:10:00,880
 

3257
01:09:59,520 --> 01:10:03,040
 so those were properties that we could

3258
01:10:00,870 --> 01:10:03,040
 

3259
01:10:00,880 --> 01:10:04,480
 also both connect to and monitor when

3260
01:10:03,030 --> 01:10:04,480
 

3261
01:10:03,040 --> 01:10:08,719
 they changed

3262
01:10:04,470 --> 01:10:08,719
 

3263
01:10:04,480 --> 01:10:08,719
 and uh

3264
01:10:09,110 --> 01:10:09,110
 

3265
01:10:09,120 --> 01:10:13,120
 and set and so

3266
01:10:13,590 --> 01:10:13,590
 

3267
01:10:13,600 --> 01:10:17,679
 all what should have been you know

3268
01:10:15,350 --> 01:10:17,679
 

3269
01:10:15,360 --> 01:10:20,159
 application and model logic that over 30

3270
01:10:17,669 --> 01:10:20,159
 

3271
01:10:17,679 --> 01:10:21,840
 years had crept up into that ui layer we

3272
01:10:20,149 --> 01:10:21,840
 

3273
01:10:20,159 --> 01:10:23,600
 just captured the whole thing in one

3274
01:10:21,830 --> 01:10:23,600
 

3275
01:10:21,840 --> 01:10:26,640
 fell swoop

3276
01:10:23,590 --> 01:10:26,640
 

3277
01:10:23,600 --> 01:10:28,400
 and then we put a transaction model that

3278
01:10:26,630 --> 01:10:28,400
 

3279
01:10:26,640 --> 01:10:30,080
 has some guarantees

3280
01:10:28,390 --> 01:10:30,080
 

3281
01:10:28,400 --> 01:10:31,760
 around sequential consistency and it's

3282
01:10:30,070 --> 01:10:31,760
 

3283
01:10:30,080 --> 01:10:34,239
 non-blocking

3284
01:10:31,750 --> 01:10:34,239
 

3285
01:10:31,760 --> 01:10:36,480
 between the new ui surface and that

3286
01:10:34,229 --> 01:10:36,480
 

3287
01:10:34,239 --> 01:10:39,679
 asynchronous thread and we communicate

3288
01:10:36,470 --> 01:10:39,679
 

3289
01:10:36,480 --> 01:10:39,679
 between the two that way

3290
01:10:39,830 --> 01:10:39,830
 

3291
01:10:39,840 --> 01:10:46,239
 so so that's how

3292
01:10:43,350 --> 01:10:46,239
 

3293
01:10:43,360 --> 01:10:46,239
 how that works

3294
01:10:49,990 --> 01:10:49,990
 

3295
01:10:50,000 --> 01:10:53,120
 let's see is there a way to mark these

3296
01:10:52,790 --> 01:10:53,120
 

3297
01:10:52,800 --> 01:10:58,880
 as

3298
01:10:53,110 --> 01:10:58,880
 

3299
01:10:53,120 --> 01:11:01,040
 answered yes um how hard do my

3300
01:10:58,870 --> 01:11:01,040
 

3301
01:10:58,880 --> 01:11:04,960
 colleagues find it to pass a code review

3302
01:11:01,030 --> 01:11:04,960
 

3303
01:11:01,040 --> 01:11:05,840
 uh with me um uh you know it depends

3304
01:11:04,950 --> 01:11:05,840
 

3305
01:11:04,960 --> 01:11:07,679
 honestly

3306
01:11:05,830 --> 01:11:07,679
 

3307
01:11:05,840 --> 01:11:09,120
 somewhat on how busy i am and how

3308
01:11:07,669 --> 01:11:09,120
 

3309
01:11:07,679 --> 01:11:10,880
 interested it is on

3310
01:11:09,110 --> 01:11:10,880
 

3311
01:11:09,120 --> 01:11:12,560
 the the piece they're working in i don't

3312
01:11:10,870 --> 01:11:12,560
 

3313
01:11:10,880 --> 01:11:14,400
 have enough time to

3314
01:11:12,550 --> 01:11:14,400
 

3315
01:11:12,560 --> 01:11:16,960
 to look at every piece of code with the

3316
01:11:14,390 --> 01:11:16,960
 

3317
01:11:14,400 --> 01:11:21,440
 with the detail i would i would like

3318
01:11:16,950 --> 01:11:21,440
 

3319
01:11:16,960 --> 01:11:24,800
 um a a story i had a

3320
01:11:21,430 --> 01:11:24,800
 

3321
01:11:21,440 --> 01:11:28,480
 a young a

3322
01:11:24,790 --> 01:11:28,480
 

3323
01:11:24,800 --> 01:11:30,239
 young employee who

3324
01:11:28,470 --> 01:11:30,239
 

3325
01:11:28,480 --> 01:11:32,159
 i was mentoring when he first came on

3326
01:11:30,229 --> 01:11:32,159
 

3327
01:11:30,239 --> 01:11:36,400
 board

3328
01:11:32,149 --> 01:11:36,400
 

3329
01:11:32,159 --> 01:11:38,159
 and i gave him a task and he

3330
01:11:36,390 --> 01:11:38,159
 

3331
01:11:36,400 --> 01:11:39,760
 he would write part of it and come to me

3332
01:11:38,149 --> 01:11:39,760
 

3333
01:11:38,159 --> 01:11:42,640
 with a code review

3334
01:11:39,750 --> 01:11:42,640
 

3335
01:11:39,760 --> 01:11:45,679
 and i would slash it up and give it back

3336
01:11:42,630 --> 01:11:45,679
 

3337
01:11:42,640 --> 01:11:45,679
 to him and i was being

3338
01:11:49,189 --> 01:11:49,189
 

3339
01:11:49,199 --> 01:11:53,920
 brutal in the code review but but also i

3340
01:11:51,750 --> 01:11:53,920
 

3341
01:11:51,760 --> 01:11:55,199
 wanted him to really solve the problem

3342
01:11:53,910 --> 01:11:55,199
 

3343
01:11:53,920 --> 01:11:57,679
 and

3344
01:11:55,189 --> 01:11:57,679
 

3345
01:11:55,199 --> 01:11:59,440
 and and get to the the underlying piece

3346
01:11:57,669 --> 01:11:59,440
 

3347
01:11:57,679 --> 01:12:01,120
 and he got pretty frustrated at one

3348
01:11:59,430 --> 01:12:01,120
 

3349
01:11:59,440 --> 01:12:03,040
 point and walked into my office and said

3350
01:12:01,110 --> 01:12:03,040
 

3351
01:12:01,120 --> 01:12:04,880
 you know could you just

3352
01:12:03,030 --> 01:12:04,880
 

3353
01:12:03,040 --> 01:12:06,320
 tell me what the right answer is he was

3354
01:12:04,870 --> 01:12:06,320
 

3355
01:12:04,880 --> 01:12:07,760
 kind of tired of coming back

3356
01:12:06,310 --> 01:12:07,760
 

3357
01:12:06,320 --> 01:12:09,679
 and the honest answer is i didn't know

3358
01:12:07,750 --> 01:12:09,679
 

3359
01:12:07,760 --> 01:12:11,199
 what the right answer was i just knew

3360
01:12:09,669 --> 01:12:11,199
 

3361
01:12:09,679 --> 01:12:14,800
 that his wasn't correct

3362
01:12:11,189 --> 01:12:14,800
 

3363
01:12:11,199 --> 01:12:16,640
 and and he thought i was was

3364
01:12:14,790 --> 01:12:16,640
 

3365
01:12:14,800 --> 01:12:18,800
 just playing games but it's much easier

3366
01:12:16,630 --> 01:12:18,800
 

3367
01:12:16,640 --> 01:12:20,159
 to look at something and say

3368
01:12:18,790 --> 01:12:20,159
 

3369
01:12:18,800 --> 01:12:22,000
 i don't know what this is i don't know

3370
01:12:20,149 --> 01:12:22,000
 

3371
01:12:20,159 --> 01:12:25,920
 if this is correct you know please

3372
01:12:21,990 --> 01:12:25,920
 

3373
01:12:22,000 --> 01:12:28,320
 explain or go fix it um

3374
01:12:25,910 --> 01:12:28,320
 

3375
01:12:25,920 --> 01:12:29,280
 than it is to actually sit down and and

3376
01:12:28,310 --> 01:12:29,280
 

3377
01:12:28,320 --> 01:12:33,920
 and work through

3378
01:12:29,270 --> 01:12:33,920
 

3379
01:12:29,280 --> 01:12:33,920
 a design on your own so

3380
01:12:34,149 --> 01:12:34,149
 

3381
01:12:34,159 --> 01:12:40,000
 so so you know if

3382
01:12:37,270 --> 01:12:40,000
 

3383
01:12:37,280 --> 01:12:41,440
 if i'm in a in a detailed mindset i can

3384
01:12:39,990 --> 01:12:41,440
 

3385
01:12:40,000 --> 01:12:43,760
 be pretty difficult to get a code review

3386
01:12:41,430 --> 01:12:43,760
 

3387
01:12:41,440 --> 01:12:43,760
 passed

3388
01:12:44,709 --> 01:12:44,709
 

3389
01:12:44,719 --> 01:12:49,120
 ah let's see do you think the industry

3390
01:12:47,430 --> 01:12:49,120
 

3391
01:12:47,440 --> 01:12:50,159
 still started with a primitive whole

3392
01:12:49,110 --> 01:12:50,159
 

3393
01:12:49,120 --> 01:12:52,480
 design

3394
01:12:50,149 --> 01:12:52,480
 

3395
01:12:50,159 --> 01:12:54,800
 in their products design having all

3396
01:12:52,470 --> 01:12:54,800
 

3397
01:12:52,480 --> 01:13:00,560
 these

3398
01:12:54,790 --> 01:13:00,560
 

3399
01:12:54,800 --> 01:13:02,080
 agile and ci cd practices designed

3400
01:13:00,550 --> 01:13:02,080
 

3401
01:13:00,560 --> 01:13:04,080
 would it be hard dealing with such

3402
01:13:02,070 --> 01:13:04,080
 

3403
01:13:02,080 --> 01:13:07,120
 design refactoring could be handled

3404
01:13:04,070 --> 01:13:07,120
 

3405
01:13:04,080 --> 01:13:07,679
 as a tech debt later on yeah you know

3406
01:13:07,110 --> 01:13:07,679
 

3407
01:13:07,120 --> 01:13:10,159
 tech

3408
01:13:07,669 --> 01:13:10,159
 

3409
01:13:07,679 --> 01:13:11,600
 is it's very hard like i said before to

3410
01:13:10,149 --> 01:13:11,600
 

3411
01:13:10,159 --> 01:13:13,280
 fix things and it's very hard to get

3412
01:13:11,590 --> 01:13:13,280
 

3413
01:13:11,600 --> 01:13:15,360
 things right from the start

3414
01:13:13,270 --> 01:13:15,360
 

3415
01:13:13,280 --> 01:13:17,520
 so you have to kind of keep refactoring

3416
01:13:15,350 --> 01:13:17,520
 

3417
01:13:15,360 --> 01:13:20,480
 bottom up and so it eventually

3418
01:13:17,510 --> 01:13:20,480
 

3419
01:13:17,520 --> 01:13:23,520
 surface at surfaces out into your your

3420
01:13:20,470 --> 01:13:23,520
 

3421
01:13:20,480 --> 01:13:23,520
 top level design

3422
01:13:24,070 --> 01:13:24,070
 

3423
01:13:24,080 --> 01:13:32,640
 there's only two people that i know of

3424
01:13:27,270 --> 01:13:32,640
 

3425
01:13:27,280 --> 01:13:34,960
 one person who i know directly and

3426
01:13:32,630 --> 01:13:34,960
 

3427
01:13:32,640 --> 01:13:37,120
 one person just by reputation and by

3428
01:13:34,950 --> 01:13:37,120
 

3429
01:13:34,960 --> 01:13:39,760
 reading their work

3430
01:13:37,110 --> 01:13:39,760
 

3431
01:13:37,120 --> 01:13:40,560
 who i think can look at a large complex

3432
01:13:39,750 --> 01:13:40,560
 

3433
01:13:39,760 --> 01:13:43,600
 system

3434
01:13:40,550 --> 01:13:43,600
 

3435
01:13:40,560 --> 01:13:47,679
 from the top and come up with

3436
01:13:43,590 --> 01:13:47,679
 

3437
01:13:43,600 --> 01:13:50,480
 a a well-constructed detailed design

3438
01:13:47,669 --> 01:13:50,480
 

3439
01:13:47,679 --> 01:13:50,480
 top-down

3440
01:13:50,709 --> 01:13:50,709
 

3441
01:13:50,719 --> 01:13:54,400
 those two people the first is mark

3442
01:13:52,950 --> 01:13:54,400
 

3443
01:13:52,960 --> 01:13:57,280
 hamburg who i've worked

3444
01:13:54,390 --> 01:13:57,280
 

3445
01:13:54,400 --> 01:14:00,000
 directly with he was the architect on

3446
01:13:57,270 --> 01:14:00,000
 

3447
01:13:57,280 --> 01:14:04,320
 photoshop in the early days of photoshop

3448
01:13:59,990 --> 01:14:04,320
 

3449
01:14:00,000 --> 01:14:04,320
 and he had this amazing ability to

3450
01:14:05,590 --> 01:14:05,590
 

3451
01:14:05,600 --> 01:14:09,280
 write features top down filling in

3452
01:14:07,830 --> 01:14:09,280
 

3453
01:14:07,840 --> 01:14:11,679
 blanks for what had to go

3454
01:14:09,270 --> 01:14:11,679
 

3455
01:14:09,280 --> 01:14:13,040
 underneath and getting the underpinnings

3456
01:14:11,669 --> 01:14:13,040
 

3457
01:14:11,679 --> 01:14:14,640
 correct

3458
01:14:13,030 --> 01:14:14,640
 

3459
01:14:13,040 --> 01:14:16,640
 my first experience with that was when i

3460
01:14:14,630 --> 01:14:16,640
 

3461
01:14:14,640 --> 01:14:19,120
 first joined adobe

3462
01:14:16,630 --> 01:14:19,120
 

3463
01:14:16,640 --> 01:14:19,120
 he had

3464
01:14:20,870 --> 01:14:20,870
 

3465
01:14:20,880 --> 01:14:23,920
 written the tiling system and it needed

3466
01:14:23,350 --> 01:14:23,920
 

3467
01:14:23,360 --> 01:14:28,080
 to plug

3468
01:14:23,910 --> 01:14:28,080
 

3469
01:14:23,920 --> 01:14:28,719
 in to a software vm system to feed the

3470
01:14:28,070 --> 01:14:28,719
 

3471
01:14:28,080 --> 01:14:32,560
 tiles

3472
01:14:28,709 --> 01:14:32,560
 

3473
01:14:28,719 --> 01:14:34,320
 asynchronously and it was

3474
01:14:32,550 --> 01:14:34,320
 

3475
01:14:32,560 --> 01:14:35,920
 you know initially it was just just

3476
01:14:34,310 --> 01:14:35,920
 

3477
01:14:34,320 --> 01:14:37,679
 accessing uh

3478
01:14:35,910 --> 01:14:37,679
 

3479
01:14:35,920 --> 01:14:40,560
 uh things synchronously but the plan was

3480
01:14:37,669 --> 01:14:40,560
 

3481
01:14:37,679 --> 01:14:43,679
 that it would be asynchronously

3482
01:14:40,550 --> 01:14:43,679
 

3483
01:14:40,560 --> 01:14:46,880
 and in his code from the top down he had

3484
01:14:43,669 --> 01:14:46,880
 

3485
01:14:43,679 --> 01:14:49,040
 every hook for doing it asynchronously

3486
01:14:46,870 --> 01:14:49,040
 

3487
01:14:46,880 --> 01:14:50,719
 correct and in the right place so all i

3488
01:14:49,030 --> 01:14:50,719
 

3489
01:14:49,040 --> 01:14:53,440
 had to do was write the underpinnings

3490
01:14:50,709 --> 01:14:53,440
 

3491
01:14:50,719 --> 01:14:55,360
 and the top worked so that was a pretty

3492
01:14:53,430 --> 01:14:55,360
 

3493
01:14:53,440 --> 01:14:56,880
 amazing experience

3494
01:14:55,350 --> 01:14:56,880
 

3495
01:14:55,360 --> 01:14:58,480
 the other person who i would say has

3496
01:14:56,870 --> 01:14:58,480
 

3497
01:14:56,880 --> 01:15:01,280
 this attribute

3498
01:14:58,470 --> 01:15:01,280
 

3499
01:14:58,480 --> 01:15:02,320
 is ken thompson and that's just from

3500
01:15:01,270 --> 01:15:02,320
 

3501
01:15:01,280 --> 01:15:05,760
 reading his work

3502
01:15:02,310 --> 01:15:05,760
 

3503
01:15:02,320 --> 01:15:09,120
 on on writing early chess programs

3504
01:15:05,750 --> 01:15:09,120
 

3505
01:15:05,760 --> 01:15:12,239
 and system five unix

3506
01:15:09,110 --> 01:15:12,239
 

3507
01:15:09,120 --> 01:15:14,960
 um and the design of

3508
01:15:12,229 --> 01:15:14,960
 

3509
01:15:12,239 --> 01:15:16,719
 of utf-8 you know i don't know for a

3510
01:15:14,950 --> 01:15:16,719
 

3511
01:15:14,960 --> 01:15:20,560
 fact but i suspect that he

3512
01:15:16,709 --> 01:15:20,560
 

3513
01:15:16,719 --> 01:15:22,080
 has this quality uh you know those

3514
01:15:20,550 --> 01:15:22,080
 

3515
01:15:20,560 --> 01:15:23,920
 are two people that i would consider

3516
01:15:22,070 --> 01:15:23,920
 

3517
01:15:22,080 --> 01:15:24,960
 kind of grand master league and i i

3518
01:15:23,910 --> 01:15:24,960
 

3519
01:15:23,920 --> 01:15:28,000
 don't put myself in

3520
01:15:24,950 --> 01:15:28,000
 

3521
01:15:24,960 --> 01:15:31,040
 in either of those leagues you know as a

3522
01:15:27,990 --> 01:15:31,040
 

3523
01:15:28,000 --> 01:15:33,199
 as a chess player and a coder um

3524
01:15:31,030 --> 01:15:33,199
 

3525
01:15:31,040 --> 01:15:34,960
 i still have to fumble around a lot with

3526
01:15:33,189 --> 01:15:34,960
 

3527
01:15:33,199 --> 01:15:36,880
 the pieces and try moves and look at the

3528
01:15:34,950 --> 01:15:36,880
 

3529
01:15:34,960 --> 01:15:38,960
 board and then retract the move and

3530
01:15:36,870 --> 01:15:38,960
 

3531
01:15:36,880 --> 01:15:41,360
 and try again to get things right and i

3532
01:15:38,950 --> 01:15:41,360
 

3533
01:15:38,960 --> 01:15:44,000
 think that's where most people are

3534
01:15:41,350 --> 01:15:44,000
 

3535
01:15:41,360 --> 01:15:45,280
 but you know understanding that your

3536
01:15:43,990 --> 01:15:45,280
 

3537
01:15:44,000 --> 01:15:49,360
 first move isn't the best

3538
01:15:45,270 --> 01:15:49,360
 

3539
01:15:45,280 --> 01:15:49,360
 move i think is is half the battle

3540
01:15:51,189 --> 01:15:51,189
 

3541
01:15:51,199 --> 01:15:55,520
 uh let's see what else do i have here

3542
01:15:53,830 --> 01:15:55,520
 

3543
01:15:53,840 --> 01:15:59,120
 for questions

3544
01:15:55,510 --> 01:15:59,120
 

3545
01:15:55,520 --> 01:16:00,320
 um you've said before that algorithms

3546
01:15:59,110 --> 01:16:00,320
 

3547
01:15:59,120 --> 01:16:01,760
 should usually not be written by

3548
01:16:00,310 --> 01:16:01,760
 

3549
01:16:00,320 --> 01:16:03,760
 yourself but used from libraries are

3550
01:16:01,750 --> 01:16:03,760
 

3551
01:16:01,760 --> 01:16:04,400
 taken from standard text or if strictly

3552
01:16:03,750 --> 01:16:04,400
 

3553
01:16:03,760 --> 01:16:06,159
 necessary

3554
01:16:04,390 --> 01:16:06,159
 

3555
01:16:04,400 --> 01:16:08,000
 invented or shared atomically what

3556
01:16:06,149 --> 01:16:08,000
 

3557
01:16:06,159 --> 01:16:09,840
 advice would you give for finding

3558
01:16:07,990 --> 01:16:09,840
 

3559
01:16:08,000 --> 01:16:13,040
 an implementation of an algorithm when

3560
01:16:09,830 --> 01:16:13,040
 

3561
01:16:09,840 --> 01:16:18,080
 you don't know a standard name for it

3562
01:16:13,030 --> 01:16:18,080
 

3563
01:16:13,040 --> 01:16:18,080
 that's always hard i mean read lots of

3564
01:16:18,390 --> 01:16:18,390
 

3565
01:16:18,400 --> 01:16:21,600
 lots of papers and for example the

3566
01:16:20,149 --> 01:16:21,600
 

3567
01:16:20,159 --> 01:16:23,679
 russian codecheck algorithm yeah

3568
01:16:21,590 --> 01:16:23,679
 

3569
01:16:21,600 --> 01:16:24,320
 probably already does exist and i'm sure

3570
01:16:23,669 --> 01:16:24,320
 

3571
01:16:23,679 --> 01:16:28,000
 it's probably

3572
01:16:24,310 --> 01:16:28,000
 

3573
01:16:24,320 --> 01:16:29,760
 in the wild i don't have a solid

3574
01:16:27,990 --> 01:16:29,760
 

3575
01:16:28,000 --> 01:16:32,880
 implementation in a library as a

3576
01:16:29,750 --> 01:16:32,880
 

3577
01:16:29,760 --> 01:16:35,920
 is a follow-up question um

3578
01:16:32,870 --> 01:16:35,920
 

3579
01:16:32,880 --> 01:16:39,520
 but you know i'll look at adding it to

3580
01:16:35,910 --> 01:16:39,520
 

3581
01:16:35,920 --> 01:16:40,960
 the st lab libraries um

3582
01:16:39,510 --> 01:16:40,960
 

3583
01:16:39,520 --> 01:16:42,159
 it can be a challenge for finding names

3584
01:16:40,950 --> 01:16:42,159
 

3585
01:16:40,960 --> 01:16:44,320
 for things and it's especially

3586
01:16:42,149 --> 01:16:44,320
 

3587
01:16:42,159 --> 01:16:46,159
 challenging because the industry isn't

3588
01:16:44,310 --> 01:16:46,159
 

3589
01:16:44,320 --> 01:16:48,320
 good about naming things

3590
01:16:46,149 --> 01:16:48,320
 

3591
01:16:46,159 --> 01:16:50,000
 and so the same algorithm in one

3592
01:16:48,310 --> 01:16:50,000
 

3593
01:16:48,320 --> 01:16:50,560
 language standard library or another

3594
01:16:49,990 --> 01:16:50,560
 

3595
01:16:50,000 --> 01:16:52,159
 language

3596
01:16:50,550 --> 01:16:52,159
 

3597
01:16:50,560 --> 01:16:55,040
 standard library will have a different

3598
01:16:52,149 --> 01:16:55,040
 

3599
01:16:52,159 --> 01:16:57,840
 name and so really what you have to do

3600
01:16:55,030 --> 01:16:57,840
 

3601
01:16:55,040 --> 01:16:59,120
 is go and you know read through the

3602
01:16:57,830 --> 01:16:59,120
 

3603
01:16:57,840 --> 01:17:01,920
 algorithms that you have at your

3604
01:16:59,110 --> 01:17:01,920
 

3605
01:16:59,120 --> 01:17:05,120
 disposal and understand them

3606
01:17:01,910 --> 01:17:05,120
 

3607
01:17:01,920 --> 01:17:08,880
 i still think that uh

3608
01:17:05,110 --> 01:17:08,880
 

3609
01:17:05,120 --> 01:17:11,040
 knuth's book should be

3610
01:17:08,870 --> 01:17:11,040
 

3611
01:17:08,880 --> 01:17:12,880
 you know on everybody's shelf as kind of

3612
01:17:11,030 --> 01:17:12,880
 

3613
01:17:11,040 --> 01:17:13,520
 a reference for finding things and

3614
01:17:12,870 --> 01:17:13,520
 

3615
01:17:12,880 --> 01:17:15,199
 they're well

3616
01:17:13,510 --> 01:17:15,199
 

3617
01:17:13,520 --> 01:17:16,640
 organized you know you have an entire

3618
01:17:15,189 --> 01:17:16,640
 

3619
01:17:15,199 --> 01:17:17,920
 volume on sorting and searching

3620
01:17:16,630 --> 01:17:17,920
 

3621
01:17:16,640 --> 01:17:20,080
 algorithms

3622
01:17:17,910 --> 01:17:20,080
 

3623
01:17:17,920 --> 01:17:21,840
 and and so that's always a good place to

3624
01:17:20,070 --> 01:17:21,840
 

3625
01:17:20,080 --> 01:17:23,840
 look to see if it's a known algorithm

3626
01:17:21,830 --> 01:17:23,840
 

3627
01:17:21,840 --> 01:17:25,760
 and usually if you can at least find an

3628
01:17:23,830 --> 01:17:25,760
 

3629
01:17:23,840 --> 01:17:27,120
 instance of the algorithm in the wild

3630
01:17:25,750 --> 01:17:27,120
 

3631
01:17:25,760 --> 01:17:28,640
 somewhere

3632
01:17:27,110 --> 01:17:28,640
 

3633
01:17:27,120 --> 01:17:30,320
 then that will give you a name and from

3634
01:17:28,630 --> 01:17:30,320
 

3635
01:17:28,640 --> 01:17:30,800
 that you can find other names and then

3636
01:17:30,310 --> 01:17:30,800
 

3637
01:17:30,320 --> 01:17:35,120
 you can

3638
01:17:30,790 --> 01:17:35,120
 

3639
01:17:30,800 --> 01:17:37,760
 find an implementation that you can use

3640
01:17:35,110 --> 01:17:37,760
 

3641
01:17:35,120 --> 01:17:39,199
 but you know get get books canoes is a

3642
01:17:37,750 --> 01:17:39,199
 

3643
01:17:37,760 --> 01:17:44,159
 good starting

3644
01:17:39,189 --> 01:17:44,159
 

3645
01:17:39,199 --> 01:17:45,440
 place uh i'm very enamored with a bob

3646
01:17:44,149 --> 01:17:45,440
 

3647
01:17:44,159 --> 01:17:48,480
 tarjan who's

3648
01:17:45,430 --> 01:17:48,480
 

3649
01:17:45,440 --> 01:17:51,120
 a trained award winner he has a

3650
01:17:48,470 --> 01:17:51,120
 

3651
01:17:48,480 --> 01:17:54,080
 very small book on network data

3652
01:17:51,110 --> 01:17:54,080
 

3653
01:17:51,120 --> 01:17:56,640
 structures and algorithms

3654
01:17:54,070 --> 01:17:56,640
 

3655
01:17:54,080 --> 01:17:58,320
 which just contains some absolutely

3656
01:17:56,630 --> 01:17:58,320
 

3657
01:17:56,640 --> 01:17:58,960
 beautiful data structures and algorithms

3658
01:17:58,310 --> 01:17:58,960
 

3659
01:17:58,320 --> 01:18:02,640
 it's like a

3660
01:17:58,950 --> 01:18:02,640
 

3661
01:17:58,960 --> 01:18:05,120
 150 page book or something like that so

3662
01:18:02,630 --> 01:18:05,120
 

3663
01:18:02,640 --> 01:18:05,920
 just search for bob tarjan and i'm sure

3664
01:18:05,110 --> 01:18:05,920
 

3665
01:18:05,120 --> 01:18:07,280
 you'll find it i

3666
01:18:05,910 --> 01:18:07,280
 

3667
01:18:05,920 --> 01:18:08,719
 forget the name of the book right now

3668
01:18:07,270 --> 01:18:08,719
 

3669
01:18:07,280 --> 01:18:10,840
 and i'm not in my office so i don't have

3670
01:18:08,709 --> 01:18:10,840
 

3671
01:18:08,719 --> 01:18:15,600
 it on my shelf here

3672
01:18:10,830 --> 01:18:15,600
 

3673
01:18:10,840 --> 01:18:19,440
 um so yeah it's our problem

3674
01:18:15,590 --> 01:18:19,440
 

3675
01:18:15,600 --> 01:18:19,440
 uh wikipedia can be pretty helpful too

3676
01:18:20,229 --> 01:18:20,229
 

3677
01:18:20,239 --> 01:18:23,280
 uh any algorithms that i'd like to be

3678
01:18:21,990 --> 01:18:23,280
 

3679
01:18:22,000 --> 01:18:26,400
 added to the c

3680
01:18:23,270 --> 01:18:26,400
 

3681
01:18:23,280 --> 01:18:30,000
 plus standard library lots

3682
01:18:26,390 --> 01:18:30,000
 

3683
01:18:26,400 --> 01:18:34,000
 lots and lots and lots um first i think

3684
01:18:29,990 --> 01:18:34,000
 

3685
01:18:30,000 --> 01:18:35,840
 the the the algorithms that you do

3686
01:18:33,990 --> 01:18:35,840
 

3687
01:18:34,000 --> 01:18:38,320
 use every day kind of the basic

3688
01:18:35,830 --> 01:18:38,320
 

3689
01:18:35,840 --> 01:18:41,360
 algorithms various forms of for each

3690
01:18:38,310 --> 01:18:41,360
 

3691
01:18:38,320 --> 01:18:42,080
 find transform there's there's you know

3692
01:18:41,350 --> 01:18:42,080
 

3693
01:18:41,360 --> 01:18:44,800
 a

3694
01:18:42,070 --> 01:18:44,800
 

3695
01:18:42,080 --> 01:18:46,560
 couple dozen variants of both of those

3696
01:18:44,790 --> 01:18:46,560
 

3697
01:18:44,800 --> 01:18:47,760
 algorithms in slightly different format

3698
01:18:46,550 --> 01:18:47,760
 

3699
01:18:46,560 --> 01:18:51,760
 and i would love

3700
01:18:47,750 --> 01:18:51,760
 

3701
01:18:47,760 --> 01:18:53,679
 to just have to have you know files

3702
01:18:51,750 --> 01:18:53,679
 

3703
01:18:51,760 --> 01:18:54,000
 that's like here's all the kind of basic

3704
01:18:53,669 --> 01:18:54,000
 

3705
01:18:53,679 --> 01:18:56,560
 find

3706
01:18:53,990 --> 01:18:56,560
 

3707
01:18:54,000 --> 01:18:58,159
 algorithms and and all the ways basic

3708
01:18:56,550 --> 01:18:58,159
 

3709
01:18:56,560 --> 01:19:00,239
 ways that you can describe find

3710
01:18:58,149 --> 01:19:00,239
 

3711
01:18:58,159 --> 01:19:02,000
 uh just because those are so common and

3712
01:19:00,229 --> 01:19:02,000
 

3713
01:19:00,239 --> 01:19:03,360
 and you know a lot of times you go to

3714
01:19:01,990 --> 01:19:03,360
 

3715
01:19:02,000 --> 01:19:05,760
 just say well i just want to find this

3716
01:19:03,350 --> 01:19:05,760
 

3717
01:19:03,360 --> 01:19:06,719
 thing but std find isn't quite the right

3718
01:19:05,750 --> 01:19:06,719
 

3719
01:19:05,760 --> 01:19:08,000
 fit

3720
01:19:06,709 --> 01:19:08,000
 

3721
01:19:06,719 --> 01:19:09,920
 so we should kind of fill in all of

3722
01:19:07,990 --> 01:19:09,920
 

3723
01:19:08,000 --> 01:19:12,000
 those gaps

3724
01:19:09,910 --> 01:19:12,000
 

3725
01:19:09,920 --> 01:19:13,520
 um but yeah there's all kinds of you

3726
01:19:11,990 --> 01:19:13,520
 

3727
01:19:12,000 --> 01:19:15,280
 know numeric algorithms we don't have

3728
01:19:13,510 --> 01:19:15,280
 

3729
01:19:13,520 --> 01:19:16,239
 any graphic algorithms and graphic

3730
01:19:15,270 --> 01:19:16,239
 

3731
01:19:15,280 --> 01:19:18,640
 algorithms

3732
01:19:16,229 --> 01:19:18,640
 

3733
01:19:16,239 --> 01:19:20,960
 are applicable even you know for a lot

3734
01:19:18,630 --> 01:19:20,960
 

3735
01:19:18,640 --> 01:19:24,080
 of problems outside of graphics

3736
01:19:20,950 --> 01:19:24,080
 

3737
01:19:20,960 --> 01:19:26,080
 uh you know things like uh bresenhamless

3738
01:19:24,070 --> 01:19:26,080
 

3739
01:19:24,080 --> 01:19:29,600
 line algorithm is really uh

3740
01:19:26,070 --> 01:19:29,600
 

3741
01:19:26,080 --> 01:19:32,960
 a very fast way to to distribute

3742
01:19:29,590 --> 01:19:32,960
 

3743
01:19:29,600 --> 01:19:34,000
 uh a set of elements across the line

3744
01:19:32,950 --> 01:19:34,000
 

3745
01:19:32,960 --> 01:19:37,840
 with as close to

3746
01:19:33,990 --> 01:19:37,840
 

3747
01:19:34,000 --> 01:19:39,280
 even spacing as you can get for for a an

3748
01:19:37,830 --> 01:19:39,280
 

3749
01:19:37,840 --> 01:19:42,320
 integral unit

3750
01:19:39,270 --> 01:19:42,320
 

3751
01:19:39,280 --> 01:19:45,360
 um so that has lots of applications

3752
01:19:42,310 --> 01:19:45,360
 

3753
01:19:42,320 --> 01:19:46,960
 outside some of the algorithms that are

3754
01:19:45,350 --> 01:19:46,960
 

3755
01:19:45,360 --> 01:19:49,040
 in the standard library like we have

3756
01:19:46,950 --> 01:19:49,040
 

3757
01:19:46,960 --> 01:19:50,239
 power but we don't have a generic power

3758
01:19:49,030 --> 01:19:50,239
 

3759
01:19:49,040 --> 01:19:52,480
 so

3760
01:19:50,229 --> 01:19:52,480
 

3761
01:19:50,239 --> 01:19:53,360
 like you know i can't take the power of

3762
01:19:52,470 --> 01:19:53,360
 

3763
01:19:52,480 --> 01:19:55,199
 a matrix

3764
01:19:53,350 --> 01:19:55,199
 

3765
01:19:53,360 --> 01:19:56,960
 so if you wanted to calculate fibonacci

3766
01:19:55,189 --> 01:19:56,960
 

3767
01:19:55,199 --> 01:19:59,040
 numbers very quickly

3768
01:19:56,950 --> 01:19:59,040
 

3769
01:19:56,960 --> 01:20:00,159
 it's raising a fibonacci matrix to a

3770
01:19:59,030 --> 01:20:00,159
 

3771
01:19:59,040 --> 01:20:01,600
 given power

3772
01:20:00,149 --> 01:20:01,600
 

3773
01:20:00,159 --> 01:20:03,199
 and we don't have a generic power

3774
01:20:01,590 --> 01:20:03,199
 

3775
01:20:01,600 --> 01:20:05,360
 algorithm we don't have a generic

3776
01:20:03,189 --> 01:20:05,360
 

3777
01:20:03,199 --> 01:20:08,000
 uh gcd algorithm although we have a

3778
01:20:05,350 --> 01:20:08,000
 

3779
01:20:05,360 --> 01:20:08,000
 concrete one

3780
01:20:08,149 --> 01:20:08,149
 

3781
01:20:08,159 --> 01:20:12,239
 so yes many many many algorithms that

3782
01:20:10,550 --> 01:20:12,239
 

3783
01:20:10,560 --> 01:20:15,280
 should be in the standard library

3784
01:20:12,229 --> 01:20:15,280
 

3785
01:20:12,239 --> 01:20:15,840
 and there's there's lots of tension you

3786
01:20:15,270 --> 01:20:15,840
 

3787
01:20:15,280 --> 01:20:17,120
 know the

3788
01:20:15,830 --> 01:20:17,120
 

3789
01:20:15,840 --> 01:20:19,040
 the more stuff you put in the standard

3790
01:20:17,110 --> 01:20:19,040
 

3791
01:20:17,120 --> 01:20:21,280
 library the more challenge it is for all

3792
01:20:19,030 --> 01:20:21,280
 

3793
01:20:19,040 --> 01:20:23,840
 the vendors to maintain

3794
01:20:21,270 --> 01:20:23,840
 

3795
01:20:21,280 --> 01:20:24,880
 but i would like there to be you know

3796
01:20:23,830 --> 01:20:24,880
 

3797
01:20:23,840 --> 01:20:26,560
 just a massive

3798
01:20:24,870 --> 01:20:26,560
 

3799
01:20:24,880 --> 01:20:32,320
 collection of thousands and thousands

3800
01:20:26,550 --> 01:20:32,320
 

3801
01:20:26,560 --> 01:20:35,120
 and thousands of algorithms

3802
01:20:32,310 --> 01:20:35,120
 

3803
01:20:32,320 --> 01:20:36,800
 uh has the ipad os photoshop stuff been

3804
01:20:35,110 --> 01:20:36,800
 

3805
01:20:35,120 --> 01:20:39,120
 backported to desktop

3806
01:20:36,790 --> 01:20:39,120
 

3807
01:20:36,800 --> 01:20:40,960
 uh would you think that would be

3808
01:20:39,110 --> 01:20:40,960
 

3809
01:20:39,120 --> 01:20:44,400
 valuable um

3810
01:20:40,950 --> 01:20:44,400
 

3811
01:20:40,960 --> 01:20:46,239
 there is a plan to do that aspects of

3812
01:20:44,390 --> 01:20:46,239
 

3813
01:20:44,400 --> 01:20:48,239
 what we've done

3814
01:20:46,229 --> 01:20:48,239
 

3815
01:20:46,239 --> 01:20:49,280
 are already in the desktop it is a

3816
01:20:48,229 --> 01:20:49,280
 

3817
01:20:48,239 --> 01:20:51,760
 shared code base

3818
01:20:49,270 --> 01:20:51,760
 

3819
01:20:49,280 --> 01:20:53,440
 so both products are built out of the

3820
01:20:51,750 --> 01:20:53,440
 

3821
01:20:51,760 --> 01:20:53,920
 same code base we're not living on a

3822
01:20:53,430 --> 01:20:53,920
 

3823
01:20:53,440 --> 01:20:56,560
 fork

3824
01:20:53,910 --> 01:20:56,560
 

3825
01:20:53,920 --> 01:20:56,560
 or anything

3826
01:20:56,950 --> 01:20:56,950
 

3827
01:20:56,960 --> 01:21:02,239
 i don't know that we'll we'll go

3828
01:21:00,470 --> 01:21:02,239
 

3829
01:21:00,480 --> 01:21:04,719
 all the way there in fact i think where

3830
01:21:02,229 --> 01:21:04,719
 

3831
01:21:02,239 --> 01:21:08,000
 we're going to end up is kind of a

3832
01:21:04,709 --> 01:21:08,000
 

3833
01:21:04,719 --> 01:21:10,320
 hybrid blend between

3834
01:21:07,990 --> 01:21:10,320
 

3835
01:21:08,000 --> 01:21:11,600
 some of the two architectures there are

3836
01:21:10,310 --> 01:21:11,600
 

3837
01:21:10,320 --> 01:21:13,440
 some advantages

3838
01:21:11,590 --> 01:21:13,440
 

3839
01:21:11,600 --> 01:21:14,800
 to say how the display system works on

3840
01:21:13,430 --> 01:21:14,800
 

3841
01:21:13,440 --> 01:21:17,679
 desktop

3842
01:21:14,790 --> 01:21:17,679
 

3843
01:21:14,800 --> 01:21:20,320
 that we can't do on mobile so if you

3844
01:21:17,669 --> 01:21:20,320
 

3845
01:21:17,679 --> 01:21:20,320
 look on

3846
01:21:20,470 --> 01:21:20,470
 

3847
01:21:20,480 --> 01:21:25,040
 desktop if you see transparency areas in

3848
01:21:22,629 --> 01:21:25,040
 

3849
01:21:22,639 --> 01:21:26,960
 photoshop they appear as a checkerboard

3850
01:21:25,030 --> 01:21:26,960
 

3851
01:21:25,040 --> 01:21:29,040
 and that checkerboard is fixed sized

3852
01:21:26,950 --> 01:21:29,040
 

3853
01:21:26,960 --> 01:21:31,040
 regardless of your zoom level

3854
01:21:29,030 --> 01:21:31,040
 

3855
01:21:29,040 --> 01:21:32,480
 but if you're on ipad the checkerboard

3856
01:21:31,030 --> 01:21:32,480
 

3857
01:21:31,040 --> 01:21:34,560
 is actually

3858
01:21:32,470 --> 01:21:34,560
 

3859
01:21:32,480 --> 01:21:35,840
 burned into the pixels by the way

3860
01:21:34,550 --> 01:21:35,840
 

3861
01:21:34,560 --> 01:21:37,360
 checkerboard is also drawn with the

3862
01:21:35,830 --> 01:21:37,360
 

3863
01:21:35,840 --> 01:21:41,199
 brezza hemline algorithm

3864
01:21:37,350 --> 01:21:41,199
 

3865
01:21:37,360 --> 01:21:44,560
 since i mentioned that a moment ago um

3866
01:21:41,189 --> 01:21:44,560
 

3867
01:21:41,199 --> 01:21:47,600
 uh uh uh

3868
01:21:44,550 --> 01:21:47,600
 

3869
01:21:44,560 --> 01:21:49,920
 and the reason for that is the way we do

3870
01:21:47,590 --> 01:21:49,920
 

3871
01:21:47,600 --> 01:21:52,480
 the display system on mobile

3872
01:21:49,910 --> 01:21:52,480
 

3873
01:21:49,920 --> 01:21:54,239
 uh we can't kind of do late compositing

3874
01:21:52,470 --> 01:21:54,239
 

3875
01:21:52,480 --> 01:21:55,440
 and that has some advantages from for

3876
01:21:54,229 --> 01:21:55,440
 

3877
01:21:54,239 --> 01:21:56,960
 mobile but it also has some

3878
01:21:55,430 --> 01:21:56,960
 

3879
01:21:55,440 --> 01:21:59,280
 disadvantages like not being

3880
01:21:56,950 --> 01:21:59,280
 

3881
01:21:56,960 --> 01:22:00,400
 able to render transparency so we're

3882
01:21:59,270 --> 01:22:00,400
 

3883
01:21:59,280 --> 01:22:01,600
 kind of looking at doing a hybrid

3884
01:22:00,390 --> 01:22:01,600
 

3885
01:22:00,400 --> 01:22:04,480
 approach between what the desktop does

3886
01:22:01,590 --> 01:22:04,480
 

3887
01:22:01,600 --> 01:22:04,480
 and what mobile does

3888
01:22:06,070 --> 01:22:06,070
 

3889
01:22:06,080 --> 01:22:11,120
 ah let's see here i think i already

3890
01:22:08,229 --> 01:22:11,120
 

3891
01:22:08,239 --> 01:22:13,520
 mentioned i look at everything from a

3892
01:22:11,110 --> 01:22:13,520
 

3893
01:22:11,120 --> 01:22:14,719
 from an alcatic architecture perspective

3894
01:22:13,510 --> 01:22:14,719
 

3895
01:22:13,520 --> 01:22:17,760
 um yeah i mean

3896
01:22:14,709 --> 01:22:17,760
 

3897
01:22:14,719 --> 01:22:20,639
 if you look i will mention when i write

3898
01:22:17,750 --> 01:22:20,639
 

3899
01:22:17,760 --> 01:22:23,440
 code i tend to write all of my code

3900
01:22:20,629 --> 01:22:23,440
 

3901
01:22:20,639 --> 01:22:24,239
 in a little console app i have a a

3902
01:22:23,430 --> 01:22:24,239
 

3903
01:22:23,440 --> 01:22:27,920
 scratch

3904
01:22:24,229 --> 01:22:27,920
 

3905
01:22:24,239 --> 01:22:29,199
 app um uh where i just keep a pending

3906
01:22:27,910 --> 01:22:29,199
 

3907
01:22:27,920 --> 01:22:31,120
 code at the top and

3908
01:22:29,189 --> 01:22:31,120
 

3909
01:22:29,199 --> 01:22:32,560
 pound of zeroing all the code out from

3910
01:22:31,110 --> 01:22:32,560
 

3911
01:22:31,120 --> 01:22:33,920
 underneath it as my reference and then

3912
01:22:32,550 --> 01:22:33,920
 

3913
01:22:32,560 --> 01:22:35,600
 when i get the code working in my

3914
01:22:33,910 --> 01:22:35,600
 

3915
01:22:33,920 --> 01:22:37,040
 scratch app then i copy and paste it

3916
01:22:35,590 --> 01:22:37,040
 

3917
01:22:35,600 --> 01:22:40,080
 into a file

3918
01:22:37,030 --> 01:22:40,080
 

3919
01:22:37,040 --> 01:22:42,080
 and that becomes the component that i

3920
01:22:40,070 --> 01:22:42,080
 

3921
01:22:40,080 --> 01:22:43,920
 integrate into the application

3922
01:22:42,070 --> 01:22:43,920
 

3923
01:22:42,080 --> 01:22:45,600
 and that means that i'm always looking

3924
01:22:43,910 --> 01:22:45,600
 

3925
01:22:43,920 --> 01:22:47,120
 when i'm writing a component

3926
01:22:45,590 --> 01:22:47,120
 

3927
01:22:45,600 --> 01:22:49,280
 to try to write it with zero

3928
01:22:47,110 --> 01:22:49,280
 

3929
01:22:47,120 --> 01:22:52,480
 dependencies uh

3930
01:22:49,270 --> 01:22:52,480
 

3931
01:22:49,280 --> 01:22:54,400
 you know uh i don't

3932
01:22:52,470 --> 01:22:54,400
 

3933
01:22:52,480 --> 01:22:55,520
 pull in the entire application into my

3934
01:22:54,390 --> 01:22:55,520
 

3935
01:22:54,400 --> 01:22:58,000
 little console app

3936
01:22:55,510 --> 01:22:58,000
 

3937
01:22:55,520 --> 01:22:58,960
 uh there are some libraries that i rely

3938
01:22:57,990 --> 01:22:58,960
 

3939
01:22:58,000 --> 01:23:03,199
 on so that i can

3940
01:22:58,950 --> 01:23:03,199
 

3941
01:22:58,960 --> 01:23:05,600
 compose the pieces but i don't want

3942
01:23:03,189 --> 01:23:05,600
 

3943
01:23:03,199 --> 01:23:07,199
 you know it to be to require a

3944
01:23:05,590 --> 01:23:07,199
 

3945
01:23:05,600 --> 01:23:09,360
 composition of everything it should just

3946
01:23:07,189 --> 01:23:09,360
 

3947
01:23:07,199 --> 01:23:11,280
 be the pieces that it's using

3948
01:23:09,350 --> 01:23:11,280
 

3949
01:23:09,360 --> 01:23:15,600
 and so yeah so i very much kind of

3950
01:23:11,270 --> 01:23:15,600
 

3951
01:23:11,280 --> 01:23:15,600
 always look at at how do i decompose a

3952
01:23:18,830 --> 01:23:18,830
 

3953
01:23:18,840 --> 01:23:21,840
 problem

3954
01:23:25,110 --> 01:23:25,110
 

3955
01:23:25,120 --> 01:23:35,840
 let's see somebody's posting links here

3956
01:23:42,790 --> 01:23:42,790
 

3957
01:23:42,800 --> 01:23:47,280
 oh that's everything that uh bob tarjan

3958
01:23:45,189 --> 01:23:47,280
 

3959
01:23:45,199 --> 01:23:50,560
 his papers

3960
01:23:47,270 --> 01:23:50,560
 

3961
01:23:47,280 --> 01:23:50,560
 probably search for him on

3962
01:23:53,030 --> 01:23:53,030
 

3963
01:23:53,040 --> 01:23:55,600
 amazon

3964
01:23:56,709 --> 01:23:56,709
 

3965
01:23:56,719 --> 01:24:03,840
 see if i can find the name of the book

3966
01:23:58,149 --> 01:24:03,840
 

3967
01:23:58,159 --> 01:24:03,840
 real quick

3968
01:24:14,229 --> 01:24:14,229
 

3969
01:24:14,239 --> 01:24:17,840
 and i cannot

3970
01:24:22,229 --> 01:24:22,229
 

3971
01:24:22,239 --> 01:24:26,480
 uh data structures and network

3972
01:24:23,990 --> 01:24:26,480
 

3973
01:24:24,000 --> 01:24:28,560
 algorithms and

3974
01:24:26,470 --> 01:24:28,560
 

3975
01:24:26,480 --> 01:24:30,639
 it's probably out of print now but i

3976
01:24:28,550 --> 01:24:30,639
 

3977
01:24:28,560 --> 01:24:34,080
 will post a

3978
01:24:30,629 --> 01:24:34,080
 

3979
01:24:30,639 --> 01:24:37,040
 link in chat i didn't realize how

3980
01:24:34,070 --> 01:24:37,040
 

3981
01:24:34,080 --> 01:24:39,360
 valuable my copy was

3982
01:24:37,030 --> 01:24:39,360
 

3983
01:24:37,040 --> 01:24:43,040
 if you can find your own copy somewhere

3984
01:24:39,350 --> 01:24:43,040
 

3985
01:24:39,360 --> 01:24:43,040
 maybe it's available online somewhere

3986
01:24:43,110 --> 01:24:43,110
 

3987
01:24:43,120 --> 01:24:45,840
 that's the book

3988
01:24:47,430 --> 01:24:47,430
 

3989
01:24:47,440 --> 01:24:50,800
 that's one problem that i find with uh

3990
01:24:50,390 --> 01:24:50,800
 

3991
01:24:50,400 --> 01:24:52,880
 you know

3992
01:24:50,790 --> 01:24:52,880
 

3993
01:24:50,800 --> 01:24:54,080
 i always think that if a book goes out

3994
01:24:52,870 --> 01:24:54,080
 

3995
01:24:52,880 --> 01:24:56,639
 of publication

3996
01:24:54,070 --> 01:24:56,639
 

3997
01:24:54,080 --> 01:24:58,320
 it should automatically go into the

3998
01:24:56,629 --> 01:24:58,320
 

3999
01:24:56,639 --> 01:25:13,840
 public domain i'm kind of an

4000
01:24:58,310 --> 01:25:13,840
 

4001
01:24:58,320 --> 01:25:13,840
 anti-copyright and patent person

4002
01:25:13,910 --> 01:25:13,910
 

4003
01:25:13,920 --> 01:25:17,440
 oh thank you jim for echoing that

4004
01:25:25,350 --> 01:25:25,350
 

4005
01:25:25,360 --> 01:25:30,960
 oh yeah uh comment on on

4006
01:25:28,550 --> 01:25:30,960
 

4007
01:25:28,560 --> 01:25:33,040
 on adsp the podcast yes i'm very much

4008
01:25:30,950 --> 01:25:33,040
 

4009
01:25:30,960 --> 01:25:35,520
 enjoying that even though it's a little

4010
01:25:33,030 --> 01:25:35,520
 

4011
01:25:33,040 --> 01:25:39,120
 can be a little uh challenging to hear

4012
01:25:35,510 --> 01:25:39,120
 

4013
01:25:35,520 --> 01:25:43,760
 my name so often brought up on a podcast

4014
01:25:39,110 --> 01:25:43,760
 

4015
01:25:39,120 --> 01:25:46,639
 so a story i've told before um

4016
01:25:43,750 --> 01:25:46,639
 

4017
01:25:43,760 --> 01:25:48,000
 uh i listen to uh cppcast and i'll

4018
01:25:46,629 --> 01:25:48,000
 

4019
01:25:46,639 --> 01:25:51,280
 usually listen

4020
01:25:47,990 --> 01:25:51,280
 

4021
01:25:48,000 --> 01:25:55,280
 to it in my car and

4022
01:25:51,270 --> 01:25:55,280
 

4023
01:25:51,280 --> 01:25:58,239
 a while back there was a

4024
01:25:55,270 --> 01:25:58,239
 

4025
01:25:55,280 --> 01:26:00,080
 a uh kate gregory who was the guest on

4026
01:25:58,229 --> 01:26:00,080
 

4027
01:25:58,239 --> 01:26:03,760
 cpp cast

4028
01:26:00,070 --> 01:26:03,760
 

4029
01:26:00,080 --> 01:26:06,159
 and and i got into the

4030
01:26:03,750 --> 01:26:06,159
 

4031
01:26:03,760 --> 01:26:08,080
 car with my wife and i turned on just

4032
01:26:06,149 --> 01:26:08,080
 

4033
01:26:06,159 --> 01:26:10,000
 started the car and started tpp cast

4034
01:26:08,070 --> 01:26:10,000
 

4035
01:26:08,080 --> 01:26:13,120
 where i had left off

4036
01:26:09,990 --> 01:26:13,120
 

4037
01:26:10,000 --> 01:26:16,639
 and uh kate and jason

4038
01:26:13,110 --> 01:26:16,639
 

4039
01:26:13,120 --> 01:26:17,440
 were going back and forth and and then

4040
01:26:16,629 --> 01:26:17,440
 

4041
01:26:16,639 --> 01:26:19,199
 kate said

4042
01:26:17,430 --> 01:26:19,199
 

4043
01:26:17,440 --> 01:26:21,040
 said she goes and then i had this sean

4044
01:26:19,189 --> 01:26:21,040
 

4045
01:26:19,199 --> 01:26:22,159
 parent moment and jason goes shawn

4046
01:26:21,030 --> 01:26:22,159
 

4047
01:26:21,040 --> 01:26:25,199
 parent moment and he

4048
01:26:22,149 --> 01:26:25,199
 

4049
01:26:22,159 --> 01:26:26,480
 goes yes this sean parent moment and

4050
01:26:25,189 --> 01:26:26,480
 

4051
01:26:25,199 --> 01:26:27,760
 they never explained what they meant by

4052
01:26:26,470 --> 01:26:27,760
 

4053
01:26:26,480 --> 01:26:29,280
 that and they just went on in the

4054
01:26:27,750 --> 01:26:29,280
 

4055
01:26:27,760 --> 01:26:30,800
 conversation

4056
01:26:29,270 --> 01:26:30,800
 

4057
01:26:29,280 --> 01:26:32,639
 my wife turns to me and she's like were

4058
01:26:30,790 --> 01:26:32,639
 

4059
01:26:30,800 --> 01:26:34,560
 they talking about you and

4060
01:26:32,629 --> 01:26:34,560
 

4061
01:26:32,639 --> 01:26:36,239
 like yes i think they actually were

4062
01:26:34,550 --> 01:26:36,239
 

4063
01:26:34,560 --> 01:26:37,840
 talking about me but i have no idea what

4064
01:26:36,229 --> 01:26:37,840
 

4065
01:26:36,239 --> 01:26:40,080
 they were talking about

4066
01:26:37,830 --> 01:26:40,080
 

4067
01:26:37,840 --> 01:26:43,120
 so so kate did fill me in later about

4068
01:26:40,070 --> 01:26:43,120
 

4069
01:26:40,080 --> 01:26:43,120
 what they were talking about

4070
01:26:44,470 --> 01:26:44,470
 

4071
01:26:44,480 --> 01:26:51,840
 but somewhat humorous to get a mention

4072
01:26:47,669 --> 01:26:51,840
 

4073
01:26:47,679 --> 01:26:51,840
 like that

4074
01:26:55,510 --> 01:26:55,510
 

4075
01:26:55,520 --> 01:27:01,199
 so i think unless uh

4076
01:26:59,270 --> 01:27:01,199
 

4077
01:26:59,280 --> 01:27:02,560
 any comments on how the goal of no

4078
01:27:01,189 --> 01:27:02,560
 

4079
01:27:01,199 --> 01:27:05,679
 contradiction relates to the

4080
01:27:02,550 --> 01:27:05,679
 

4081
01:27:02,560 --> 01:27:09,040
 immutability of data structures

4082
01:27:05,669 --> 01:27:09,040
 

4083
01:27:05,679 --> 01:27:11,760
 yeah so certainly

4084
01:27:09,030 --> 01:27:11,760
 

4085
01:27:09,040 --> 01:27:12,320
 uh you know immutability helps right

4086
01:27:11,750 --> 01:27:12,320
 

4087
01:27:11,760 --> 01:27:15,520
 right the

4088
01:27:12,310 --> 01:27:15,520
 

4089
01:27:12,320 --> 01:27:18,480
 the shared writing of something is

4090
01:27:15,510 --> 01:27:18,480
 

4091
01:27:15,520 --> 01:27:19,840
 um is one way that you can get a

4092
01:27:18,470 --> 01:27:19,840
 

4093
01:27:18,480 --> 01:27:22,960
 contradiction

4094
01:27:19,830 --> 01:27:22,960
 

4095
01:27:19,840 --> 01:27:23,520
 and so removing mutability um you can

4096
01:27:22,950 --> 01:27:23,520
 

4097
01:27:22,960 --> 01:27:25,040
 both

4098
01:27:23,510 --> 01:27:25,040
 

4099
01:27:23,520 --> 01:27:26,880
 you can remove that contradiction you

4100
01:27:25,030 --> 01:27:26,880
 

4101
01:27:25,040 --> 01:27:28,239
 can remove the data race contradiction

4102
01:27:26,870 --> 01:27:28,239
 

4103
01:27:26,880 --> 01:27:29,360
 there's another one which requires you

4104
01:27:28,229 --> 01:27:29,360
 

4105
01:27:28,239 --> 01:27:33,840
 know at least one thing writing while

4106
01:27:29,350 --> 01:27:33,840
 

4107
01:27:29,360 --> 01:27:33,840
 you have multiple readers

4108
01:27:33,990 --> 01:27:33,990
 

4109
01:27:34,000 --> 01:27:40,239
 for you know for any operation

4110
01:27:37,189 --> 01:27:40,239
 

4111
01:27:37,199 --> 01:27:44,639
 you can kind of you can demonstrate

4112
01:27:40,229 --> 01:27:44,639
 

4113
01:27:40,239 --> 01:27:46,080
 that that either performing it in place

4114
01:27:44,629 --> 01:27:46,080
 

4115
01:27:44,639 --> 01:27:48,239
 well for any operation first you can

4116
01:27:46,070 --> 01:27:48,239
 

4117
01:27:46,080 --> 01:27:48,880
 perform it in place or you can perform

4118
01:27:48,229 --> 01:27:48,880
 

4119
01:27:48,239 --> 01:27:52,800
 it

4120
01:27:48,870 --> 01:27:52,800
 

4121
01:27:48,880 --> 01:27:56,719
 uh uh with a copy with with immutability

4122
01:27:52,790 --> 01:27:56,719
 

4123
01:27:52,800 --> 01:27:58,159
 um uh or you can perform it lazily which

4124
01:27:56,709 --> 01:27:58,159
 

4125
01:27:56,719 --> 01:28:00,080
 means you can construction

4126
01:27:58,149 --> 01:28:00,080
 

4127
01:27:58,159 --> 01:28:02,960
 construct a function that would yield

4128
01:28:00,070 --> 01:28:02,960
 

4129
01:28:00,080 --> 01:28:04,800
 the result piecemeal

4130
01:28:02,950 --> 01:28:04,800
 

4131
01:28:02,960 --> 01:28:06,960
 and that's true for any operation the

4132
01:28:04,790 --> 01:28:06,960
 

4133
01:28:04,800 --> 01:28:09,280
 difference there is that each of those

4134
01:28:06,950 --> 01:28:09,280
 

4135
01:28:06,960 --> 01:28:10,800
 will have a varying complexity and it's

4136
01:28:09,270 --> 01:28:10,800
 

4137
01:28:09,280 --> 01:28:12,560
 not always

4138
01:28:10,790 --> 01:28:12,560
 

4139
01:28:10,800 --> 01:28:14,080
 it's not always the mutable structures

4140
01:28:12,550 --> 01:28:14,080
 

4141
01:28:12,560 --> 01:28:17,120
 that have the fastest complexity

4142
01:28:14,070 --> 01:28:17,120
 

4143
01:28:14,080 --> 01:28:20,159
 sometimes they are not the fastest uh

4144
01:28:17,110 --> 01:28:20,159
 

4145
01:28:17,120 --> 01:28:22,239
 so you know in fact for some operations

4146
01:28:20,149 --> 01:28:22,239
 

4147
01:28:20,159 --> 01:28:25,040
 even even in the stl

4148
01:28:22,229 --> 01:28:25,040
 

4149
01:28:22,239 --> 01:28:26,880
 like stable partition it's called a

4150
01:28:25,030 --> 01:28:26,880
 

4151
01:28:25,040 --> 01:28:28,880
 memory dynamic operation which means it

4152
01:28:26,870 --> 01:28:28,880
 

4153
01:28:26,880 --> 01:28:31,360
 tries to see if there's enough

4154
01:28:28,870 --> 01:28:31,360
 

4155
01:28:28,880 --> 01:28:33,280
 uh space to allocate spare memory and if

4156
01:28:31,350 --> 01:28:33,280
 

4157
01:28:31,360 --> 01:28:35,040
 it does it allocates spare space and

4158
01:28:33,270 --> 01:28:35,040
 

4159
01:28:33,280 --> 01:28:36,400
 i think most implementations don't even

4160
01:28:35,030 --> 01:28:36,400
 

4161
01:28:35,040 --> 01:28:37,840
 check to see what

4162
01:28:36,390 --> 01:28:37,840
 

4163
01:28:36,400 --> 01:28:39,360
 a reasonable amount of memory would be

4164
01:28:37,830 --> 01:28:39,360
 

4165
01:28:37,840 --> 01:28:40,719
 so they just always allocate a secondary

4166
01:28:39,350 --> 01:28:40,719
 

4167
01:28:39,360 --> 01:28:42,800
 buffer

4168
01:28:40,709 --> 01:28:42,800
 

4169
01:28:40,719 --> 01:28:44,320
 but you know you can do an in-situ work

4170
01:28:42,790 --> 01:28:44,320
 

4171
01:28:42,800 --> 01:28:45,120
 partition but the fastest way to do an

4172
01:28:44,310 --> 01:28:45,120
 

4173
01:28:44,320 --> 01:28:48,400
 in-situ

4174
01:28:45,110 --> 01:28:48,400
 

4175
01:28:45,120 --> 01:28:52,159
 partition is to uh

4176
01:28:48,390 --> 01:28:52,159
 

4177
01:28:48,400 --> 01:28:54,000
 or stable partition is to to copy

4178
01:28:52,149 --> 01:28:54,000
 

4179
01:28:52,159 --> 01:28:55,840
 you know all the good guys into a buffer

4180
01:28:53,990 --> 01:28:55,840
 

4181
01:28:54,000 --> 01:28:57,440
 and copy all the bad guys into a buffer

4182
01:28:55,830 --> 01:28:57,440
 

4183
01:28:55,840 --> 01:29:01,040
 and then copy them both back

4184
01:28:57,430 --> 01:29:01,040
 

4185
01:28:57,440 --> 01:29:04,239
 in in place and so

4186
01:29:01,030 --> 01:29:04,239
 

4187
01:29:01,040 --> 01:29:06,560
 so that's the the

4188
01:29:04,229 --> 01:29:06,560
 

4189
01:29:04,239 --> 01:29:07,520
 you know the fastest implementation it

4190
01:29:06,550 --> 01:29:07,520
 

4191
01:29:06,560 --> 01:29:10,400
 turns out

4192
01:29:07,510 --> 01:29:10,400
 

4193
01:29:07,520 --> 01:29:11,040
 assuming you have the extra memory you

4194
01:29:10,390 --> 01:29:11,040
 

4195
01:29:10,400 --> 01:29:13,520
 know so

4196
01:29:11,030 --> 01:29:13,520
 

4197
01:29:11,040 --> 01:29:14,560
 so that's a trade-off that as as

4198
01:29:13,510 --> 01:29:14,560
 

4199
01:29:13,520 --> 01:29:16,320
 engineers

4200
01:29:14,550 --> 01:29:16,320
 

4201
01:29:14,560 --> 01:29:17,840
 you know we have to make we have to

4202
01:29:16,310 --> 01:29:17,840
 

4203
01:29:16,320 --> 01:29:21,120
 figure out uh

4204
01:29:17,830 --> 01:29:21,120
 

4205
01:29:17,840 --> 01:29:23,520
 how important performance is to us and

4206
01:29:21,110 --> 01:29:23,520
 

4207
01:29:21,120 --> 01:29:24,639
 and how do we capitalize that and i

4208
01:29:23,510 --> 01:29:24,639
 

4209
01:29:23,520 --> 01:29:27,440
 think

4210
01:29:24,629 --> 01:29:27,440
 

4211
01:29:24,639 --> 01:29:29,920
 you know most engineers who spend a lot

4212
01:29:27,430 --> 01:29:29,920
 

4213
01:29:27,440 --> 01:29:32,639
 of time in imperative languages like c

4214
01:29:29,910 --> 01:29:32,639
 

4215
01:29:29,920 --> 01:29:34,239
 plus you know that are as opposed to non

4216
01:29:32,629 --> 01:29:34,239
 

4217
01:29:32,639 --> 01:29:36,080
 as opposed to functional languages that

4218
01:29:34,229 --> 01:29:36,080
 

4219
01:29:34,239 --> 01:29:37,280
 spend time in non-functional languages i

4220
01:29:36,070 --> 01:29:37,280
 

4221
01:29:36,080 --> 01:29:38,800
 shouldn't have said imperative in

4222
01:29:37,270 --> 01:29:38,800
 

4223
01:29:37,280 --> 01:29:40,400
 non-functional languages as opposed to

4224
01:29:38,790 --> 01:29:40,400
 

4225
01:29:38,800 --> 01:29:43,360
 functional languages

4226
01:29:40,390 --> 01:29:43,360
 

4227
01:29:40,400 --> 01:29:44,880
 always think in terms of mutations first

4228
01:29:43,350 --> 01:29:44,880
 

4229
01:29:43,360 --> 01:29:50,480
 and

4230
01:29:44,870 --> 01:29:50,480
 

4231
01:29:44,880 --> 01:29:50,480
 you should try to try to look at

4232
01:29:50,629 --> 01:29:50,629
 

4233
01:29:50,639 --> 01:29:54,480
 both composition you know a lazy

4234
01:29:52,550 --> 01:29:54,480
 

4235
01:29:52,560 --> 01:29:55,440
 algorithm and look at a functional

4236
01:29:54,470 --> 01:29:55,440
 

4237
01:29:54,480 --> 01:29:58,719
 solution

4238
01:29:55,430 --> 01:29:58,719
 

4239
01:29:55,440 --> 01:30:01,199
 also and and determine what the what the

4240
01:29:58,709 --> 01:30:01,199
 

4241
01:29:58,719 --> 01:30:01,199
 weights are

4242
01:30:02,390 --> 01:30:02,390
 

4243
01:30:02,400 --> 01:30:05,920
 so do you want to make an invalid state

4244
01:30:04,070 --> 01:30:05,920
 

4245
01:30:04,080 --> 01:30:06,480
 impossible to represent and how often is

4246
01:30:05,910 --> 01:30:06,480
 

4247
01:30:05,920 --> 01:30:08,400
 this

4248
01:30:06,470 --> 01:30:08,400
 

4249
01:30:06,480 --> 01:30:10,880
 practical yeah ideally you want to make

4250
01:30:08,390 --> 01:30:10,880
 

4251
01:30:08,400 --> 01:30:14,080
 the invalid states

4252
01:30:10,870 --> 01:30:14,080
 

4253
01:30:10,880 --> 01:30:16,000
 impossible to to represent

4254
01:30:14,070 --> 01:30:16,000
 

4255
01:30:14,080 --> 01:30:17,280
 the problem there is there's a provable

4256
01:30:15,990 --> 01:30:17,280
 

4257
01:30:16,000 --> 01:30:21,840
 trade-off there

4258
01:30:17,270 --> 01:30:21,840
 

4259
01:30:17,280 --> 01:30:21,840
 with performance um

4260
01:30:21,910 --> 01:30:21,910
 

4261
01:30:21,920 --> 01:30:28,239
 in fact the canonical example is copy

4262
01:30:25,030 --> 01:30:28,239
 

4263
01:30:25,040 --> 01:30:32,159
 or is a sort but it's it's

4264
01:30:28,229 --> 01:30:32,159
 

4265
01:30:28,239 --> 01:30:36,239
 true of of of any in-situ

4266
01:30:32,149 --> 01:30:36,239
 

4267
01:30:32,159 --> 01:30:40,639
 um algorithm and in the case of sort

4268
01:30:36,229 --> 01:30:40,639
 

4269
01:30:36,239 --> 01:30:43,679
 uh the fastest way to do sort is to

4270
01:30:40,629 --> 01:30:43,679
 

4271
01:30:40,639 --> 01:30:45,280
 sort in-situ and the fastest way

4272
01:30:43,669 --> 01:30:45,280
 

4273
01:30:43,679 --> 01:30:48,080
 to do it in situ is something that you

4274
01:30:45,270 --> 01:30:48,080
 

4275
01:30:45,280 --> 01:30:50,560
 can't easily do in c plus

4276
01:30:48,070 --> 01:30:50,560
 

4277
01:30:48,080 --> 01:30:53,120
 it would require a destructive move but

4278
01:30:50,550 --> 01:30:53,120
 

4279
01:30:50,560 --> 01:30:54,960
 it's if you think about

4280
01:30:53,110 --> 01:30:54,960
 

4281
01:30:53,120 --> 01:30:57,520
 any permutation at some point within

4282
01:30:54,950 --> 01:30:57,520
 

4283
01:30:54,960 --> 01:30:59,280
 your sequence you have to remove an item

4284
01:30:57,510 --> 01:30:59,280
 

4285
01:30:57,520 --> 01:31:02,400
 if you're doing it in place and then

4286
01:30:59,270 --> 01:31:02,400
 

4287
01:30:59,280 --> 01:31:04,000
 fill in the hole and you keep doing that

4288
01:31:02,390 --> 01:31:04,000
 

4289
01:31:02,400 --> 01:31:05,360
 removing items and filling in the hole

4290
01:31:03,990 --> 01:31:05,360
 

4291
01:31:04,000 --> 01:31:06,800
 well at the point where you remove the

4292
01:31:05,350 --> 01:31:06,800
 

4293
01:31:05,360 --> 01:31:08,719
 item ideally you don't want to

4294
01:31:06,790 --> 01:31:08,719
 

4295
01:31:06,800 --> 01:31:10,320
 write anything back into the hole you

4296
01:31:08,709 --> 01:31:10,320
 

4297
01:31:08,719 --> 01:31:11,760
 just want to leave the hole that would

4298
01:31:10,310 --> 01:31:11,760
 

4299
01:31:10,320 --> 01:31:13,679
 be called a destructive move

4300
01:31:11,750 --> 01:31:13,679
 

4301
01:31:11,760 --> 01:31:17,760
 you move the object to another place and

4302
01:31:13,669 --> 01:31:17,760
 

4303
01:31:13,679 --> 01:31:20,880
 leave a hole where it came from

4304
01:31:17,750 --> 01:31:20,880
 

4305
01:31:17,760 --> 01:31:23,120
 but that basically means now your

4306
01:31:20,870 --> 01:31:23,120
 

4307
01:31:20,880 --> 01:31:24,880
 your sequence of objects is no longer

4308
01:31:23,110 --> 01:31:24,880
 

4309
01:31:23,120 --> 01:31:27,760
 contiguous and so it's no longer

4310
01:31:24,870 --> 01:31:27,760
 

4311
01:31:24,880 --> 01:31:27,760
 in a valid state

4312
01:31:28,629 --> 01:31:28,629
 

4313
01:31:28,639 --> 01:31:32,320
 so so there's this this fundamental

4314
01:31:30,790 --> 01:31:32,320
 

4315
01:31:30,800 --> 01:31:35,280
 trade-off that you have between

4316
01:31:32,310 --> 01:31:35,280
 

4317
01:31:32,320 --> 01:31:36,080
 performance and safety and so you have

4318
01:31:35,270 --> 01:31:36,080
 

4319
01:31:35,280 --> 01:31:39,120
 to

4320
01:31:36,070 --> 01:31:39,120
 

4321
01:31:36,080 --> 01:31:40,239
 take care and i think i see a lot of

4322
01:31:39,110 --> 01:31:40,239
 

4323
01:31:39,120 --> 01:31:44,560
 issues getting

4324
01:31:40,229 --> 01:31:44,560
 

4325
01:31:40,239 --> 01:31:46,960
 called caused by two things one is the

4326
01:31:44,550 --> 01:31:46,960
 

4327
01:31:44,560 --> 01:31:48,719
 the uh you know i already mentioned

4328
01:31:46,950 --> 01:31:48,719
 

4329
01:31:46,960 --> 01:31:51,360
 shared shared pointers

4330
01:31:48,709 --> 01:31:51,360
 

4331
01:31:48,719 --> 01:31:52,719
 but uh two of the newer things are

4332
01:31:51,350 --> 01:31:52,719
 

4333
01:31:51,360 --> 01:31:59,840
 optional

4334
01:31:52,709 --> 01:31:59,840
 

4335
01:31:52,719 --> 01:31:59,840
 and um

4336
01:32:00,629 --> 01:32:00,629
 

4337
01:32:00,639 --> 01:32:04,080
 no it was the first time i was thinking

4338
01:32:02,550 --> 01:32:04,080
 

4339
01:32:02,560 --> 01:32:06,639
 it will come back to me so so

4340
01:32:04,070 --> 01:32:06,639
 

4341
01:32:04,080 --> 01:32:07,199
 let me talk about optional for a minute

4342
01:32:06,629 --> 01:32:07,199
 

4343
01:32:06,639 --> 01:32:08,719
 i see

4344
01:32:07,189 --> 01:32:08,719
 

4345
01:32:07,199 --> 01:32:11,040
 people making more and more and more

4346
01:32:08,709 --> 01:32:11,040
 

4347
01:32:08,719 --> 01:32:12,000
 code with optional and letting optionals

4348
01:32:11,030 --> 01:32:12,000
 

4349
01:32:11,040 --> 01:32:13,840
 kind of spread throughout their

4350
01:32:11,990 --> 01:32:13,840
 

4351
01:32:12,000 --> 01:32:15,440
 system and ideally with an optional you

4352
01:32:13,830 --> 01:32:15,440
 

4353
01:32:13,840 --> 01:32:15,840
 kind of want to you know it's a good

4354
01:32:15,430 --> 01:32:15,840
 

4355
01:32:15,440 --> 01:32:16,960
 function

4356
01:32:15,830 --> 01:32:16,960
 

4357
01:32:15,840 --> 01:32:19,199
 result if you have something that can

4358
01:32:16,950 --> 01:32:19,199
 

4359
01:32:16,960 --> 01:32:22,239
 return something or nothing

4360
01:32:19,189 --> 01:32:22,239
 

4361
01:32:19,199 --> 01:32:26,080
 but then once you have the optional uh

4362
01:32:22,229 --> 01:32:26,080
 

4363
01:32:22,239 --> 01:32:27,520
 uh you want to you know basically

4364
01:32:26,070 --> 01:32:27,520
 

4365
01:32:26,080 --> 01:32:29,679
 take the insides out and go one

4366
01:32:27,510 --> 01:32:29,679
 

4367
01:32:27,520 --> 01:32:30,960
 direction or go a different direction

4368
01:32:29,669 --> 01:32:30,960
 

4369
01:32:29,679 --> 01:32:32,639
 you don't want to keep carrying the

4370
01:32:30,950 --> 01:32:32,639
 

4371
01:32:30,960 --> 01:32:34,239
 optional around and turn everything into

4372
01:32:32,629 --> 01:32:34,239
 

4373
01:32:32,639 --> 01:32:35,199
 a maybe monad because at some point

4374
01:32:34,229 --> 01:32:35,199
 

4375
01:32:34,239 --> 01:32:37,199
 somebody's going to

4376
01:32:35,189 --> 01:32:37,199
 

4377
01:32:35,199 --> 01:32:38,560
 forget to check and see is the value

4378
01:32:37,189 --> 01:32:38,560
 

4379
01:32:37,199 --> 01:32:40,800
 there or not

4380
01:32:38,550 --> 01:32:40,800
 

4381
01:32:38,560 --> 01:32:43,199
 and and it's they might as well have

4382
01:32:40,790 --> 01:32:43,199
 

4383
01:32:40,800 --> 01:32:44,960
 just dereferenced a uh

4384
01:32:43,189 --> 01:32:44,960
 

4385
01:32:43,199 --> 01:32:46,320
 a null pointer you know if they went

4386
01:32:44,950 --> 01:32:46,320
 

4387
01:32:44,960 --> 01:32:48,719
 through the value thing maybe it throws

4388
01:32:46,310 --> 01:32:48,719
 

4389
01:32:46,320 --> 01:32:55,440
 an exception but it's equally as bad for

4390
01:32:48,709 --> 01:32:55,440
 

4391
01:32:48,719 --> 01:32:56,800
 the correctness of your application um

4392
01:32:55,430 --> 01:32:56,800
 

4393
01:32:55,440 --> 01:32:58,800
 uh oh the other thing that i was going

4394
01:32:56,790 --> 01:32:58,800
 

4395
01:32:56,800 --> 01:33:01,840
 to mention is a

4396
01:32:58,790 --> 01:33:01,840
 

4397
01:32:58,800 --> 01:33:03,920
 explicit move and and r value references

4398
01:33:01,830 --> 01:33:03,920
 

4399
01:33:01,840 --> 01:33:05,679
 you really want to try to avoid explicit

4400
01:33:03,910 --> 01:33:05,679
 

4401
01:33:03,920 --> 01:33:07,360
 moves which means

4402
01:33:05,669 --> 01:33:07,360
 

4403
01:33:05,679 --> 01:33:08,639
 you still want to use r value references

4404
01:33:07,350 --> 01:33:08,639
 

4405
01:33:07,360 --> 01:33:11,840
 our value references without the

4406
01:33:08,629 --> 01:33:11,840
 

4407
01:33:08,639 --> 01:33:13,920
 explicit move are safe

4408
01:33:11,830 --> 01:33:13,920
 

4409
01:33:11,840 --> 01:33:16,080
 but that just means that you have to

4410
01:33:13,910 --> 01:33:16,080
 

4411
01:33:13,920 --> 01:33:17,120
 compose your code in a more functional

4412
01:33:16,070 --> 01:33:17,120
 

4413
01:33:16,080 --> 01:33:18,960
 fashion

4414
01:33:17,110 --> 01:33:18,960
 

4415
01:33:17,120 --> 01:33:20,800
 so that the function results of one

4416
01:33:18,950 --> 01:33:20,800
 

4417
01:33:18,960 --> 01:33:22,159
 thing become the immediate arguments to

4418
01:33:20,790 --> 01:33:22,159
 

4419
01:33:20,800 --> 01:33:23,600
 the next thing and you're not putting

4420
01:33:22,149 --> 01:33:23,600
 

4421
01:33:22,159 --> 01:33:24,400
 them into a temporary and then moving

4422
01:33:23,590 --> 01:33:24,400
 

4423
01:33:23,600 --> 01:33:25,840
 them out

4424
01:33:24,390 --> 01:33:25,840
 

4425
01:33:24,400 --> 01:33:28,000
 and causing the problem that now you've

4426
01:33:25,830 --> 01:33:28,000
 

4427
01:33:25,840 --> 01:33:30,560
 got this this uh

4428
01:33:27,990 --> 01:33:30,560
 

4429
01:33:28,000 --> 01:33:32,159
 you know invalid object in your code

4430
01:33:30,550 --> 01:33:32,159
 

4431
01:33:30,560 --> 01:33:33,920
 which the next programmer isn't going to

4432
01:33:32,149 --> 01:33:33,920
 

4433
01:33:32,159 --> 01:33:36,719
 realize is invalid and they're going to

4434
01:33:33,910 --> 01:33:36,719
 

4435
01:33:33,920 --> 01:33:39,280
 use it again on the next line

4436
01:33:36,709 --> 01:33:39,280
 

4437
01:33:36,719 --> 01:33:40,639
 so so yes you want to try to make the

4438
01:33:39,270 --> 01:33:40,639
 

4439
01:33:39,280 --> 01:33:42,560
 impossible states

4440
01:33:40,629 --> 01:33:42,560
 

4441
01:33:40,639 --> 01:33:45,280
 uh the invalid states impossible to

4442
01:33:42,550 --> 01:33:45,280
 

4443
01:33:42,560 --> 01:33:50,480
 represent but you can't

4444
01:33:45,270 --> 01:33:50,480
 

4445
01:33:45,280 --> 01:33:52,080
 and this is even true in

4446
01:33:50,470 --> 01:33:52,080
 

4447
01:33:50,480 --> 01:33:54,719
 you know haskell or purely functional

4448
01:33:52,070 --> 01:33:54,719
 

4449
01:33:52,080 --> 01:33:56,639
 languages right if it's turing complete

4450
01:33:54,709 --> 01:33:56,639
 

4451
01:33:54,719 --> 01:33:58,320
 you can build a c machine inside of it

4452
01:33:56,629 --> 01:33:58,320
 

4453
01:33:56,639 --> 01:34:00,080
 and always write the same bad code that

4454
01:33:58,310 --> 01:34:00,080
 

4455
01:33:58,320 --> 01:34:04,480
 you couldn't see

4456
01:34:00,070 --> 01:34:04,480
 

4457
01:34:00,080 --> 01:34:06,080
 and so so uh

4458
01:34:04,470 --> 01:34:06,080
 

4459
01:34:04,480 --> 01:34:08,560
 your language will help but it won't

4460
01:34:06,070 --> 01:34:08,560
 

4461
01:34:06,080 --> 01:34:08,560
 save you

4462
01:34:13,830 --> 01:34:13,830
 

4463
01:34:13,840 --> 01:34:19,840
 let's see any other questions

4464
01:34:23,669 --> 01:34:23,669
 

4465
01:34:23,679 --> 01:34:33,840
 uh somebody said variant um

4466
01:34:27,910 --> 01:34:33,840
 

4467
01:34:27,920 --> 01:34:33,840
 uh uh you know yeah i think

4468
01:34:35,030 --> 01:34:35,030
 

4469
01:34:35,040 --> 01:34:39,679
 variant is one of those things where i

4470
01:34:37,350 --> 01:34:39,679
 

4471
01:34:37,360 --> 01:34:41,040
 don't think it gets used enough

4472
01:34:39,669 --> 01:34:41,040
 

4473
01:34:39,679 --> 01:34:43,679
 in the sense that i think a lot of

4474
01:34:41,030 --> 01:34:43,679
 

4475
01:34:41,040 --> 01:34:46,320
 people reach for polymorphism as a first

4476
01:34:43,669 --> 01:34:46,320
 

4477
01:34:43,679 --> 01:34:48,320
 choice even when they have a closed set

4478
01:34:46,310 --> 01:34:48,320
 

4479
01:34:46,320 --> 01:34:51,040
 of data types where a variant would be a

4480
01:34:48,310 --> 01:34:51,040
 

4481
01:34:48,320 --> 01:34:51,040
 better solution

4482
01:34:52,709 --> 01:34:52,709
 

4483
01:34:52,719 --> 01:34:59,040
 so you know a variant done

4484
01:34:55,910 --> 01:34:59,040
 

4485
01:34:55,920 --> 01:35:02,159
 well where you're basically packaging

4486
01:34:59,030 --> 01:35:02,159
 

4487
01:34:59,040 --> 01:35:02,159
 things up into

4488
01:35:02,229 --> 01:35:02,229
 

4489
01:35:02,239 --> 01:35:07,040
 uh you know anytime you have polymorph

4490
01:35:05,830 --> 01:35:07,040
 

4491
01:35:05,840 --> 01:35:09,440
 morphism really what you want to be

4492
01:35:07,030 --> 01:35:09,440
 

4493
01:35:07,040 --> 01:35:11,440
 doing is packaging things up that have

4494
01:35:09,430 --> 01:35:11,440
 

4495
01:35:09,440 --> 01:35:14,000
 some similar trait that that

4496
01:35:11,430 --> 01:35:14,000
 

4497
01:35:11,440 --> 01:35:15,760
 that they all satisfy the same concept

4498
01:35:13,990 --> 01:35:15,760
 

4499
01:35:14,000 --> 01:35:17,440
 and so if you have a variant that's a

4500
01:35:15,750 --> 01:35:17,440
 

4501
01:35:15,760 --> 01:35:19,520
 collection of objects that satisfy the

4502
01:35:17,430 --> 01:35:19,520
 

4503
01:35:17,440 --> 01:35:21,119
 same concepts

4504
01:35:19,510 --> 01:35:21,119
 

4505
01:35:19,520 --> 01:35:23,119
 then that's great then it's just another

4506
01:35:21,109 --> 01:35:23,119
 

4507
01:35:21,119 --> 01:35:24,960
 value type and you use it as if it were

4508
01:35:23,109 --> 01:35:24,960
 

4509
01:35:23,119 --> 01:35:26,000
 any of those objects and everything just

4510
01:35:24,950 --> 01:35:26,000
 

4511
01:35:24,960 --> 01:35:27,760
 works

4512
01:35:25,990 --> 01:35:27,760
 

4513
01:35:26,000 --> 01:35:29,840
 where you get into trouble with variance

4514
01:35:27,750 --> 01:35:29,840
 

4515
01:35:27,760 --> 01:35:32,560
 is when when you don't do that

4516
01:35:29,830 --> 01:35:32,560
 

4517
01:35:29,840 --> 01:35:34,239
 and uh you know instead of kind of

4518
01:35:32,550 --> 01:35:34,239
 

4519
01:35:32,560 --> 01:35:35,840
 having a generic visitor that will do

4520
01:35:34,229 --> 01:35:35,840
 

4521
01:35:34,239 --> 01:35:37,360
 the same thing on all the objects you

4522
01:35:35,830 --> 01:35:37,360
 

4523
01:35:35,840 --> 01:35:38,480
 have special case after special case

4524
01:35:37,350 --> 01:35:38,480
 

4525
01:35:37,360 --> 01:35:42,800
 after special case

4526
01:35:38,470 --> 01:35:42,800
 

4527
01:35:38,480 --> 01:35:44,800
 those things you want to avoid

4528
01:35:42,790 --> 01:35:44,800
 

4529
01:35:42,800 --> 01:35:46,000
 uh do i have comments on physical

4530
01:35:44,790 --> 01:35:46,000
 

4531
01:35:44,800 --> 01:35:49,199
 layouts of the

4532
01:35:45,990 --> 01:35:49,199
 

4533
01:35:46,000 --> 01:35:52,719
 c plus project um yeah you know it's

4534
01:35:49,189 --> 01:35:52,719
 

4535
01:35:49,199 --> 01:35:54,639
 a case that i'm horrible at uh

4536
01:35:52,709 --> 01:35:54,639
 

4537
01:35:52,719 --> 01:35:57,040
 uh i would like to see a standardized

4538
01:35:54,629 --> 01:35:57,040
 

4539
01:35:54,639 --> 01:35:57,040
 things

4540
01:35:57,189 --> 01:35:57,189
 

4541
01:35:57,199 --> 01:36:00,400
 more there's a

4542
01:36:00,470 --> 01:36:00,470
 

4543
01:36:00,480 --> 01:36:03,520
 proposal that people have started

4544
01:36:02,310 --> 01:36:03,520
 

4545
01:36:02,320 --> 01:36:06,480
 following more and more

4546
01:36:03,510 --> 01:36:06,480
 

4547
01:36:03,520 --> 01:36:08,000
 which is uh what's the bike shed layout

4548
01:36:06,470 --> 01:36:08,000
 

4549
01:36:06,480 --> 01:36:12,880
 i think is what it's called

4550
01:36:07,990 --> 01:36:12,880
 

4551
01:36:08,000 --> 01:36:12,880
 let me see if i can put a link in chat

4552
01:36:13,669 --> 01:36:13,669
 

4553
01:36:13,679 --> 01:36:25,840
 uh bike shed

4554
01:36:18,229 --> 01:36:25,840
 

4555
01:36:18,239 --> 01:36:25,840
 library layout

4556
01:36:27,750 --> 01:36:27,750
 

4557
01:36:27,760 --> 01:36:30,880
 stick a link in chat

4558
01:36:31,750 --> 01:36:31,750
 

4559
01:36:31,760 --> 01:36:34,800
 this is kind of the best

4560
01:36:35,990 --> 01:36:35,990
 

4561
01:36:36,000 --> 01:36:40,320
 top level layout that i found we don't

4562
01:36:38,310 --> 01:36:40,320
 

4563
01:36:38,320 --> 01:36:42,320
 do this right now with sdlab i'd like to

4564
01:36:40,310 --> 01:36:42,320
 

4565
01:36:40,320 --> 01:36:45,760
 switch st lab to do that

4566
01:36:42,310 --> 01:36:45,760
 

4567
01:36:42,320 --> 01:36:48,639
 um uh i you know

4568
01:36:45,750 --> 01:36:48,639
 

4569
01:36:45,760 --> 01:36:50,239
 adobe right now is rolling their own

4570
01:36:48,629 --> 01:36:50,239
 

4571
01:36:48,639 --> 01:36:51,360
 kind of dependency management system

4572
01:36:50,229 --> 01:36:51,360
 

4573
01:36:50,239 --> 01:36:54,320
 that i'm hoping we're going to

4574
01:36:51,350 --> 01:36:54,320
 

4575
01:36:51,360 --> 01:36:56,480
 open source you know when you're

4576
01:36:54,310 --> 01:36:56,480
 

4577
01:36:54,320 --> 01:36:59,119
 building on kind of a bundled product

4578
01:36:56,470 --> 01:36:59,119
 

4579
01:36:56,480 --> 01:37:00,239
 like a desktop product which is a little

4580
01:36:59,109 --> 01:37:00,239
 

4581
01:36:59,119 --> 01:37:01,360
 different than a server product where

4582
01:37:00,229 --> 01:37:01,360
 

4583
01:37:00,239 --> 01:37:03,520
 you're trying to get you know like

4584
01:37:01,350 --> 01:37:03,520
 

4585
01:37:01,360 --> 01:37:05,119
 one application to run inside of a vm so

4586
01:37:03,510 --> 01:37:05,119
 

4587
01:37:03,520 --> 01:37:06,000
 you suck down all these libraries and

4588
01:37:05,109 --> 01:37:06,000
 

4589
01:37:05,119 --> 01:37:07,840
 and

4590
01:37:05,990 --> 01:37:07,840
 

4591
01:37:06,000 --> 01:37:09,119
 they're always dlls basically we want to

4592
01:37:07,830 --> 01:37:09,119
 

4593
01:37:07,840 --> 01:37:12,480
 statically link everything

4594
01:37:09,109 --> 01:37:12,480
 

4595
01:37:09,119 --> 01:37:16,000
 and to do that well dynamically

4596
01:37:12,470 --> 01:37:16,000
 

4597
01:37:12,480 --> 01:37:16,000
 linking well you want everything built

4598
01:37:16,149 --> 01:37:16,149
 

4599
01:37:16,159 --> 01:37:19,679
 from sources with the same compiler

4600
01:37:18,149 --> 01:37:19,679
 

4601
01:37:18,159 --> 01:37:21,840
 settings

4602
01:37:19,669 --> 01:37:21,840
 

4603
01:37:19,679 --> 01:37:23,440
 with the same compiler with the same set

4604
01:37:21,830 --> 01:37:23,440
 

4605
01:37:21,840 --> 01:37:25,440
 of dependencies

4606
01:37:23,430 --> 01:37:25,440
 

4607
01:37:23,440 --> 01:37:29,760
 and shake things out that way and there

4608
01:37:25,430 --> 01:37:29,760
 

4609
01:37:25,440 --> 01:37:29,760
 just are not good tools for doing that

4610
01:37:29,830 --> 01:37:29,830
 

4611
01:37:29,840 --> 01:37:33,360
 so adobe has been been rolling their own

4612
01:37:32,070 --> 01:37:33,360
 

4613
01:37:32,080 --> 01:37:34,880
 and i'm hoping we'll be able to open

4614
01:37:33,350 --> 01:37:34,880
 

4615
01:37:33,360 --> 01:37:36,239
 source it and i've been pushing on that

4616
01:37:34,870 --> 01:37:36,239
 

4617
01:37:34,880 --> 01:37:39,440
 team

4618
01:37:36,229 --> 01:37:39,440
 

4619
01:37:36,239 --> 01:37:41,760
 what i would like to say see happen

4620
01:37:39,430 --> 01:37:41,760
 

4621
01:37:39,440 --> 01:37:43,520
 is if you have a library that follows a

4622
01:37:41,750 --> 01:37:43,520
 

4623
01:37:41,760 --> 01:37:47,040
 standard layout

4624
01:37:43,510 --> 01:37:47,040
 

4625
01:37:43,520 --> 01:37:47,040
 like a bike shed layout

4626
01:37:47,109 --> 01:37:47,109
 

4627
01:37:47,119 --> 01:37:51,440
 that you should just be able to say oh

4628
01:37:49,430 --> 01:37:51,440
 

4629
01:37:49,440 --> 01:37:53,920
 you know add the dependency

4630
01:37:51,430 --> 01:37:53,920
 

4631
01:37:51,440 --> 01:37:55,600
 to that library and tell a dependency

4632
01:37:53,910 --> 01:37:55,600
 

4633
01:37:53,920 --> 01:37:58,719
 management system nothing more

4634
01:37:55,590 --> 01:37:58,719
 

4635
01:37:55,600 --> 01:37:58,719
 and it will just work

4636
01:37:59,030 --> 01:37:59,030
 

4637
01:37:59,040 --> 01:38:02,800
 question here is our system

4638
01:38:00,229 --> 01:38:02,800
 

4639
01:38:00,239 --> 01:38:04,320
 complementing cmake uh

4640
01:38:02,790 --> 01:38:04,320
 

4641
01:38:02,800 --> 01:38:06,560
 yeah it's not building another build

4642
01:38:04,310 --> 01:38:06,560
 

4643
01:38:04,320 --> 01:38:09,280
 tool so it's a complement

4644
01:38:06,550 --> 01:38:09,280
 

4645
01:38:06,560 --> 01:38:11,040
 to cmake and jip and a couple other

4646
01:38:09,270 --> 01:38:11,040
 

4647
01:38:09,280 --> 01:38:14,239
 build systems that we

4648
01:38:11,030 --> 01:38:14,239
 

4649
01:38:11,040 --> 01:38:18,320
 we run internally

4650
01:38:14,229 --> 01:38:18,320
 

4651
01:38:14,239 --> 01:38:18,320
 so yes it's a complement to c make

4652
01:38:24,550 --> 01:38:24,550
 

4653
01:38:24,560 --> 01:38:28,480
 its job is just to handle dependencies

4654
01:38:26,950 --> 01:38:28,480
 

4655
01:38:26,960 --> 01:38:30,080
 like one of the

4656
01:38:28,470 --> 01:38:30,080
 

4657
01:38:28,480 --> 01:38:33,760
 you know nice things about cmake is you

4658
01:38:30,070 --> 01:38:33,760
 

4659
01:38:30,080 --> 01:38:33,760
 can kind of uh

4660
01:38:34,070 --> 01:38:34,070
 

4661
01:38:34,080 --> 01:38:37,280
 insert things like build settings from

4662
01:38:35,830 --> 01:38:37,280
 

4663
01:38:35,840 --> 01:38:39,600
 the top down

4664
01:38:37,270 --> 01:38:39,600
 

4665
01:38:37,280 --> 01:38:39,600
 but

4666
01:38:40,550 --> 01:38:40,550
 

4667
01:38:40,560 --> 01:38:45,760
 there's no way within cmake to express

4668
01:38:43,510 --> 01:38:45,760
 

4669
01:38:43,520 --> 01:38:46,239
 this library requires that it be built

4670
01:38:45,750 --> 01:38:46,239
 

4671
01:38:45,760 --> 01:38:49,360
 with c

4672
01:38:46,229 --> 01:38:49,360
 

4673
01:38:46,239 --> 01:38:50,480
 plus 14 as an example you know at least

4674
01:38:49,350 --> 01:38:50,480
 

4675
01:38:49,360 --> 01:38:53,600
 14

4676
01:38:50,470 --> 01:38:53,600
 

4677
01:38:50,480 --> 01:38:54,800
 and if you're if you want to be building

4678
01:38:53,590 --> 01:38:54,800
 

4679
01:38:53,600 --> 01:38:56,639
 everything with the

4680
01:38:54,790 --> 01:38:56,639
 

4681
01:38:54,800 --> 01:38:58,560
 with the same compiler settings then

4682
01:38:56,629 --> 01:38:58,560
 

4683
01:38:56,639 --> 01:38:59,920
 that imposes a restriction on every

4684
01:38:58,550 --> 01:38:59,920
 

4685
01:38:58,560 --> 01:39:13,840
 other library that you would want to

4686
01:38:59,910 --> 01:39:13,840
 

4687
01:38:59,920 --> 01:39:13,840
 integrate together

4688
01:39:22,629 --> 01:39:22,629
 

4689
01:39:22,639 --> 01:39:24,719
 you