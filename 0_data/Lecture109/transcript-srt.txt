1
00:05:37,420 --> 00:05:40,890
 see you after the toilet

2
00:09:50,239 --> 00:09:50,239
 

3
00:09:50,249 --> 00:09:55,660
 all right so welcome back everyone so as

4
00:09:54,239 --> 00:09:55,660
 

5
00:09:54,249 --> 00:09:57,910
 you know this tutorial will be about

6
00:09:55,650 --> 00:09:57,910
 

7
00:09:55,660 --> 00:10:00,069
 algorithm configuration learning in the

8
00:09:57,900 --> 00:10:00,069
 

9
00:09:57,910 --> 00:10:01,990
 space of algorithm design which I

10
00:10:00,059 --> 00:10:01,990
 

11
00:10:00,069 --> 00:10:04,420
 personally think is a really important

12
00:10:01,980 --> 00:10:04,420
 

13
00:10:01,990 --> 00:10:06,790
 exciting emerging topic and our tutorial

14
00:10:04,410 --> 00:10:06,790
 

15
00:10:04,420 --> 00:10:09,790
 speakers today are two pioneers in this

16
00:10:06,780 --> 00:10:09,790
 

17
00:10:06,790 --> 00:10:12,069
 field the first tutorial speaker is

18
00:10:09,780 --> 00:10:12,069
 

19
00:10:09,790 --> 00:10:15,519
 Kevin Bacon Brown he is a professor of

20
00:10:12,059 --> 00:10:15,519
 

21
00:10:12,069 --> 00:10:20,910
 computer science at UBC in Canada and he

22
00:10:15,509 --> 00:10:20,910
 

23
00:10:15,519 --> 00:10:23,709
 is also Canada's sefa AI chair at ami

24
00:10:20,900 --> 00:10:23,709
 

25
00:10:20,910 --> 00:10:26,079
 Kevin works broadly in AI machine

26
00:10:23,699 --> 00:10:26,079
 

27
00:10:23,709 --> 00:10:28,809
 learning and algorithm ugly me game

28
00:10:26,069 --> 00:10:28,809
 

29
00:10:26,079 --> 00:10:30,369
 theory and he won many awards many

30
00:10:28,799 --> 00:10:30,369
 

31
00:10:28,809 --> 00:10:33,309
 honors and awards for his work including

32
00:10:30,359 --> 00:10:33,309
 

33
00:10:30,369 --> 00:10:37,869
 being an elected fellow of triple AI and

34
00:10:33,299 --> 00:10:37,869
 

35
00:10:33,309 --> 00:10:40,809
 an ACM distinguished member that's Kevin

36
00:10:37,859 --> 00:10:40,809
 

37
00:10:37,869 --> 00:10:43,059
 our second speaker is Frank Hatter

38
00:10:40,799 --> 00:10:43,059
 

39
00:10:40,809 --> 00:10:45,670
 Frank is a full professor for machine

40
00:10:43,049 --> 00:10:45,670
 

41
00:10:43,059 --> 00:10:47,319
 learning at the computer science

42
00:10:45,660 --> 00:10:47,319
 

43
00:10:45,670 --> 00:10:48,869
 department of the University of Freiburg

44
00:10:47,309 --> 00:10:48,869
 

45
00:10:47,319 --> 00:10:51,610
 in Germany

46
00:10:48,859 --> 00:10:51,610
 

47
00:10:48,869 --> 00:10:53,949
 his main research interests are in

48
00:10:51,600 --> 00:10:53,949
 

49
00:10:51,610 --> 00:10:58,689
 machine learning artificial intelligence

50
00:10:53,939 --> 00:10:58,689
 

51
00:10:53,949 --> 00:11:00,759
 and automated algorithm design and he

52
00:10:58,679 --> 00:11:00,759
 

53
00:10:58,689 --> 00:11:05,829
 also won many different awards for his

54
00:11:00,749 --> 00:11:05,829
 

55
00:11:00,759 --> 00:11:07,449
 work including the ERC grant and just

56
00:11:05,819 --> 00:11:07,449
 

57
00:11:05,829 --> 00:11:09,939
 like Kevin he's also a pioneer of

58
00:11:07,439 --> 00:11:09,939
 

59
00:11:07,449 --> 00:11:12,399
 algorithm configuration the topic of the

60
00:11:09,929 --> 00:11:12,399
 

61
00:11:09,939 --> 00:11:14,379
 tutorial today and so we are extremely

62
00:11:12,389 --> 00:11:14,379
 

63
00:11:12,399 --> 00:11:18,730
 delighted to have both Kevin and Frank

64
00:11:14,369 --> 00:11:18,730
 

65
00:11:14,379 --> 00:11:20,640
 giving the tutorial today so please join

66
00:11:18,720 --> 00:11:20,640
 

67
00:11:18,730 --> 00:11:26,200
 me in welcoming back

68
00:11:20,630 --> 00:11:26,200
 

69
00:11:20,640 --> 00:11:33,020
[Applause]

70
00:11:26,190 --> 00:11:33,020
 

71
00:11:26,200 --> 00:11:34,340
 thanks Nina so let me let me begin by

72
00:11:33,010 --> 00:11:34,340
 

73
00:11:33,020 --> 00:11:36,050
 giving you the kind of high-level

74
00:11:34,330 --> 00:11:36,050
 

75
00:11:34,340 --> 00:11:39,170
 outline of what we're gonna speak about

76
00:11:36,040 --> 00:11:39,170
 

77
00:11:36,050 --> 00:11:41,030
 today so I'm really excited to tell you

78
00:11:39,160 --> 00:11:41,030
 

79
00:11:39,170 --> 00:11:43,430
 guys about algorithm configuration both

80
00:11:41,020 --> 00:11:43,430
 

81
00:11:41,030 --> 00:11:46,430
 because I think it's a really practical

82
00:11:43,420 --> 00:11:46,430
 

83
00:11:43,430 --> 00:11:47,540
 and impactful tool that is useful for I

84
00:11:46,420 --> 00:11:47,540
 

85
00:11:46,430 --> 00:11:49,820
 think a lot of the kinds of problems

86
00:11:47,530 --> 00:11:49,820
 

87
00:11:47,540 --> 00:11:51,560
 that the ML community is starting to

88
00:11:49,810 --> 00:11:51,560
 

89
00:11:49,820 --> 00:11:55,150
 care a lot about you know going beyond

90
00:11:51,550 --> 00:11:55,150
 

91
00:11:51,560 --> 00:11:58,010
 just simply simple predictive modeling

92
00:11:55,140 --> 00:11:58,010
 

93
00:11:55,150 --> 00:11:59,450
 we're gonna speak at the beginning I'll

94
00:11:58,000 --> 00:11:59,450
 

95
00:11:58,010 --> 00:12:01,250
 kind of give you the lay of the land

96
00:11:59,440 --> 00:12:01,250
 

97
00:11:59,450 --> 00:12:04,100
 I'll tell you why I think this problem

98
00:12:01,240 --> 00:12:04,100
 

99
00:12:01,250 --> 00:12:06,230
 is exciting and I'll give you a case

100
00:12:04,090 --> 00:12:06,230
 

101
00:12:04,100 --> 00:12:08,270
 study on a particularly high-stakes

102
00:12:06,220 --> 00:12:08,270
 

103
00:12:06,230 --> 00:12:10,670
 application of algorithm configuration

104
00:12:08,260 --> 00:12:10,670
 

105
00:12:08,270 --> 00:12:13,010
 that that shows I think the promise that

106
00:12:10,660 --> 00:12:13,010
 

107
00:12:10,670 --> 00:12:14,960
 this kind of methodology has I'll hand

108
00:12:13,000 --> 00:12:14,960
 

109
00:12:13,010 --> 00:12:16,550
 over to Frank and he'll tell you about

110
00:12:14,950 --> 00:12:16,550
 

111
00:12:14,960 --> 00:12:19,730
 practical methods for algorithm

112
00:12:16,540 --> 00:12:19,730
 

113
00:12:16,550 --> 00:12:22,940
 configuration which are the sort of more

114
00:12:19,720 --> 00:12:22,940
 

115
00:12:19,730 --> 00:12:24,200
 heuristic algorithms that are pretty

116
00:12:22,930 --> 00:12:24,200
 

117
00:12:22,940 --> 00:12:26,480
 mature at this point people have been

118
00:12:24,190 --> 00:12:26,480
 

119
00:12:24,200 --> 00:12:29,420
 working on them for sort of 15 or 20

120
00:12:26,470 --> 00:12:29,420
 

121
00:12:26,480 --> 00:12:31,670
 years and they're what has really had

122
00:12:29,410 --> 00:12:31,670
 

123
00:12:29,420 --> 00:12:33,440
 success in applications we'll take a

124
00:12:31,660 --> 00:12:33,440
 

125
00:12:31,670 --> 00:12:36,170
 short break so you can stretch your legs

126
00:12:33,430 --> 00:12:36,170
 

127
00:12:33,440 --> 00:12:38,180
 and then we'll move to speaking about

128
00:12:36,160 --> 00:12:38,180
 

129
00:12:36,170 --> 00:12:41,570
 algorithm configuration methods that

130
00:12:38,170 --> 00:12:41,570
 

131
00:12:38,180 --> 00:12:44,330
 have theoretical guarantees after and

132
00:12:41,560 --> 00:12:44,330
 

133
00:12:41,570 --> 00:12:46,100
 after that Frank will then go beyond the

134
00:12:44,320 --> 00:12:46,100
 

135
00:12:44,330 --> 00:12:49,430
 kind of static algorithm configuration

136
00:12:46,090 --> 00:12:49,430
 

137
00:12:46,100 --> 00:12:52,790
 problem and tell you about related

138
00:12:49,420 --> 00:12:52,790
 

139
00:12:49,430 --> 00:12:55,520
 problems that the field is starting to

140
00:12:52,780 --> 00:12:55,520
 

141
00:12:52,790 --> 00:12:58,100
 think about let me note to you the URL

142
00:12:55,510 --> 00:12:58,100
 

143
00:12:55,520 --> 00:12:59,960
 at the bottom of this slide we've posted

144
00:12:58,090 --> 00:12:59,960
 

145
00:12:58,100 --> 00:13:01,640
 our slides online so especially if

146
00:12:59,950 --> 00:13:01,640
 

147
00:12:59,960 --> 00:13:03,230
 you're far away from the screen and have

148
00:13:01,630 --> 00:13:03,230
 

149
00:13:01,640 --> 00:13:05,840
 trouble making out some of the details

150
00:13:03,220 --> 00:13:05,840
 

151
00:13:03,230 --> 00:13:08,570
 and you can click on this link and and

152
00:13:05,830 --> 00:13:08,570
 

153
00:13:05,840 --> 00:13:10,130
 get a PDF of all the slides also all of

154
00:13:08,560 --> 00:13:10,130
 

155
00:13:08,570 --> 00:13:11,840
 the references in the talk are

156
00:13:10,120 --> 00:13:11,840
 

157
00:13:10,130 --> 00:13:14,210
 hyperlinks in the presentation to the

158
00:13:11,830 --> 00:13:14,210
 

159
00:13:11,840 --> 00:13:15,560
 original papers so if there's anything

160
00:13:14,200 --> 00:13:15,560
 

161
00:13:14,210 --> 00:13:17,690
 that you're interested in learning more

162
00:13:15,550 --> 00:13:17,690
 

163
00:13:15,560 --> 00:13:19,490
 about you can get that from the PDFs so

164
00:13:17,680 --> 00:13:19,490
 

165
00:13:17,690 --> 00:13:21,170
 that'll be on every slide at the very

166
00:13:19,480 --> 00:13:21,170
 

167
00:13:19,490 --> 00:13:23,480
 footer but that won't help you if you're

168
00:13:21,160 --> 00:13:23,480
 

169
00:13:21,170 --> 00:13:27,410
 at the back so I'll have it on the title

170
00:13:23,470 --> 00:13:27,410
 

171
00:13:23,480 --> 00:13:29,900
 slides too so here at the beginning I'm

172
00:13:27,400 --> 00:13:29,900
 

173
00:13:27,410 --> 00:13:32,630
 going to begin by telling you why it is

174
00:13:29,890 --> 00:13:32,630
 

175
00:13:29,900 --> 00:13:34,370
 that we claimed that algorithm

176
00:13:32,620 --> 00:13:34,370
 

177
00:13:32,630 --> 00:13:35,810
 configuration should be thought of as

178
00:13:34,360 --> 00:13:35,810
 

179
00:13:34,370 --> 00:13:37,340
 learning in the space of algorithm

180
00:13:35,800 --> 00:13:37,340
 

181
00:13:35,810 --> 00:13:39,170
 designs

182
00:13:37,330 --> 00:13:39,170
 

183
00:13:37,340 --> 00:13:41,360
 then I'll formally define what this

184
00:13:39,160 --> 00:13:41,360
 

185
00:13:39,170 --> 00:13:43,820
 problem is I'll tell you about a key

186
00:13:41,350 --> 00:13:43,820
 

187
00:13:41,360 --> 00:13:46,010
 enabling technology which is algorithm

188
00:13:43,810 --> 00:13:46,010
 

189
00:13:43,820 --> 00:13:47,800
 runtime prediction and then finally I'll

190
00:13:46,000 --> 00:13:47,800
 

191
00:13:46,010 --> 00:13:50,500
 do that case study that I told you about

192
00:13:47,790 --> 00:13:50,500
 

193
00:13:47,800 --> 00:13:53,510
 so let's get into it

194
00:13:50,490 --> 00:13:53,510
 

195
00:13:50,500 --> 00:13:55,820
 so broadly speaking algorithm

196
00:13:53,500 --> 00:13:55,820
 

197
00:13:53,510 --> 00:13:57,470
 configuration is a powerful new

198
00:13:55,810 --> 00:13:57,470
 

199
00:13:55,820 --> 00:13:59,570
 technique at the interface of machine

200
00:13:57,460 --> 00:13:59,570
 

201
00:13:57,470 --> 00:14:02,510
 learning and optimization that makes it

202
00:13:59,560 --> 00:14:02,510
 

203
00:13:59,570 --> 00:14:04,100
 possible to design an algorithm using

204
00:14:02,500 --> 00:14:04,100
 

205
00:14:02,510 --> 00:14:06,260
 the kind of methodology that we think of

206
00:14:04,090 --> 00:14:06,260
 

207
00:14:04,100 --> 00:14:08,480
 in machine learning rather than using

208
00:14:06,250 --> 00:14:08,480
 

209
00:14:06,260 --> 00:14:10,240
 sort of people's heuristic intuitions

210
00:14:08,470 --> 00:14:10,240
 

211
00:14:08,480 --> 00:14:13,550
 about how a combinatorial optimization

212
00:14:10,230 --> 00:14:13,550
 

213
00:14:10,240 --> 00:14:17,390
 problem might work so that the kind of

214
00:14:13,540 --> 00:14:17,390
 

215
00:14:13,550 --> 00:14:20,150
 key idea is to let go of the mistaken

216
00:14:17,380 --> 00:14:20,150
 

217
00:14:17,390 --> 00:14:22,340
 idea that we as algorithm designers have

218
00:14:20,140 --> 00:14:22,340
 

219
00:14:20,150 --> 00:14:24,200
 good intuitions about what works and

220
00:14:22,330 --> 00:14:24,200
 

221
00:14:22,340 --> 00:14:27,710
 what doesn't in a big combinatorial

222
00:14:24,190 --> 00:14:27,710
 

223
00:14:24,200 --> 00:14:29,750
 space and instead to expose all of the

224
00:14:27,700 --> 00:14:29,750
 

225
00:14:27,710 --> 00:14:32,720
 potentially good ideas that we have as

226
00:14:29,740 --> 00:14:32,720
 

227
00:14:29,750 --> 00:14:35,390
 parameters thereby creating a huge

228
00:14:32,710 --> 00:14:35,390
 

229
00:14:32,720 --> 00:14:37,310
 design space of algorithms that is far

230
00:14:35,380 --> 00:14:37,310
 

231
00:14:35,390 --> 00:14:40,130
 too large and unwieldy to think about

232
00:14:37,300 --> 00:14:40,130
 

233
00:14:37,310 --> 00:14:43,520
 oneself and then to use automatic

234
00:14:40,120 --> 00:14:43,520
 

235
00:14:40,130 --> 00:14:47,030
 methods to search in that space and I

236
00:14:43,510 --> 00:14:47,030
 

237
00:14:43,520 --> 00:14:49,430
 think this domain is exciting for the

238
00:14:47,020 --> 00:14:49,430
 

239
00:14:47,030 --> 00:14:52,160
 ICML community both because many

240
00:14:49,420 --> 00:14:52,160
 

241
00:14:49,430 --> 00:14:54,320
 research challenges remain in making

242
00:14:52,150 --> 00:14:54,320
 

243
00:14:52,160 --> 00:14:56,750
 these methods better extending them to

244
00:14:54,310 --> 00:14:56,750
 

245
00:14:54,320 --> 00:14:59,450
 new domains and theoretically analyzing

246
00:14:56,740 --> 00:14:59,450
 

247
00:14:56,750 --> 00:15:02,060
 their properties and also because these

248
00:14:59,440 --> 00:15:02,060
 

249
00:14:59,450 --> 00:15:03,970
 tools which are open source and have

250
00:15:02,050 --> 00:15:03,970
 

251
00:15:02,060 --> 00:15:06,230
 been widely used at this point are

252
00:15:03,960 --> 00:15:06,230
 

253
00:15:03,970 --> 00:15:08,690
 easily applicable to practical problems

254
00:15:06,220 --> 00:15:08,690
 

255
00:15:06,230 --> 00:15:12,050
 and if you do anything that involves

256
00:15:08,680 --> 00:15:12,050
 

257
00:15:08,690 --> 00:15:15,020
 solving a an optimization problem in

258
00:15:12,040 --> 00:15:15,020
 

259
00:15:12,050 --> 00:15:17,350
 practice it's pretty likely that you can

260
00:15:15,010 --> 00:15:17,350
 

261
00:15:15,020 --> 00:15:20,180
 download and run some of the tools that

262
00:15:17,340 --> 00:15:20,180
 

263
00:15:17,350 --> 00:15:22,160
 that our group and others have made and

264
00:15:20,170 --> 00:15:22,160
 

265
00:15:20,180 --> 00:15:26,210
 just get better performance kind of out

266
00:15:22,150 --> 00:15:26,210
 

267
00:15:22,160 --> 00:15:27,620
 of the box so here's why I think it

268
00:15:26,200 --> 00:15:27,620
 

269
00:15:26,210 --> 00:15:30,440
 makes sense to think about algorithm

270
00:15:27,610 --> 00:15:30,440
 

271
00:15:27,620 --> 00:15:34,220
 designs as a hypothesis space I want to

272
00:15:30,430 --> 00:15:34,220
 

273
00:15:30,440 --> 00:15:36,320
 contrast the state of things in discrete

274
00:15:34,210 --> 00:15:36,320
 

275
00:15:34,220 --> 00:15:38,240
 optimization with the state of things in

276
00:15:36,310 --> 00:15:38,240
 

277
00:15:36,320 --> 00:15:41,720
 just sort of classical machine learning

278
00:15:38,230 --> 00:15:41,720
 

279
00:15:38,240 --> 00:15:44,320
 so you know back in the day when these

280
00:15:41,710 --> 00:15:44,320
 

281
00:15:41,720 --> 00:15:46,460
 the nerves and ICML conferences began

282
00:15:44,310 --> 00:15:46,460
 

283
00:15:44,320 --> 00:15:48,410
 the way people thought about machine

284
00:15:46,450 --> 00:15:48,410
 

285
00:15:46,460 --> 00:15:50,450
 learning was to identify a set of

286
00:15:48,400 --> 00:15:50,450
 

287
00:15:48,410 --> 00:15:51,170
 features based on some kind of expert

288
00:15:50,440 --> 00:15:51,170
 

289
00:15:50,450 --> 00:15:52,579
 insights and

290
00:15:51,160 --> 00:15:52,579
 

291
00:15:51,170 --> 00:15:55,279
 kind of sense of what what was going to

292
00:15:52,569 --> 00:15:55,279
 

293
00:15:52,579 --> 00:15:57,230
 be important about a domain to select

294
00:15:55,269 --> 00:15:57,230
 

295
00:15:55,279 --> 00:15:59,720
 some model family by hand you know you

296
00:15:57,220 --> 00:15:59,720
 

297
00:15:57,230 --> 00:16:00,889
 would go to the latest ICML tutorials

298
00:15:59,710 --> 00:16:00,889
 

299
00:15:59,720 --> 00:16:02,660
 and you would find out that support

300
00:16:00,879 --> 00:16:02,660
 

301
00:16:00,889 --> 00:16:04,490
 vector machines were really exciting and

302
00:16:02,650 --> 00:16:04,490
 

303
00:16:02,660 --> 00:16:05,870
 then you would find out there was some

304
00:16:04,480 --> 00:16:05,870
 

305
00:16:04,490 --> 00:16:07,190
 hyper parameters and so you would kind

306
00:16:05,860 --> 00:16:07,190
 

307
00:16:05,870 --> 00:16:09,800
 of Natalee it manually twiddle with

308
00:16:07,180 --> 00:16:09,800
 

309
00:16:07,190 --> 00:16:11,240
 those hyper parameters of course that's

310
00:16:09,790 --> 00:16:11,240
 

311
00:16:09,800 --> 00:16:14,449
 not the way people think about machine

312
00:16:11,230 --> 00:16:14,449
 

313
00:16:11,240 --> 00:16:16,250
 learning much anymore we've moved to a

314
00:16:14,439 --> 00:16:16,250
 

315
00:16:14,449 --> 00:16:18,949
 paradigm of having very highly

316
00:16:16,240 --> 00:16:18,949
 

317
00:16:16,250 --> 00:16:20,630
 parameterised models where we really

318
00:16:18,939 --> 00:16:20,630
 

319
00:16:18,949 --> 00:16:23,209
 de-emphasize the idea of relying on

320
00:16:20,620 --> 00:16:23,209
 

321
00:16:20,630 --> 00:16:24,860
 expert knowledge but instead we try to

322
00:16:23,199 --> 00:16:24,860
 

323
00:16:23,209 --> 00:16:27,709
 only use that kind of knowledge to

324
00:16:24,850 --> 00:16:27,709
 

325
00:16:24,860 --> 00:16:29,360
 identify important in variances in the

326
00:16:27,699 --> 00:16:29,360
 

327
00:16:27,709 --> 00:16:32,180
 problem like a convolutional structure

328
00:16:29,350 --> 00:16:32,180
 

329
00:16:29,360 --> 00:16:33,829
 or model biases we want to put in we

330
00:16:32,170 --> 00:16:33,829
 

331
00:16:32,180 --> 00:16:36,139
 make these models deep in the sense that

332
00:16:33,819 --> 00:16:36,139
 

333
00:16:33,829 --> 00:16:38,480
 they have many layers of parameters each

334
00:16:36,129 --> 00:16:38,480
 

335
00:16:36,139 --> 00:16:40,339
 of which depend on the previous ones and

336
00:16:38,470 --> 00:16:40,339
 

337
00:16:38,480 --> 00:16:43,190
 then we we handle the fact that we have

338
00:16:40,329 --> 00:16:43,190
 

339
00:16:40,339 --> 00:16:46,820
 such an enormous highly parametrized

340
00:16:43,180 --> 00:16:46,820
 

341
00:16:43,190 --> 00:16:48,980
 model by having a lot of data plus maybe

342
00:16:46,810 --> 00:16:48,980
 

343
00:16:46,820 --> 00:16:51,920
 some ideas about regularization to avoid

344
00:16:48,970 --> 00:16:51,920
 

345
00:16:48,980 --> 00:16:54,170
 overfitting and we handled the fact that

346
00:16:51,910 --> 00:16:54,170
 

347
00:16:51,920 --> 00:16:56,930
 this is such a humongous computational

348
00:16:54,160 --> 00:16:56,930
 

349
00:16:54,170 --> 00:16:58,850
 problem to then fit such a model by not

350
00:16:56,920 --> 00:16:58,850
 

351
00:16:56,930 --> 00:17:00,829
 worrying about it we just have

352
00:16:58,840 --> 00:17:00,829
 

353
00:16:58,850 --> 00:17:02,720
 tremendous amounts of computation and we

354
00:17:00,819 --> 00:17:02,720
 

355
00:17:00,829 --> 00:17:04,910
 just bite the bullet and optimize the

356
00:17:02,710 --> 00:17:04,910
 

357
00:17:02,720 --> 00:17:07,419
 model and and this whole paradigm as

358
00:17:04,900 --> 00:17:07,419
 

359
00:17:04,910 --> 00:17:10,040
 everyone here knows works really well

360
00:17:07,409 --> 00:17:10,040
 

361
00:17:07,419 --> 00:17:12,439
 well in discrete optimization the way

362
00:17:10,030 --> 00:17:12,439
 

363
00:17:10,040 --> 00:17:14,890
 most people if you had to solve a

364
00:17:12,429 --> 00:17:14,890
 

365
00:17:12,439 --> 00:17:16,939
 Traveling Salesman problem or a

366
00:17:14,880 --> 00:17:16,939
 

367
00:17:14,890 --> 00:17:19,400
 satisfiability problem or a mixed

368
00:17:16,929 --> 00:17:19,400
 

369
00:17:16,939 --> 00:17:21,890
 integer program the way those kinds of

370
00:17:19,390 --> 00:17:21,890
 

371
00:17:19,400 --> 00:17:23,329
 algorithms tend to get designed looks a

372
00:17:21,880 --> 00:17:23,329
 

373
00:17:21,890 --> 00:17:25,549
 lot like the classical approach in

374
00:17:23,319 --> 00:17:25,549
 

375
00:17:23,329 --> 00:17:28,189
 machine learning so an expert thinks

376
00:17:25,539 --> 00:17:28,189
 

377
00:17:25,549 --> 00:17:29,929
 hard about and how a heuristic algorithm

378
00:17:28,179 --> 00:17:29,929
 

379
00:17:28,189 --> 00:17:32,270
 might work well they have some good

380
00:17:29,919 --> 00:17:32,270
 

381
00:17:29,929 --> 00:17:33,770
 ideas they read some papers and then

382
00:17:32,260 --> 00:17:33,770
 

383
00:17:32,270 --> 00:17:35,570
 they iteratively conduct small

384
00:17:33,760 --> 00:17:35,570
 

385
00:17:33,770 --> 00:17:37,730
 experiments maybe on the domain of

386
00:17:35,560 --> 00:17:37,730
 

387
00:17:35,570 --> 00:17:40,730
 interest and improve the design

388
00:17:37,720 --> 00:17:40,730
 

389
00:17:37,730 --> 00:17:41,870
 iteratively until the ICML deadline at

390
00:17:40,720 --> 00:17:41,870
 

391
00:17:40,730 --> 00:17:45,679
 which point they lock in whatever

392
00:17:41,860 --> 00:17:45,679
 

393
00:17:41,870 --> 00:17:47,299
 they've got and they submit it I want to

394
00:17:45,669 --> 00:17:47,299
 

395
00:17:45,679 --> 00:17:49,990
 argue that we should think about

396
00:17:47,289 --> 00:17:49,990
 

397
00:17:47,299 --> 00:17:52,309
 designing combinatorial optimization

398
00:17:49,980 --> 00:17:52,309
 

399
00:17:49,990 --> 00:17:55,160
 algorithms in the same way that we think

400
00:17:52,299 --> 00:17:55,160
 

401
00:17:52,309 --> 00:17:57,020
 now about doing machine learning so I

402
00:17:55,150 --> 00:17:57,020
 

403
00:17:55,160 --> 00:17:58,700
 think we should come up with algorithms

404
00:17:57,010 --> 00:17:58,700
 

405
00:17:57,020 --> 00:18:01,730
 which represent very highly

406
00:17:58,690 --> 00:18:01,730
 

407
00:17:58,700 --> 00:18:03,640
 parameterised design spaces of different

408
00:18:01,720 --> 00:18:03,640
 

409
00:18:01,730 --> 00:18:06,610
 heuristic design choices that might make

410
00:18:03,630 --> 00:18:06,610
 

411
00:18:03,640 --> 00:18:08,980
 sense to an expert these design spaces

412
00:18:06,600 --> 00:18:08,980
 

413
00:18:06,610 --> 00:18:10,780
 should be deep just as our motto machine

414
00:18:08,970 --> 00:18:10,780
 

415
00:18:08,980 --> 00:18:12,970
 learning models are deep in the sense

416
00:18:10,770 --> 00:18:12,970
 

417
00:18:10,780 --> 00:18:15,580
 that we expose many levels of parameters

418
00:18:12,960 --> 00:18:15,580
 

419
00:18:12,970 --> 00:18:17,560
 each level of which depends on the

420
00:18:15,570 --> 00:18:17,560
 

421
00:18:15,580 --> 00:18:21,310
 values of parameters that were set at

422
00:18:17,550 --> 00:18:21,310
 

423
00:18:17,560 --> 00:18:23,710
 higher levels we again should think

424
00:18:21,300 --> 00:18:23,710
 

425
00:18:21,310 --> 00:18:25,900
 about this as as fitting to a data

426
00:18:23,700 --> 00:18:25,900
 

427
00:18:23,710 --> 00:18:27,340
 distribution here the distribution that

428
00:18:25,890 --> 00:18:27,340
 

429
00:18:25,900 --> 00:18:29,830
 we should care about is the distribution

430
00:18:27,330 --> 00:18:29,830
 

431
00:18:27,340 --> 00:18:31,510
 of problem instances on which we want to

432
00:18:29,820 --> 00:18:31,510
 

433
00:18:29,830 --> 00:18:33,700
 get good performance when we're doing

434
00:18:31,500 --> 00:18:33,700
 

435
00:18:31,510 --> 00:18:35,770
 combinatorial optimization in practice

436
00:18:33,690 --> 00:18:35,770
 

437
00:18:33,700 --> 00:18:37,360
 we don't care about coming up with some

438
00:18:35,760 --> 00:18:37,360
 

439
00:18:35,770 --> 00:18:39,340
 piece of code that can solve every

440
00:18:37,350 --> 00:18:39,340
 

441
00:18:37,360 --> 00:18:41,980
 problem in the world in fact we kind of

442
00:18:39,330 --> 00:18:41,980
 

443
00:18:39,340 --> 00:18:43,300
 know that we can't do that so instead we

444
00:18:41,970 --> 00:18:43,300
 

445
00:18:41,980 --> 00:18:45,100
 should try to come up with a piece of

446
00:18:43,290 --> 00:18:45,100
 

447
00:18:43,300 --> 00:18:46,930
 code that works really well on the

448
00:18:45,090 --> 00:18:46,930
 

449
00:18:45,100 --> 00:18:48,640
 problems we actually care about and if

450
00:18:46,920 --> 00:18:48,640
 

451
00:18:46,930 --> 00:18:50,890
 we face a different distribution of

452
00:18:48,630 --> 00:18:50,890
 

453
00:18:48,640 --> 00:18:54,100
 problems we should react amaizing up

454
00:18:50,880 --> 00:18:54,100
 

455
00:18:50,890 --> 00:18:56,440
 with a new piece of code and how should

456
00:18:54,090 --> 00:18:56,440
 

457
00:18:54,100 --> 00:18:59,590
 we you know having exposed this gigantic

458
00:18:56,430 --> 00:18:59,590
 

459
00:18:56,440 --> 00:19:01,780
 parameter space you know with all this

460
00:18:59,580 --> 00:19:01,780
 

461
00:18:59,590 --> 00:19:03,400
 conditionality and all this tons of data

462
00:19:01,770 --> 00:19:03,400
 

463
00:19:01,780 --> 00:19:05,320
 that we want to reason about how should

464
00:19:03,390 --> 00:19:05,320
 

465
00:19:03,400 --> 00:19:07,210
 we actually come up with a good point in

466
00:19:05,310 --> 00:19:07,210
 

467
00:19:05,320 --> 00:19:08,740
 that space well that's really what this

468
00:19:07,200 --> 00:19:08,740
 

469
00:19:07,210 --> 00:19:10,360
 tutorial is going to be about we're

470
00:19:08,730 --> 00:19:10,360
 

471
00:19:08,740 --> 00:19:13,000
 gonna kind of open the black box and

472
00:19:10,350 --> 00:19:13,000
 

473
00:19:10,360 --> 00:19:15,610
 talk about how those methods work today

474
00:19:12,990 --> 00:19:15,610
 

475
00:19:13,000 --> 00:19:16,870
 but the short answer is we should do the

476
00:19:15,600 --> 00:19:16,870
 

477
00:19:15,610 --> 00:19:19,510
 same thing that we do in machine

478
00:19:16,860 --> 00:19:19,510
 

479
00:19:16,870 --> 00:19:21,190
 learning we should bite the bullet we

480
00:19:19,500 --> 00:19:21,190
 

481
00:19:19,510 --> 00:19:23,050
 should recognize that computers have

482
00:19:21,180 --> 00:19:23,050
 

483
00:19:21,190 --> 00:19:26,320
 gotten a lot faster than they used to be

484
00:19:23,040 --> 00:19:26,320
 

485
00:19:23,050 --> 00:19:30,100
 and we should simply go ahead and an

486
00:19:26,310 --> 00:19:30,100
 

487
00:19:26,320 --> 00:19:32,260
 explore this space automatically so you

488
00:19:30,090 --> 00:19:32,260
 

489
00:19:30,100 --> 00:19:33,790
 know I talked about AI is never complete

490
00:19:32,250 --> 00:19:33,790
 

491
00:19:32,260 --> 00:19:36,190
 if it doesn't begin early on with a

492
00:19:33,780 --> 00:19:36,190
 

493
00:19:33,790 --> 00:19:39,340
 slide above Moore's Law so let me just

494
00:19:36,180 --> 00:19:39,340
 

495
00:19:36,190 --> 00:19:41,140
 quickly remind you that something

496
00:19:39,330 --> 00:19:41,140
 

497
00:19:39,340 --> 00:19:43,710
 counterintuitive has happened in

498
00:19:41,130 --> 00:19:43,710
 

499
00:19:41,140 --> 00:19:46,600
 computing since 2000

500
00:19:43,700 --> 00:19:46,600
 

501
00:19:43,710 --> 00:19:49,000
 you know our subjective experience of

502
00:19:46,590 --> 00:19:49,000
 

503
00:19:46,600 --> 00:19:51,160
 how fast computers are sort of plateaued

504
00:19:48,990 --> 00:19:51,160
 

505
00:19:49,000 --> 00:19:52,780
 around 2000 near the clock speeds of the

506
00:19:51,150 --> 00:19:52,780
 

507
00:19:51,160 --> 00:19:55,120
 the computers sitting on our desks in

508
00:19:52,770 --> 00:19:55,120
 

509
00:19:52,780 --> 00:19:57,880
 our laps you know haven't really changed

510
00:19:55,110 --> 00:19:57,880
 

511
00:19:55,120 --> 00:19:58,990
 for the last 20 years but the number of

512
00:19:57,870 --> 00:19:58,990
 

513
00:19:57,880 --> 00:20:01,360
 transistors on a chip

514
00:19:58,980 --> 00:20:01,360
 

515
00:19:58,990 --> 00:20:02,920
 you know surely physical laws will kick

516
00:20:01,350 --> 00:20:02,920
 

517
00:20:01,360 --> 00:20:04,210
 in at some point but they haven't kicked

518
00:20:02,910 --> 00:20:04,210
 

519
00:20:02,920 --> 00:20:06,880
 in yet we've really still been

520
00:20:04,200 --> 00:20:06,880
 

521
00:20:04,210 --> 00:20:09,340
 experiencing that exponential growth you

522
00:20:06,870 --> 00:20:09,340
 

523
00:20:06,880 --> 00:20:11,080
 know even up to the present day and that

524
00:20:09,330 --> 00:20:11,080
 

525
00:20:09,340 --> 00:20:13,570
 really has been realized as parallelism

526
00:20:11,070 --> 00:20:13,570
 

527
00:20:11,080 --> 00:20:15,610
 so it's now the case that we have access

528
00:20:13,560 --> 00:20:15,610
 

529
00:20:13,570 --> 00:20:16,930
 to cloud computing resources that are

530
00:20:15,600 --> 00:20:16,930
 

531
00:20:15,610 --> 00:20:18,880
 cheaper

532
00:20:16,920 --> 00:20:18,880
 

533
00:20:16,930 --> 00:20:21,280
 tremendously more parallel than they

534
00:20:18,870 --> 00:20:21,280
 

535
00:20:18,880 --> 00:20:23,500
 were one or two decades ago and what

536
00:20:21,270 --> 00:20:23,500
 

537
00:20:21,280 --> 00:20:25,900
 that means is that computational

538
00:20:23,490 --> 00:20:25,900
 

539
00:20:23,500 --> 00:20:28,240
 approaches that intuitively to us feel

540
00:20:25,890 --> 00:20:28,240
 

541
00:20:25,900 --> 00:20:30,580
 just crazy and stupid because they're so

542
00:20:28,230 --> 00:20:30,580
 

543
00:20:28,240 --> 00:20:32,530
 just profligate in the way that they use

544
00:20:30,570 --> 00:20:32,530
 

545
00:20:30,580 --> 00:20:34,990
 computational resources nevertheless

546
00:20:32,520 --> 00:20:34,990
 

547
00:20:32,530 --> 00:20:36,880
 make a tremendous amount of sense given

548
00:20:34,980 --> 00:20:36,880
 

549
00:20:34,990 --> 00:20:41,650
 this explosive growth in computational

550
00:20:36,870 --> 00:20:41,650
 

551
00:20:36,880 --> 00:20:43,810
 hardware so if we live in a world of

552
00:20:41,640 --> 00:20:43,810
 

553
00:20:41,650 --> 00:20:45,840
 learn about algorithms here's how

554
00:20:43,800 --> 00:20:45,840
 

555
00:20:43,810 --> 00:20:48,700
 designers ought to think differently

556
00:20:45,830 --> 00:20:48,700
 

557
00:20:45,840 --> 00:20:50,170
 they should shift from choosing

558
00:20:48,690 --> 00:20:50,170
 

559
00:20:48,700 --> 00:20:52,560
 heuristics that they think are gonna

560
00:20:50,160 --> 00:20:52,560
 

561
00:20:50,170 --> 00:20:55,990
 work well you know having some you know

562
00:20:52,550 --> 00:20:55,990
 

563
00:20:52,560 --> 00:20:58,060
 biological metaphor or some kind of you

564
00:20:55,980 --> 00:20:58,060
 

565
00:20:55,990 --> 00:20:59,770
 know nice back-of-the-envelope sketch of

566
00:20:58,050 --> 00:20:59,770
 

567
00:20:58,060 --> 00:21:02,110
 a proof about why some heuristic is a

568
00:20:59,760 --> 00:21:02,110
 

569
00:20:59,770 --> 00:21:06,010
 good idea and this should move instead

570
00:21:02,100 --> 00:21:06,010
 

571
00:21:02,110 --> 00:21:07,780
 towards collecting all of the different

572
00:21:06,000 --> 00:21:07,780
 

573
00:21:06,010 --> 00:21:10,390
 good heuristic ideas that they can find

574
00:21:07,770 --> 00:21:10,390
 

575
00:21:07,780 --> 00:21:12,160
 out about at exposing this wide variety

576
00:21:10,380 --> 00:21:12,160
 

577
00:21:10,390 --> 00:21:16,030
 of design elements that might be

578
00:21:12,150 --> 00:21:16,030
 

579
00:21:12,160 --> 00:21:18,940
 sensible they can get out of the

580
00:21:16,020 --> 00:21:18,940
 

581
00:21:16,030 --> 00:21:21,580
 business therefore of experimenting

582
00:21:18,930 --> 00:21:21,580
 

583
00:21:18,940 --> 00:21:23,410
 manually so they should stop this kind

584
00:21:21,570 --> 00:21:23,410
 

585
00:21:21,580 --> 00:21:25,420
 of workflow where you change one thing

586
00:21:23,400 --> 00:21:25,420
 

587
00:21:23,410 --> 00:21:26,710
 and then you run some small experiments

588
00:21:25,410 --> 00:21:26,710
 

589
00:21:25,420 --> 00:21:29,380
 and your laptop and you see whether

590
00:21:26,700 --> 00:21:29,380
 

591
00:21:26,710 --> 00:21:30,970
 things got faster because that that

592
00:21:29,370 --> 00:21:30,970
 

593
00:21:29,380 --> 00:21:32,520
 amounts to doing coordinate descent and

594
00:21:30,960 --> 00:21:32,520
 

595
00:21:30,970 --> 00:21:35,080
 we know that that's not a very effective

596
00:21:32,510 --> 00:21:35,080
 

597
00:21:32,520 --> 00:21:37,930
 search strategy in a combinatorial space

598
00:21:35,070 --> 00:21:37,930
 

599
00:21:35,080 --> 00:21:39,940
 they should instead just allow an

600
00:21:37,920 --> 00:21:39,940
 

601
00:21:37,930 --> 00:21:41,980
 automated procedure to do much fancier

602
00:21:39,930 --> 00:21:41,980
 

603
00:21:39,940 --> 00:21:45,520
 things to search these big spaces that

604
00:21:41,970 --> 00:21:45,520
 

605
00:21:41,980 --> 00:21:47,590
 get exposed and they should let go of

606
00:21:45,510 --> 00:21:47,590
 

607
00:21:45,520 --> 00:21:50,920
 the idea that there's such a thing as a

608
00:21:47,580 --> 00:21:50,920
 

609
00:21:47,590 --> 00:21:52,240
 great heuristic algorithm overall that's

610
00:21:50,910 --> 00:21:52,240
 

611
00:21:50,920 --> 00:21:54,130
 sort of like saying there's a great

612
00:21:52,230 --> 00:21:54,130
 

613
00:21:52,240 --> 00:21:56,500
 trained machine learning model overall

614
00:21:54,120 --> 00:21:56,500
 

615
00:21:54,130 --> 00:21:58,420
 sometimes there is you know sometimes

616
00:21:56,490 --> 00:21:58,420
 

617
00:21:56,500 --> 00:22:01,330
 there's surprisingly robust models but

618
00:21:58,410 --> 00:22:01,330
 

619
00:21:58,420 --> 00:22:03,640
 it's easy always to find some new

620
00:22:01,320 --> 00:22:03,640
 

621
00:22:01,330 --> 00:22:05,050
 distribution where an existing models

622
00:22:03,630 --> 00:22:05,050
 

623
00:22:03,640 --> 00:22:06,940
 not going to do well and then of course

624
00:22:05,040 --> 00:22:06,940
 

625
00:22:05,050 --> 00:22:08,920
 you just retrain it and we should think

626
00:22:06,930 --> 00:22:08,920
 

627
00:22:06,940 --> 00:22:10,480
 the same way about heuristic algorithms

628
00:22:08,910 --> 00:22:10,480
 

629
00:22:08,920 --> 00:22:15,220
 we should think about retraining them to

630
00:22:10,470 --> 00:22:15,220
 

631
00:22:10,480 --> 00:22:17,410
 new workloads so here's a very

632
00:22:15,210 --> 00:22:17,410
 

633
00:22:15,220 --> 00:22:20,220
 high-level example of how this can look

634
00:22:17,400 --> 00:22:20,220
 

635
00:22:17,410 --> 00:22:22,660
 here's a framework that my group

636
00:22:20,210 --> 00:22:22,660
 

637
00:22:20,220 --> 00:22:24,790
 designed about ten years ago which we

638
00:22:22,650 --> 00:22:24,790
 

639
00:22:22,660 --> 00:22:27,520
 called satin Stein it's a kind of

640
00:22:24,780 --> 00:22:27,520
 

641
00:22:24,790 --> 00:22:29,520
 tongue-in-cheek story so as you probably

642
00:22:27,510 --> 00:22:29,520
 

643
00:22:27,520 --> 00:22:31,950
 know Frankenstein who

644
00:22:29,510 --> 00:22:31,950
 

645
00:22:29,520 --> 00:22:36,330
 was the doctor not the monster pictured

646
00:22:31,940 --> 00:22:36,330
 

647
00:22:31,950 --> 00:22:38,550
 here and had this goal in in the famous

648
00:22:36,320 --> 00:22:38,550
 

649
00:22:36,330 --> 00:22:41,580
 story of trying to create a perfect

650
00:22:38,540 --> 00:22:41,580
 

651
00:22:38,550 --> 00:22:42,990
 human from scavenged body parts it's not

652
00:22:41,570 --> 00:22:42,990
 

653
00:22:41,580 --> 00:22:46,170
 clear why he thought that was a good

654
00:22:42,980 --> 00:22:46,170
 

655
00:22:42,990 --> 00:22:48,720
 idea but nevertheless we decided that we

656
00:22:46,160 --> 00:22:48,720
 

657
00:22:46,170 --> 00:22:51,420
 had a similar goal which was to create a

658
00:22:48,710 --> 00:22:51,420
 

659
00:22:48,720 --> 00:22:53,670
 perfect high performance at solver by

660
00:22:51,410 --> 00:22:53,670
 

661
00:22:51,420 --> 00:22:56,040
 scavenging components from everywhere we

662
00:22:53,660 --> 00:22:56,040
 

663
00:22:53,670 --> 00:22:59,010
 could find them so we set out to build a

664
00:22:56,030 --> 00:22:59,010
 

665
00:22:56,040 --> 00:23:00,900
 piece of code that was just extremely

666
00:22:59,000 --> 00:23:00,900
 

667
00:22:59,010 --> 00:23:02,220
 modular and included all of the

668
00:23:00,890 --> 00:23:02,220
 

669
00:23:00,900 --> 00:23:04,890
 heuristic ideas that we could identify

670
00:23:02,210 --> 00:23:04,890
 

671
00:23:02,220 --> 00:23:07,560
 in the literature for how you would

672
00:23:04,880 --> 00:23:07,560
 

673
00:23:04,890 --> 00:23:09,690
 solve sat using local search we ended up

674
00:23:07,550 --> 00:23:09,690
 

675
00:23:07,560 --> 00:23:12,180
 with a design space that had three

676
00:23:09,680 --> 00:23:12,180
 

677
00:23:09,690 --> 00:23:14,520
 different levels of conditionality 41

678
00:23:12,170 --> 00:23:14,520
 

679
00:23:12,180 --> 00:23:16,080
 parameters total it was able to

680
00:23:14,510 --> 00:23:16,080
 

681
00:23:14,520 --> 00:23:18,930
 instantiate trillions of different

682
00:23:16,070 --> 00:23:18,930
 

683
00:23:16,080 --> 00:23:20,010
 solver strategies and and we benchmarked

684
00:23:18,920 --> 00:23:20,010
 

685
00:23:18,930 --> 00:23:22,440
 it to make sure that it could represent

686
00:23:20,000 --> 00:23:22,440
 

687
00:23:20,010 --> 00:23:24,360
 at least 29 different distinct

688
00:23:22,430 --> 00:23:24,360
 

689
00:23:22,440 --> 00:23:25,440
 high-performance solvers from the

690
00:23:24,350 --> 00:23:25,440
 

691
00:23:24,360 --> 00:23:29,340
 literature that people had kind of

692
00:23:25,430 --> 00:23:29,340
 

693
00:23:25,440 --> 00:23:31,560
 individually proposed and overall here's

694
00:23:29,330 --> 00:23:31,560
 

695
00:23:29,340 --> 00:23:33,720
 how it did on six different benchmarks

696
00:23:31,550 --> 00:23:33,720
 

697
00:23:31,560 --> 00:23:38,010
 you know reconfigured at each time as

698
00:23:33,710 --> 00:23:38,010
 

699
00:23:33,720 --> 00:23:39,510
 compared to eleven sort of high

700
00:23:38,000 --> 00:23:39,510
 

701
00:23:38,010 --> 00:23:41,130
 performance local search solvers that

702
00:23:39,500 --> 00:23:41,130
 

703
00:23:39,510 --> 00:23:42,930
 people cared about in the literature

704
00:23:41,120 --> 00:23:42,930
 

705
00:23:41,130 --> 00:23:45,390
 this is on a log scale so that the

706
00:23:42,920 --> 00:23:45,390
 

707
00:23:42,930 --> 00:23:47,610
 differences are pretty big red is of

708
00:23:45,380 --> 00:23:47,610
 

709
00:23:45,390 --> 00:23:50,250
 course our method and gray is all the

710
00:23:47,600 --> 00:23:50,250
 

711
00:23:47,610 --> 00:23:51,540
 other ones and these distributions are

712
00:23:50,240 --> 00:23:51,540
 

713
00:23:50,250 --> 00:23:52,800
 really really different from each other

714
00:23:51,530 --> 00:23:52,800
 

715
00:23:51,540 --> 00:23:55,470
 it doesn't matter if you know what they

716
00:23:52,790 --> 00:23:55,470
 

717
00:23:52,800 --> 00:23:57,390
 are but some of them are kind of graph

718
00:23:55,460 --> 00:23:57,390
 

719
00:23:55,470 --> 00:23:58,650
 problems some of them are random and

720
00:23:57,380 --> 00:23:58,650
 

721
00:23:57,390 --> 00:24:01,440
 some of them come from industrial

722
00:23:58,640 --> 00:24:01,440
 

723
00:23:58,650 --> 00:24:03,750
 applications and you can see overall it

724
00:24:01,430 --> 00:24:03,750
 

725
00:24:01,440 --> 00:24:05,730
 was the best among all of the different

726
00:24:03,740 --> 00:24:05,730
 

727
00:24:03,750 --> 00:24:07,350
 methods each time and sometimes it was

728
00:24:05,720 --> 00:24:07,350
 

729
00:24:05,730 --> 00:24:09,510
 just ridiculously better than anything

730
00:24:07,340 --> 00:24:09,510
 

731
00:24:07,350 --> 00:24:11,340
 else so it was going from problems that

732
00:24:09,500 --> 00:24:11,340
 

733
00:24:09,510 --> 00:24:13,310
 took many hundreds of seconds for the

734
00:24:11,330 --> 00:24:13,310
 

735
00:24:11,340 --> 00:24:16,440
 best method down to a couple of seconds

736
00:24:13,300 --> 00:24:16,440
 

737
00:24:13,310 --> 00:24:18,090
 and this is the promise of algorithm

738
00:24:16,430 --> 00:24:18,090
 

739
00:24:16,440 --> 00:24:20,070
 configuration we've seen this kind of

740
00:24:18,080 --> 00:24:20,070
 

741
00:24:18,090 --> 00:24:21,720
 performance just over and over again

742
00:24:20,060 --> 00:24:21,720
 

743
00:24:20,070 --> 00:24:24,810
 when we've applied these methods to

744
00:24:21,710 --> 00:24:24,810
 

745
00:24:21,720 --> 00:24:26,820
 different settings so let me say a

746
00:24:24,800 --> 00:24:26,820
 

747
00:24:24,810 --> 00:24:28,770
 little bit more formally the algorithm

748
00:24:26,810 --> 00:24:28,770
 

749
00:24:26,820 --> 00:24:30,000
 configuration problem that we're going

750
00:24:28,760 --> 00:24:30,000
 

751
00:24:28,770 --> 00:24:32,760
 to think about throughout this tutorial

752
00:24:29,990 --> 00:24:32,760
 

753
00:24:30,000 --> 00:24:35,940
 until we get to Frank's last section on

754
00:24:32,750 --> 00:24:35,940
 

755
00:24:32,760 --> 00:24:37,260
 related problems where he scoped out and

756
00:24:35,930 --> 00:24:37,260
 

757
00:24:35,940 --> 00:24:41,040
 think about some problems different from

758
00:24:37,250 --> 00:24:41,040
 

759
00:24:37,260 --> 00:24:43,330
 this one so broadly speaking we want to

760
00:24:41,030 --> 00:24:43,330
 

761
00:24:41,040 --> 00:24:45,850
 build a configurator which

762
00:24:43,320 --> 00:24:45,850
 

763
00:24:43,330 --> 00:24:47,440
 is what you might call a meta algorithm

764
00:24:45,840 --> 00:24:47,440
 

765
00:24:45,850 --> 00:24:50,530
 in the sense that it takes another

766
00:24:47,430 --> 00:24:50,530
 

767
00:24:47,440 --> 00:24:52,150
 algorithm as one of its inputs so we

768
00:24:50,520 --> 00:24:52,150
 

769
00:24:50,530 --> 00:24:54,130
 want to have this piece of code that you

770
00:24:52,140 --> 00:24:54,130
 

771
00:24:52,150 --> 00:24:55,780
 can you can give your own parametrized

772
00:24:54,120 --> 00:24:55,780
 

773
00:24:54,130 --> 00:24:58,330
 algorithm to and it's going to

774
00:24:55,770 --> 00:24:58,330
 

775
00:24:55,780 --> 00:25:00,550
 repeatedly probe your algorithm on

776
00:24:58,320 --> 00:25:00,550
 

777
00:24:58,330 --> 00:25:03,070
 problem instances from some distribution

778
00:25:00,540 --> 00:25:03,070
 

779
00:25:00,550 --> 00:25:06,070
 that you care about return how long the

780
00:25:03,060 --> 00:25:06,070
 

781
00:25:03,070 --> 00:25:07,600
 problem took to solve and then make some

782
00:25:06,060 --> 00:25:07,600
 

783
00:25:06,070 --> 00:25:10,180
 decision about what experiments to run

784
00:25:07,590 --> 00:25:10,180
 

785
00:25:07,600 --> 00:25:12,790
 next so it's basically an automated

786
00:25:10,170 --> 00:25:12,790
 

787
00:25:10,180 --> 00:25:15,850
 experimental design framework that

788
00:25:12,780 --> 00:25:15,850
 

789
00:25:12,790 --> 00:25:17,950
 reasons about running your algorithm and

790
00:25:15,840 --> 00:25:17,950
 

791
00:25:15,850 --> 00:25:22,000
 how well it does in different parts of

792
00:25:17,940 --> 00:25:22,000
 

793
00:25:17,950 --> 00:25:23,710
 the space it's worth thinking about what

794
00:25:21,990 --> 00:25:23,710
 

795
00:25:22,000 --> 00:25:26,830
 kinds of parameters we allow an

796
00:25:23,700 --> 00:25:26,830
 

797
00:25:23,710 --> 00:25:29,980
 algorithm to have and broadly speaking

798
00:25:26,820 --> 00:25:29,980
 

799
00:25:26,830 --> 00:25:31,960
 we allowed anything so you would imagine

800
00:25:29,970 --> 00:25:31,960
 

801
00:25:29,980 --> 00:25:34,210
 it's easiest to think about continuous

802
00:25:31,950 --> 00:25:34,210
 

803
00:25:31,960 --> 00:25:35,560
 parameters you know we there are lots of

804
00:25:34,200 --> 00:25:35,560
 

805
00:25:34,210 --> 00:25:37,510
 machine learning methods and convex

806
00:25:35,550 --> 00:25:37,510
 

807
00:25:35,560 --> 00:25:40,180
 optimization approaches that work best

808
00:25:37,500 --> 00:25:40,180
 

809
00:25:37,510 --> 00:25:42,370
 in continuous spaces and of course we

810
00:25:40,170 --> 00:25:42,370
 

811
00:25:40,180 --> 00:25:44,980
 can handle continuous spaces but we also

812
00:25:42,360 --> 00:25:44,980
 

813
00:25:42,370 --> 00:25:47,350
 allow for integer parameters ordinal

814
00:25:44,970 --> 00:25:47,350
 

815
00:25:44,980 --> 00:25:50,440
 parameters categorical parameters that

816
00:25:47,340 --> 00:25:50,440
 

817
00:25:47,350 --> 00:25:52,570
 have some unordered finite domain many

818
00:25:50,430 --> 00:25:52,570
 

819
00:25:50,440 --> 00:25:54,580
 categorical parameters in practice end

820
00:25:52,560 --> 00:25:54,580
 

821
00:25:52,570 --> 00:25:56,500
 up being sort of switches like should I

822
00:25:54,570 --> 00:25:56,500
 

823
00:25:54,580 --> 00:25:58,180
 turn this mechanism on or turn it off

824
00:25:56,490 --> 00:25:58,180
 

825
00:25:56,500 --> 00:26:00,370
 where we would expect really

826
00:25:58,170 --> 00:26:00,370
 

827
00:25:58,180 --> 00:26:03,280
 discontinuous behavior as we change the

828
00:26:00,360 --> 00:26:03,280
 

829
00:26:00,370 --> 00:26:04,870
 value of that switch and of course

830
00:26:03,270 --> 00:26:04,870
 

831
00:26:03,280 --> 00:26:07,330
 conditional parameters where the

832
00:26:04,860 --> 00:26:07,330
 

833
00:26:04,870 --> 00:26:09,280
 parameter only has meaning given the

834
00:26:07,320 --> 00:26:09,280
 

835
00:26:07,330 --> 00:26:12,150
 value of some parent parameters so I

836
00:26:09,270 --> 00:26:12,150
 

837
00:26:09,280 --> 00:26:14,080
 might for example have a random restart

838
00:26:12,140 --> 00:26:14,080
 

839
00:26:12,150 --> 00:26:15,760
 mechanism and I might have a parameter

840
00:26:14,070 --> 00:26:15,760
 

841
00:26:14,080 --> 00:26:17,440
 that says should I turn it on or off and

842
00:26:15,750 --> 00:26:17,440
 

843
00:26:15,760 --> 00:26:19,690
 then I have another parameter that says

844
00:26:17,430 --> 00:26:19,690
 

845
00:26:17,440 --> 00:26:21,460
 should the random restarts be local or

846
00:26:19,680 --> 00:26:21,460
 

847
00:26:19,690 --> 00:26:23,110
 should they be global and then I could

848
00:26:21,450 --> 00:26:23,110
 

849
00:26:21,460 --> 00:26:24,640
 have another parameter that's

850
00:26:23,100 --> 00:26:24,640
 

851
00:26:23,110 --> 00:26:26,080
 conditional on that that says what is

852
00:26:24,630 --> 00:26:26,080
 

853
00:26:24,640 --> 00:26:27,460
 the probability according to which I

854
00:26:26,070 --> 00:26:27,460
 

855
00:26:26,080 --> 00:26:30,700
 should do this sampling for a local

856
00:26:27,450 --> 00:26:30,700
 

857
00:26:27,460 --> 00:26:32,830
 restart overall we want to think about

858
00:26:30,690 --> 00:26:32,830
 

859
00:26:30,700 --> 00:26:34,990
 parameters giving rise to really

860
00:26:32,820 --> 00:26:34,990
 

861
00:26:32,830 --> 00:26:37,600
 enormous and structured spaces of

862
00:26:34,980 --> 00:26:37,600
 

863
00:26:34,990 --> 00:26:40,420
 configurations so in practice we've

864
00:26:37,590 --> 00:26:40,420
 

865
00:26:37,600 --> 00:26:43,210
 configured spaces that have on the order

866
00:26:40,410 --> 00:26:43,210
 

867
00:26:40,420 --> 00:26:45,130
 of 10 to the 950 configurations so

868
00:26:43,200 --> 00:26:45,130
 

869
00:26:43,210 --> 00:26:47,380
 really really enormous combinatorial

870
00:26:45,120 --> 00:26:47,380
 

871
00:26:45,130 --> 00:26:49,720
 spaces and in settings where we have a

872
00:26:47,370 --> 00:26:49,720
 

873
00:26:47,380 --> 00:26:51,760
 lot of these boolean kinds of parameters

874
00:26:49,710 --> 00:26:51,760
 

875
00:26:49,720 --> 00:26:53,350
 we're changing the value of one

876
00:26:51,750 --> 00:26:53,350
 

877
00:26:51,760 --> 00:26:55,180
 parameter might lead to really

878
00:26:53,340 --> 00:26:55,180
 

879
00:26:53,350 --> 00:26:55,850
 qualitatively different behavior for the

880
00:26:55,170 --> 00:26:55,850
 

881
00:26:55,180 --> 00:26:57,380
 algorithms

882
00:26:55,840 --> 00:26:57,380
 

883
00:26:55,850 --> 00:26:59,480
 we're not going to make some kind of

884
00:26:57,370 --> 00:26:59,480
 

885
00:26:57,380 --> 00:27:01,250
 smoothness or continuity assumptions

886
00:26:59,470 --> 00:27:01,250
 

887
00:26:59,480 --> 00:27:02,930
 about how parameters work because in

888
00:27:01,240 --> 00:27:02,930
 

889
00:27:01,250 --> 00:27:05,450
 practice they just don't exhibit that

890
00:27:02,920 --> 00:27:05,450
 

891
00:27:02,930 --> 00:27:06,770
 kind of smoothness and for what it's

892
00:27:05,440 --> 00:27:06,770
 

893
00:27:05,450 --> 00:27:08,720
 worth that's why we use the term

894
00:27:06,760 --> 00:27:08,720
 

895
00:27:06,770 --> 00:27:10,820
 algorithm configuration rather than

896
00:27:08,710 --> 00:27:10,820
 

897
00:27:08,720 --> 00:27:12,410
 parameter tuning I mean if you like you

898
00:27:10,810 --> 00:27:12,410
 

899
00:27:10,820 --> 00:27:15,110
 can think all of all of this as being

900
00:27:12,400 --> 00:27:15,110
 

901
00:27:12,410 --> 00:27:17,030
 parameter tuning but that sort of evokes

902
00:27:15,100 --> 00:27:17,030
 

903
00:27:15,110 --> 00:27:19,460
 the notion of one or two pretty

904
00:27:17,020 --> 00:27:19,460
 

905
00:27:17,030 --> 00:27:22,340
 well-behaved parameters rather than you

906
00:27:19,450 --> 00:27:22,340
 

907
00:27:19,460 --> 00:27:24,170
 know hundreds of really unstable

908
00:27:22,330 --> 00:27:24,170
 

909
00:27:22,340 --> 00:27:26,210
 discontinuous parameters some of which

910
00:27:24,160 --> 00:27:26,210
 

911
00:27:24,170 --> 00:27:27,470
 are discrete or conditional so that's

912
00:27:26,200 --> 00:27:27,470
 

913
00:27:26,210 --> 00:27:28,940
 why we're using a different term and why

914
00:27:27,460 --> 00:27:28,940
 

915
00:27:27,470 --> 00:27:32,300
 that the literature has adopted this

916
00:27:28,930 --> 00:27:32,300
 

917
00:27:28,940 --> 00:27:35,030
 different term so here's the the

918
00:27:32,290 --> 00:27:35,030
 

919
00:27:32,300 --> 00:27:36,680
 definition that I'm gonna stick to

920
00:27:35,020 --> 00:27:36,680
 

921
00:27:35,030 --> 00:27:38,530
 through the rest of this talk and the

922
00:27:36,670 --> 00:27:38,530
 

923
00:27:36,680 --> 00:27:41,090
 notation that we're gonna use throughout

924
00:27:38,520 --> 00:27:41,090
 

925
00:27:38,530 --> 00:27:44,000
 so we're going to imagine that we're

926
00:27:41,080 --> 00:27:44,000
 

927
00:27:41,090 --> 00:27:46,760
 given a parameterised algorithm script a

928
00:27:43,990 --> 00:27:46,760
 

929
00:27:44,000 --> 00:27:49,700
 and it will have a parameter

930
00:27:46,750 --> 00:27:49,700
 

931
00:27:46,760 --> 00:27:53,570
 configuration space capital theta which

932
00:27:49,690 --> 00:27:53,570
 

933
00:27:49,700 --> 00:27:55,910
 is may be uncountably infinite may be

934
00:27:53,560 --> 00:27:55,910
 

935
00:27:53,570 --> 00:27:57,830
 finite it doesn't matter we're also

936
00:27:55,900 --> 00:27:57,830
 

937
00:27:55,910 --> 00:28:00,380
 going to be given a distribution over

938
00:27:57,820 --> 00:28:00,380
 

939
00:27:57,830 --> 00:28:02,990
 problem instances usually we're going to

940
00:28:00,370 --> 00:28:02,990
 

941
00:28:00,380 --> 00:28:06,110
 receive this distribution as a bunch of

942
00:28:02,980 --> 00:28:06,110
 

943
00:28:02,990 --> 00:28:07,940
 samples from an actual generating

944
00:28:06,100 --> 00:28:07,940
 

945
00:28:06,110 --> 00:28:09,920
 process that we don't get to observe you

946
00:28:07,930 --> 00:28:09,920
 

947
00:28:07,940 --> 00:28:11,420
 know you can think of it as Walmart

948
00:28:09,910 --> 00:28:11,420
 

949
00:28:09,920 --> 00:28:13,370
 wants me to solve their vehicle routing

950
00:28:11,410 --> 00:28:13,370
 

951
00:28:11,420 --> 00:28:15,260
 problem and they give me 10,000 examples

952
00:28:13,360 --> 00:28:15,260
 

953
00:28:13,370 --> 00:28:18,140
 of vehicle routing problems they've seen

954
00:28:15,250 --> 00:28:18,140
 

955
00:28:15,260 --> 00:28:19,820
 in the past you could also imagine that

956
00:28:18,130 --> 00:28:19,820
 

957
00:28:18,140 --> 00:28:23,350
 it's a generator that I can probe

958
00:28:19,810 --> 00:28:23,350
 

959
00:28:19,820 --> 00:28:25,730
 arbitrary amounts of time if you prefer

960
00:28:23,340 --> 00:28:25,730
 

961
00:28:23,350 --> 00:28:27,980
 something really critical about this

962
00:28:25,720 --> 00:28:27,980
 

963
00:28:25,730 --> 00:28:31,010
 problem that will be unfamiliar to you

964
00:28:27,970 --> 00:28:31,010
 

965
00:28:27,980 --> 00:28:33,980
 if you're if you think about you know

966
00:28:31,000 --> 00:28:33,980
 

967
00:28:31,010 --> 00:28:36,980
 related but different kinds of of

968
00:28:33,970 --> 00:28:36,980
 

969
00:28:33,980 --> 00:28:39,920
 technical problems is the use of a

970
00:28:36,970 --> 00:28:39,920
 

971
00:28:36,980 --> 00:28:41,750
 cut-off time so it's usually the case in

972
00:28:39,910 --> 00:28:41,750
 

973
00:28:39,920 --> 00:28:44,150
 combinatorial optimization that run time

974
00:28:41,740 --> 00:28:44,150
 

975
00:28:41,750 --> 00:28:46,340
 distributions are exponential and what

976
00:28:44,140 --> 00:28:46,340
 

977
00:28:44,150 --> 00:28:48,080
 that means is almost without a doubt

978
00:28:46,330 --> 00:28:48,080
 

979
00:28:46,340 --> 00:28:51,880
 we're going to encounter runs that take

980
00:28:48,070 --> 00:28:51,880
 

981
00:28:48,080 --> 00:28:54,260
 too long to finish even on arbitrarily

982
00:28:51,870 --> 00:28:54,260
 

983
00:28:51,880 --> 00:28:56,510
 parallel and normos compute clusters you

984
00:28:54,250 --> 00:28:56,510
 

985
00:28:54,260 --> 00:28:58,460
 know we can easily run into individual

986
00:28:56,500 --> 00:28:58,460
 

987
00:28:56,510 --> 00:29:00,440
 algorithm runs which you know correspond

988
00:28:58,450 --> 00:29:00,440
 

989
00:28:58,460 --> 00:29:02,900
 to single data points for us that take

990
00:29:00,430 --> 00:29:02,900
 

991
00:29:00,440 --> 00:29:05,360
 weeks or months to complete and so for

992
00:29:02,890 --> 00:29:05,360
 

993
00:29:02,900 --> 00:29:07,220
 this to make any sense we need to come

994
00:29:05,350 --> 00:29:07,220
 

995
00:29:05,360 --> 00:29:08,000
 up with some amount of time where we're

996
00:29:07,210 --> 00:29:08,000
 

997
00:29:07,220 --> 00:29:10,010
 just going to cut the

998
00:29:07,990 --> 00:29:10,010
 

999
00:29:08,000 --> 00:29:12,410
 them off and say it didn't it didn't

1000
00:29:10,000 --> 00:29:12,410
 

1001
00:29:10,010 --> 00:29:13,760
 finish too bad maybe that's gonna be a

1002
00:29:12,400 --> 00:29:13,760
 

1003
00:29:12,410 --> 00:29:15,500
 day or something think you think about

1004
00:29:13,750 --> 00:29:15,500
 

1005
00:29:13,760 --> 00:29:18,170
 some long but not infinite amount of

1006
00:29:15,490 --> 00:29:18,170
 

1007
00:29:15,500 --> 00:29:20,810
 time and then we're gonna have a cost

1008
00:29:18,160 --> 00:29:20,810
 

1009
00:29:18,170 --> 00:29:23,030
 function that says how do I feel about

1010
00:29:20,800 --> 00:29:23,030
 

1011
00:29:20,810 --> 00:29:24,230
 what happened so if I take some

1012
00:29:23,020 --> 00:29:24,230
 

1013
00:29:23,030 --> 00:29:26,960
 configuration from the configuration

1014
00:29:24,220 --> 00:29:26,960
 

1015
00:29:24,230 --> 00:29:28,730
 space and I run it on some problem

1016
00:29:26,950 --> 00:29:28,730
 

1017
00:29:26,960 --> 00:29:32,510
 instance from the instance distribution

1018
00:29:28,720 --> 00:29:32,510
 

1019
00:29:28,730 --> 00:29:35,090
 and I actually go run it and I measure

1020
00:29:32,500 --> 00:29:35,090
 

1021
00:29:32,510 --> 00:29:36,860
 what happened I get back some real value

1022
00:29:35,080 --> 00:29:36,860
 

1023
00:29:35,090 --> 00:29:40,550
 and I'm gonna think about this real

1024
00:29:36,850 --> 00:29:40,550
 

1025
00:29:36,860 --> 00:29:42,890
 value as a cost so it might be solution

1026
00:29:40,540 --> 00:29:42,890
 

1027
00:29:40,550 --> 00:29:46,130
 quality or it might be time you know it

1028
00:29:42,880 --> 00:29:46,130
 

1029
00:29:42,890 --> 00:29:48,740
 could be loss of a model and the optimal

1030
00:29:46,120 --> 00:29:48,740
 

1031
00:29:46,130 --> 00:29:51,080
 configuration in the space is the

1032
00:29:48,730 --> 00:29:51,080
 

1033
00:29:48,740 --> 00:29:53,630
 configuration that minimizes the

1034
00:29:51,070 --> 00:29:53,630
 

1035
00:29:51,080 --> 00:29:55,130
 expectation over all of the instances in

1036
00:29:53,620 --> 00:29:55,130
 

1037
00:29:53,630 --> 00:29:59,870
 the instance distribution of this cost

1038
00:29:55,120 --> 00:29:59,870
 

1039
00:29:55,130 --> 00:30:01,370
 function now throughout this talk almost

1040
00:29:59,860 --> 00:30:01,370
 

1041
00:29:59,870 --> 00:30:03,500
 without exception we're going to

1042
00:30:01,360 --> 00:30:03,500
 

1043
00:30:01,370 --> 00:30:06,040
 restrict ourselves to thinking about a

1044
00:30:03,490 --> 00:30:06,040
 

1045
00:30:03,500 --> 00:30:08,900
 cost function that measures runtime so

1046
00:30:06,030 --> 00:30:08,900
 

1047
00:30:06,040 --> 00:30:10,280
 Inlet unless we say otherwise so the

1048
00:30:08,890 --> 00:30:10,280
 

1049
00:30:08,900 --> 00:30:12,140
 reason we want to do this is I think

1050
00:30:10,270 --> 00:30:12,140
 

1051
00:30:10,280 --> 00:30:14,410
 some really interesting technical things

1052
00:30:12,130 --> 00:30:14,410
 

1053
00:30:12,140 --> 00:30:17,660
 happen when we make this restriction so

1054
00:30:14,400 --> 00:30:17,660
 

1055
00:30:14,410 --> 00:30:20,030
 I'm going to use this notation R sub

1056
00:30:17,650 --> 00:30:20,030
 

1057
00:30:17,660 --> 00:30:21,650
 Kappa bar to indicate the wrong time of

1058
00:30:20,020 --> 00:30:21,650
 

1059
00:30:20,030 --> 00:30:25,850
 an algorithm capped at run time Kappa

1060
00:30:21,640 --> 00:30:25,850
 

1061
00:30:21,650 --> 00:30:27,710
 bar and when that's my cost function I'm

1062
00:30:25,840 --> 00:30:27,710
 

1063
00:30:25,850 --> 00:30:31,700
 gonna say I'm configuring with a runtime

1064
00:30:27,700 --> 00:30:31,700
 

1065
00:30:27,710 --> 00:30:33,800
 objective so there are a couple of

1066
00:30:31,690 --> 00:30:33,800
 

1067
00:30:31,700 --> 00:30:35,450
 related bodies of literature that don't

1068
00:30:33,790 --> 00:30:35,450
 

1069
00:30:33,800 --> 00:30:38,330
 make this restriction and I just want to

1070
00:30:35,440 --> 00:30:38,330
 

1071
00:30:35,450 --> 00:30:40,970
 note their existence the first is called

1072
00:30:38,320 --> 00:30:40,970
 

1073
00:30:38,330 --> 00:30:42,710
 blackbox optimization so this is a

1074
00:30:40,960 --> 00:30:42,710
 

1075
00:30:40,970 --> 00:30:44,180
 literature that started in statistics

1076
00:30:42,700 --> 00:30:44,180
 

1077
00:30:42,710 --> 00:30:47,030
 and probably includes some of the people

1078
00:30:44,170 --> 00:30:47,030
 

1079
00:30:44,180 --> 00:30:49,130
 here which just thinks about the problem

1080
00:30:47,020 --> 00:30:49,130
 

1081
00:30:47,030 --> 00:30:52,160
 of I want to optimize some function and

1082
00:30:49,120 --> 00:30:52,160
 

1083
00:30:49,130 --> 00:30:54,110
 I don't actually have you know access to

1084
00:30:52,150 --> 00:30:54,110
 

1085
00:30:52,160 --> 00:30:56,330
 the function itself all I can do is make

1086
00:30:54,100 --> 00:30:56,330
 

1087
00:30:54,110 --> 00:30:57,800
 query access to the function so think

1088
00:30:56,320 --> 00:30:57,800
 

1089
00:30:56,330 --> 00:31:00,440
 about the function as being something

1090
00:30:57,790 --> 00:31:00,440
 

1091
00:30:57,800 --> 00:31:03,470
 like a climate model or you know how

1092
00:31:00,430 --> 00:31:03,470
 

1093
00:31:00,440 --> 00:31:05,210
 does my you know aircraft how much drag

1094
00:31:03,460 --> 00:31:05,210
 

1095
00:31:03,470 --> 00:31:06,860
 does my aircraft design have if I

1096
00:31:05,200 --> 00:31:06,860
 

1097
00:31:05,210 --> 00:31:09,860
 simulated and put it in a wind tunnel

1098
00:31:06,850 --> 00:31:09,860
 

1099
00:31:06,860 --> 00:31:11,420
 and as I change parameters of my model I

1100
00:31:09,850 --> 00:31:11,420
 

1101
00:31:09,860 --> 00:31:13,700
 can run this thing for days and days and

1102
00:31:11,410 --> 00:31:13,700
 

1103
00:31:11,420 --> 00:31:15,920
 get back some answer about about the

1104
00:31:13,690 --> 00:31:15,920
 

1105
00:31:13,700 --> 00:31:18,050
 black box function and then I might want

1106
00:31:15,910 --> 00:31:18,050
 

1107
00:31:15,920 --> 00:31:18,440
 to minimize it but here the thing I'm

1108
00:31:18,040 --> 00:31:18,440
 

1109
00:31:18,050 --> 00:31:21,620
 trying to

1110
00:31:18,430 --> 00:31:21,620
 

1111
00:31:18,440 --> 00:31:25,010
 you know drag or amount of carbon output

1112
00:31:21,610 --> 00:31:25,010
 

1113
00:31:21,620 --> 00:31:27,680
 or something it's not run time secondly

1114
00:31:25,000 --> 00:31:27,680
 

1115
00:31:25,010 --> 00:31:29,480
 hyper parameter optimization says I want

1116
00:31:27,670 --> 00:31:29,480
 

1117
00:31:27,680 --> 00:31:31,720
 to find the hyper parameters of some

1118
00:31:29,470 --> 00:31:31,720
 

1119
00:31:29,480 --> 00:31:34,100
 model that minimizes validation set loss

1120
00:31:31,710 --> 00:31:34,100
 

1121
00:31:31,720 --> 00:31:37,130
 this has been a really active research

1122
00:31:34,090 --> 00:31:37,130
 

1123
00:31:34,100 --> 00:31:39,230
 area in the auto ml literature and there

1124
00:31:37,120 --> 00:31:39,230
 

1125
00:31:37,130 --> 00:31:40,760
 will make a couple of references to

1126
00:31:39,220 --> 00:31:40,760
 

1127
00:31:39,230 --> 00:31:42,770
 hyper parameter optimization throughout

1128
00:31:40,750 --> 00:31:42,770
 

1129
00:31:40,760 --> 00:31:44,480
 it turns out that some of the algorithms

1130
00:31:42,760 --> 00:31:44,480
 

1131
00:31:42,770 --> 00:31:46,310
 that we propose for algorithm

1132
00:31:44,470 --> 00:31:46,310
 

1133
00:31:44,480 --> 00:31:47,720
 configuration have been really effective

1134
00:31:46,300 --> 00:31:47,720
 

1135
00:31:46,310 --> 00:31:50,540
 in the hyper parameter optimization

1136
00:31:47,710 --> 00:31:50,540
 

1137
00:31:47,720 --> 00:31:52,190
 space but it doesn't have a runtime

1138
00:31:50,530 --> 00:31:52,190
 

1139
00:31:50,540 --> 00:31:54,740
 objective instead it has a loss

1140
00:31:52,180 --> 00:31:54,740
 

1141
00:31:52,190 --> 00:31:56,000
 objective and mostly we're not going to

1142
00:31:54,730 --> 00:31:56,000
 

1143
00:31:54,740 --> 00:31:58,040
 speak about that in this tutorial so I

1144
00:31:55,990 --> 00:31:58,040
 

1145
00:31:56,000 --> 00:32:03,290
 just wanted to call it out right now

1146
00:31:58,030 --> 00:32:03,290
 

1147
00:31:58,040 --> 00:32:05,210
 okay so now I want to switch gears and

1148
00:32:03,280 --> 00:32:05,210
 

1149
00:32:03,290 --> 00:32:06,950
 talk about a technical problem which

1150
00:32:05,200 --> 00:32:06,950
 

1151
00:32:05,210 --> 00:32:09,320
 isn't quite the same as algorithm

1152
00:32:06,940 --> 00:32:09,320
 

1153
00:32:06,950 --> 00:32:10,820
 configuration but turns out to be

1154
00:32:09,310 --> 00:32:10,820
 

1155
00:32:09,320 --> 00:32:12,830
 intellectually interesting for its own

1156
00:32:10,810 --> 00:32:12,830
 

1157
00:32:10,820 --> 00:32:14,930
 sake and turns out to be a really

1158
00:32:12,820 --> 00:32:14,930
 

1159
00:32:12,830 --> 00:32:16,520
 important enabling technology for making

1160
00:32:14,920 --> 00:32:16,520
 

1161
00:32:14,930 --> 00:32:19,010
 algorithm configuration methods work

1162
00:32:16,510 --> 00:32:19,010
 

1163
00:32:16,520 --> 00:32:23,030
 well and that's what I'll call algorithm

1164
00:32:19,000 --> 00:32:23,030
 

1165
00:32:19,010 --> 00:32:24,920
 run time prediction so here's a problem

1166
00:32:23,020 --> 00:32:24,920
 

1167
00:32:23,030 --> 00:32:26,960
 that you know on the face of it sounds

1168
00:32:24,910 --> 00:32:26,960
 

1169
00:32:24,920 --> 00:32:29,720
 like a pretty vanilla application of

1170
00:32:26,950 --> 00:32:29,720
 

1171
00:32:26,960 --> 00:32:31,670
 regression but it's a little bit strange

1172
00:32:29,710 --> 00:32:31,670
 

1173
00:32:29,720 --> 00:32:33,860
 so so let's think about it let's say I

1174
00:32:31,660 --> 00:32:33,860
 

1175
00:32:31,670 --> 00:32:35,960
 give you a set of problem instances for

1176
00:32:33,850 --> 00:32:35,960
 

1177
00:32:33,860 --> 00:32:38,090
 some combinatorial optimization problem

1178
00:32:35,950 --> 00:32:38,090
 

1179
00:32:35,960 --> 00:32:39,920
 let's say you have some solver let's say

1180
00:32:38,080 --> 00:32:39,920
 

1181
00:32:38,090 --> 00:32:42,680
 your solver is SEAPLEX

1182
00:32:39,910 --> 00:32:42,680
 

1183
00:32:39,920 --> 00:32:44,510
 so you go out to I log you pay them a

1184
00:32:42,670 --> 00:32:44,510
 

1185
00:32:42,680 --> 00:32:46,880
 whole lot of money to buy SEAPLEX which

1186
00:32:44,500 --> 00:32:46,880
 

1187
00:32:44,510 --> 00:32:48,680
 is a really expensive state-of-the-art

1188
00:32:46,870 --> 00:32:48,680
 

1189
00:32:46,880 --> 00:32:50,630
 mixed integer programming solver and

1190
00:32:48,670 --> 00:32:50,630
 

1191
00:32:48,680 --> 00:32:53,240
 nobody knows how it works because it's a

1192
00:32:50,620 --> 00:32:53,240
 

1193
00:32:50,630 --> 00:32:55,010
 trade secret and I won't tell you but

1194
00:32:53,230 --> 00:32:55,010
 

1195
00:32:53,240 --> 00:32:57,110
 you can download it and use it on your

1196
00:32:55,000 --> 00:32:57,110
 

1197
00:32:55,010 --> 00:32:59,450
 computer and let's say you have a bunch

1198
00:32:57,100 --> 00:32:59,450
 

1199
00:32:57,110 --> 00:33:02,420
 of instances which you know correspond

1200
00:32:59,440 --> 00:33:02,420
 

1201
00:32:59,450 --> 00:33:04,430
 to vehicle rented problems and for each

1202
00:33:02,410 --> 00:33:04,430
 

1203
00:33:02,420 --> 00:33:06,440
 instance let's say you're able to come

1204
00:33:04,420 --> 00:33:06,440
 

1205
00:33:04,430 --> 00:33:08,000
 up with a set of feature values which

1206
00:33:06,430 --> 00:33:08,000
 

1207
00:33:06,440 --> 00:33:10,250
 measure something about the instance

1208
00:33:07,990 --> 00:33:10,250
 

1209
00:33:08,000 --> 00:33:12,410
 that you might think matters but which

1210
00:33:10,240 --> 00:33:12,410
 

1211
00:33:10,250 --> 00:33:14,000
 are computable in polynomial time so you

1212
00:33:12,400 --> 00:33:14,000
 

1213
00:33:12,410 --> 00:33:15,320
 might say things like how many

1214
00:33:13,990 --> 00:33:15,320
 

1215
00:33:14,000 --> 00:33:18,500
 constraints are there in the mixed

1216
00:33:15,310 --> 00:33:18,500
 

1217
00:33:15,320 --> 00:33:21,140
 integer program how many non-zeroes are

1218
00:33:18,490 --> 00:33:21,140
 

1219
00:33:18,500 --> 00:33:22,730
 there in the constraint matrix how much

1220
00:33:21,130 --> 00:33:22,730
 

1221
00:33:21,140 --> 00:33:24,800
 variation is there in which variables

1222
00:33:22,720 --> 00:33:24,800
 

1223
00:33:22,730 --> 00:33:27,890
 the constraints talk about these kinds

1224
00:33:24,790 --> 00:33:27,890
 

1225
00:33:24,800 --> 00:33:29,540
 of things and and then for every

1226
00:33:27,880 --> 00:33:29,540
 

1227
00:33:27,890 --> 00:33:32,090
 instance you also have a runtime

1228
00:33:29,530 --> 00:33:32,090
 

1229
00:33:29,540 --> 00:33:33,650
 observation that says how long did C

1230
00:33:32,080 --> 00:33:33,650
 

1231
00:33:32,090 --> 00:33:35,600
 actually take to solve this particular

1232
00:33:33,640 --> 00:33:35,600
 

1233
00:33:33,650 --> 00:33:38,950
 problem and you obtain these runtime

1234
00:33:35,590 --> 00:33:38,950
 

1235
00:33:35,600 --> 00:33:42,770
 observations by just running it yourself

1236
00:33:38,940 --> 00:33:42,770
 

1237
00:33:38,950 --> 00:33:44,510
 well would it be possible to use some

1238
00:33:42,760 --> 00:33:44,510
 

1239
00:33:42,770 --> 00:33:47,030
 kind of regression approach to say I

1240
00:33:44,500 --> 00:33:47,030
 

1241
00:33:44,510 --> 00:33:49,310
 want to learn a mapping from whatever

1242
00:33:47,020 --> 00:33:49,310
 

1243
00:33:47,030 --> 00:33:51,320
 these features were to these runtimes so

1244
00:33:49,300 --> 00:33:51,320
 

1245
00:33:49,310 --> 00:33:53,360
 I want to be able to predict for new

1246
00:33:51,310 --> 00:33:53,360
 

1247
00:33:51,320 --> 00:33:57,740
 instances that I've never seen before

1248
00:33:53,350 --> 00:33:57,740
 

1249
00:33:53,360 --> 00:33:59,030
 how long they would take to run I mean

1250
00:33:57,730 --> 00:33:59,030
 

1251
00:33:57,740 --> 00:34:00,620
 on the face of that anything sounds like

1252
00:33:59,020 --> 00:34:00,620
 

1253
00:33:59,030 --> 00:34:01,970
 a machine learning problem and machine

1254
00:34:00,610 --> 00:34:01,970
 

1255
00:34:00,620 --> 00:34:05,150
 learning is wonderful that's why we're

1256
00:34:01,960 --> 00:34:05,150
 

1257
00:34:01,970 --> 00:34:06,890
 all here so it must work but but it

1258
00:34:05,140 --> 00:34:06,890
 

1259
00:34:05,150 --> 00:34:08,150
 seems maybe if you think about it a

1260
00:34:06,880 --> 00:34:08,150
 

1261
00:34:06,890 --> 00:34:09,800
 little bit longer a little bit

1262
00:34:08,140 --> 00:34:09,800
 

1263
00:34:08,150 --> 00:34:11,630
 surprising to think that supervised

1264
00:34:09,790 --> 00:34:11,630
 

1265
00:34:09,800 --> 00:34:13,730
 learning would be able to predict the

1266
00:34:11,620 --> 00:34:13,730
 

1267
00:34:11,630 --> 00:34:16,250
 empirical behavior of an exponential

1268
00:34:13,720 --> 00:34:16,250
 

1269
00:34:13,730 --> 00:34:18,110
 time algorithm on held-out problem its

1270
00:34:16,240 --> 00:34:18,110
 

1271
00:34:16,250 --> 00:34:20,270
 inputs each of which might be you know

1272
00:34:18,100 --> 00:34:20,270
 

1273
00:34:18,110 --> 00:34:22,700
 megabytes in size and distilled down to

1274
00:34:20,260 --> 00:34:22,700
 

1275
00:34:20,270 --> 00:34:25,580
 a small feature vector you might start

1276
00:34:22,690 --> 00:34:25,580
 

1277
00:34:22,700 --> 00:34:27,200
 wondering I mean is there even you some

1278
00:34:25,570 --> 00:34:27,200
 

1279
00:34:25,580 --> 00:34:28,790
 complexity theoretic reason why this

1280
00:34:27,190 --> 00:34:28,790
 

1281
00:34:27,200 --> 00:34:30,860
 shouldn't be possible to do

1282
00:34:28,780 --> 00:34:30,860
 

1283
00:34:28,790 --> 00:34:32,300
 turns out no but it's not it's not

1284
00:34:30,850 --> 00:34:32,300
 

1285
00:34:30,860 --> 00:34:36,230
 obvious and it's a kind of an average

1286
00:34:32,290 --> 00:34:36,230
 

1287
00:34:32,300 --> 00:34:37,580
 case claim which is why I know so you

1288
00:34:36,220 --> 00:34:37,580
 

1289
00:34:36,230 --> 00:34:39,470
 know I wouldn't be here talking about

1290
00:34:37,570 --> 00:34:39,470
 

1291
00:34:37,580 --> 00:34:41,000
 this if indeed this didn't work but I

1292
00:34:39,460 --> 00:34:41,000
 

1293
00:34:39,470 --> 00:34:43,700
 think it's a surprising thing that it

1294
00:34:40,990 --> 00:34:43,700
 

1295
00:34:41,000 --> 00:34:48,410
 works as well as it does so here are

1296
00:34:43,690 --> 00:34:48,410
 

1297
00:34:43,700 --> 00:34:51,340
 some results from a paper with Frank and

1298
00:34:48,400 --> 00:34:51,340
 

1299
00:34:48,410 --> 00:34:53,450
 myself and Ling Shu and Holger who's

1300
00:34:51,330 --> 00:34:53,450
 

1301
00:34:51,340 --> 00:34:56,600
 which was a kind of a survey of this

1302
00:34:53,440 --> 00:34:56,600
 

1303
00:34:53,450 --> 00:34:58,400
 area a IJ showing that algorithm run

1304
00:34:56,590 --> 00:34:58,400
 

1305
00:34:56,600 --> 00:35:01,430
 time is really surprisingly predictable

1306
00:34:58,390 --> 00:35:01,430
 

1307
00:34:58,400 --> 00:35:03,950
 so these graphs are showing actual run

1308
00:35:01,420 --> 00:35:03,950
 

1309
00:35:01,430 --> 00:35:05,840
 time on a log scale on the x-axis and

1310
00:35:03,940 --> 00:35:05,840
 

1311
00:35:03,950 --> 00:35:07,760
 notice that we're varying by like seven

1312
00:35:05,830 --> 00:35:07,760
 

1313
00:35:05,840 --> 00:35:10,760
 orders of magnitude in actual runtime

1314
00:35:07,750 --> 00:35:10,760
 

1315
00:35:07,760 --> 00:35:12,680
 and predicted run time on the y-axis and

1316
00:35:10,750 --> 00:35:12,680
 

1317
00:35:10,760 --> 00:35:15,350
 you can see root mean squared errors

1318
00:35:12,670 --> 00:35:15,350
 

1319
00:35:12,680 --> 00:35:18,080
 reported and they're sort of you know

1320
00:35:15,340 --> 00:35:18,080
 

1321
00:35:15,350 --> 00:35:21,170
 all on the on the order of half an order

1322
00:35:18,070 --> 00:35:21,170
 

1323
00:35:18,080 --> 00:35:23,000
 of magnitude or less so and this is on

1324
00:35:21,160 --> 00:35:23,000
 

1325
00:35:21,170 --> 00:35:24,740
 you know hello test data so these are

1326
00:35:22,990 --> 00:35:24,740
 

1327
00:35:23,000 --> 00:35:26,270
 you know optimization problems that the

1328
00:35:24,730 --> 00:35:26,270
 

1329
00:35:24,740 --> 00:35:28,520
 trainer model didn't get a chance to see

1330
00:35:26,260 --> 00:35:28,520
 

1331
00:35:26,270 --> 00:35:30,380
 the top ones are for satisfiability

1332
00:35:28,510 --> 00:35:30,380
 

1333
00:35:28,520 --> 00:35:33,320
 problems the bottom ones are for mixed

1334
00:35:30,370 --> 00:35:33,320
 

1335
00:35:30,380 --> 00:35:34,880
 integer programs and the one in the

1336
00:35:33,310 --> 00:35:34,880
 

1337
00:35:33,320 --> 00:35:36,560
 bottom right is the best example that

1338
00:35:34,870 --> 00:35:36,560
 

1339
00:35:34,880 --> 00:35:38,780
 we've ever seen is a computational

1340
00:35:36,550 --> 00:35:38,780
 

1341
00:35:36,560 --> 00:35:41,180
 sustainability problem about protecting

1342
00:35:38,770 --> 00:35:41,180
 

1343
00:35:38,780 --> 00:35:44,109
 red crested woodpecker habitats and has

1344
00:35:41,170 --> 00:35:44,109
 

1345
00:35:41,180 --> 00:35:45,940
 an RMS e of 0.02

1346
00:35:44,099 --> 00:35:45,940
 

1347
00:35:44,109 --> 00:35:47,410
 and that's not because the problems are

1348
00:35:45,930 --> 00:35:47,410
 

1349
00:35:45,940 --> 00:35:48,999
 trivial their varying across three

1350
00:35:47,400 --> 00:35:48,999
 

1351
00:35:47,410 --> 00:35:51,339
 orders of magnitude but there's just

1352
00:35:48,989 --> 00:35:51,339
 

1353
00:35:48,999 --> 00:35:52,960
 nailing how long they take to solve but

1354
00:35:51,329 --> 00:35:52,960
 

1355
00:35:51,339 --> 00:35:55,660
 even the worst ones which are you know

1356
00:35:52,950 --> 00:35:55,660
 

1357
00:35:52,960 --> 00:35:57,279
 all of MIT web which is a giant and very

1358
00:35:55,650 --> 00:35:57,279
 

1359
00:35:55,660 --> 00:35:58,960
 heterogeneous mixed integer programming

1360
00:35:57,269 --> 00:35:58,960
 

1361
00:35:57,279 --> 00:36:00,700
 benchmark library

1362
00:35:58,950 --> 00:36:00,700
 

1363
00:35:58,960 --> 00:36:04,359
 it still has a root mean squared error

1364
00:36:00,690 --> 00:36:04,359
 

1365
00:36:00,700 --> 00:36:06,190
 of like 0.63 so still you know these are

1366
00:36:04,349 --> 00:36:06,190
 

1367
00:36:04,359 --> 00:36:09,069
 not perfectly predictable but

1368
00:36:06,180 --> 00:36:09,069
 

1369
00:36:06,190 --> 00:36:10,690
 surprisingly predictable and I didn't

1370
00:36:09,059 --> 00:36:10,690
 

1371
00:36:09,069 --> 00:36:12,009
 cherry pick those examples in fact I

1372
00:36:10,680 --> 00:36:12,009
 

1373
00:36:10,690 --> 00:36:14,619
 think the nipple of example is one of

1374
00:36:11,999 --> 00:36:14,619
 

1375
00:36:12,009 --> 00:36:16,390
 the worst ones I know about we found

1376
00:36:14,609 --> 00:36:16,390
 

1377
00:36:14,619 --> 00:36:18,130
 that algorithm runtime is surprisingly

1378
00:36:16,380 --> 00:36:18,130
 

1379
00:36:16,390 --> 00:36:21,099
 consistently predictable across

1380
00:36:18,120 --> 00:36:21,099
 

1381
00:36:18,130 --> 00:36:23,829
 different problem domains dozens of

1382
00:36:21,089 --> 00:36:23,829
 

1383
00:36:21,099 --> 00:36:26,079
 different solvers and in many dozens of

1384
00:36:23,819 --> 00:36:26,079
 

1385
00:36:23,829 --> 00:36:27,849
 instance distributions including major

1386
00:36:26,069 --> 00:36:27,849
 

1387
00:36:26,079 --> 00:36:29,650
 benchmarks the community's care about

1388
00:36:27,839 --> 00:36:29,650
 

1389
00:36:27,849 --> 00:36:32,650
 real world data from particular

1390
00:36:29,640 --> 00:36:32,650
 

1391
00:36:29,650 --> 00:36:34,539
 application areas broadly speaking you

1392
00:36:32,640 --> 00:36:34,539
 

1393
00:36:32,650 --> 00:36:38,589
 should feel like this technology just

1394
00:36:34,529 --> 00:36:38,589
 

1395
00:36:34,539 --> 00:36:40,900
 works and if it works so well why

1396
00:36:38,579 --> 00:36:40,900
 

1397
00:36:38,589 --> 00:36:42,940
 shouldn't we get more ambitious so so

1398
00:36:40,890 --> 00:36:42,940
 

1399
00:36:40,900 --> 00:36:44,890
 far I've talked about the runtime of a

1400
00:36:42,930 --> 00:36:44,890
 

1401
00:36:42,940 --> 00:36:47,200
 single black box algorithm like SEAPLEX

1402
00:36:44,880 --> 00:36:47,200
 

1403
00:36:44,890 --> 00:36:48,609
 but maybe I should say you know hey see

1404
00:36:47,190 --> 00:36:48,609
 

1405
00:36:47,200 --> 00:36:50,619
 flex actually has a whole bunch of

1406
00:36:48,599 --> 00:36:50,619
 

1407
00:36:48,609 --> 00:36:52,630
 different parameters wouldn't it be cool

1408
00:36:50,609 --> 00:36:52,630
 

1409
00:36:50,619 --> 00:36:55,269
 if I could predict not just how long see

1410
00:36:52,620 --> 00:36:55,269
 

1411
00:36:52,630 --> 00:36:57,249
 flex takes to run but how long simplex

1412
00:36:55,259 --> 00:36:57,249
 

1413
00:36:55,269 --> 00:36:58,989
 would take to run under new parameter

1414
00:36:57,239 --> 00:36:58,989
 

1415
00:36:57,249 --> 00:37:01,390
 settings that I've never even evaluated

1416
00:36:58,979 --> 00:37:01,390
 

1417
00:36:58,989 --> 00:37:02,529
 it on before on a new instance that I've

1418
00:37:01,380 --> 00:37:02,529
 

1419
00:37:01,390 --> 00:37:05,859
 also never seen before

1420
00:37:02,519 --> 00:37:05,859
 

1421
00:37:02,529 --> 00:37:07,599
 and again I wouldn't be standing here

1422
00:37:05,849 --> 00:37:07,599
 

1423
00:37:05,859 --> 00:37:09,309
 talking to you if that didn't work too

1424
00:37:07,589 --> 00:37:09,309
 

1425
00:37:07,599 --> 00:37:11,559
 although again that's kind of surprising

1426
00:37:09,299 --> 00:37:11,559
 

1427
00:37:09,309 --> 00:37:13,869
 you can see the error gets a bit worse

1428
00:37:11,549 --> 00:37:13,869
 

1429
00:37:11,559 --> 00:37:16,029
 but here we're generalizing both to

1430
00:37:13,859 --> 00:37:16,029
 

1431
00:37:13,869 --> 00:37:17,499
 unseen problem instances and unseen

1432
00:37:16,019 --> 00:37:17,499
 

1433
00:37:16,029 --> 00:37:20,140
 configurations you know effectively

1434
00:37:17,489 --> 00:37:20,140
 

1435
00:37:17,499 --> 00:37:23,049
 unseen algorithms and we're correct

1436
00:37:20,130 --> 00:37:23,049
 

1437
00:37:20,140 --> 00:37:25,749
 within roughly an order of magnitude so

1438
00:37:23,039 --> 00:37:25,749
 

1439
00:37:23,049 --> 00:37:27,420
 why am I telling you about all this it

1440
00:37:25,739 --> 00:37:27,420
 

1441
00:37:25,749 --> 00:37:29,170
 really this goes to show that despite

1442
00:37:27,410 --> 00:37:29,170
 

1443
00:37:27,420 --> 00:37:31,029
 discontinuities in the algorithms

1444
00:37:29,160 --> 00:37:31,029
 

1445
00:37:29,170 --> 00:37:33,730
 performance as a function of some of its

1446
00:37:31,019 --> 00:37:33,730
 

1447
00:37:31,029 --> 00:37:36,009
 parameters and algorithms performance is

1448
00:37:33,720 --> 00:37:36,009
 

1449
00:37:33,730 --> 00:37:38,559
 well approximated by a relatively simple

1450
00:37:35,999 --> 00:37:38,559
 

1451
00:37:36,009 --> 00:37:40,239
 function of its parameters not all of

1452
00:37:38,549 --> 00:37:40,239
 

1453
00:37:38,559 --> 00:37:43,509
 the parameters discontinuously matter

1454
00:37:40,229 --> 00:37:43,509
 

1455
00:37:40,239 --> 00:37:45,220
 all of the time you know there must be

1456
00:37:43,499 --> 00:37:45,220
 

1457
00:37:43,509 --> 00:37:47,289
 kind of expressible in some lower

1458
00:37:45,210 --> 00:37:47,289
 

1459
00:37:45,220 --> 00:37:49,509
 dimensional space and there's still some

1460
00:37:47,279 --> 00:37:49,509
 

1461
00:37:47,289 --> 00:37:51,549
 residual noise but we can really get a

1462
00:37:49,499 --> 00:37:51,549
 

1463
00:37:49,509 --> 00:37:54,130
 handle on you know how an algorithm

1464
00:37:51,539 --> 00:37:54,130
 

1465
00:37:51,549 --> 00:37:56,170
 behaves on problems and you know

1466
00:37:54,120 --> 00:37:56,170
 

1467
00:37:54,130 --> 00:37:57,910
 parts of its design space that we

1468
00:37:56,160 --> 00:37:57,910
 

1469
00:37:56,170 --> 00:37:59,529
 haven't explicitly looked at before and

1470
00:37:57,900 --> 00:37:59,529
 

1471
00:37:57,910 --> 00:38:01,569
 that that's really what opens up the

1472
00:37:59,519 --> 00:38:01,569
 

1473
00:37:59,529 --> 00:38:02,950
 possibility of doing some kind of

1474
00:38:01,559 --> 00:38:02,950
 

1475
00:38:01,569 --> 00:38:06,759
 machine learning in this space and being

1476
00:38:02,940 --> 00:38:06,759
 

1477
00:38:02,950 --> 00:38:08,309
 able to make progress so last thing I

1478
00:38:06,749 --> 00:38:08,309
 

1479
00:38:06,759 --> 00:38:11,680
 want to say about this just as an aside

1480
00:38:08,299 --> 00:38:11,680
 

1481
00:38:08,309 --> 00:38:14,019
 actually I've maybe understated how

1482
00:38:11,670 --> 00:38:14,019
 

1483
00:38:11,680 --> 00:38:15,880
 difficult this is to make work the

1484
00:38:14,009 --> 00:38:15,880
 

1485
00:38:14,019 --> 00:38:17,799
 regression problem is a bit trickier

1486
00:38:15,870 --> 00:38:17,799
 

1487
00:38:15,880 --> 00:38:20,079
 than then I initially gave you the

1488
00:38:17,789 --> 00:38:20,079
 

1489
00:38:17,799 --> 00:38:22,660
 impression so we have mixed continuous

1490
00:38:20,069 --> 00:38:22,660
 

1491
00:38:20,079 --> 00:38:24,190
 and discrete variables it's high

1492
00:38:22,650 --> 00:38:24,190
 

1493
00:38:22,660 --> 00:38:26,079
 dimensional although often with low

1494
00:38:24,180 --> 00:38:26,079
 

1495
00:38:24,190 --> 00:38:28,119
 effective dimensionality and we have a

1496
00:38:26,069 --> 00:38:28,119
 

1497
00:38:26,079 --> 00:38:31,140
 very noisy response variable because

1498
00:38:28,109 --> 00:38:31,140
 

1499
00:38:28,119 --> 00:38:33,730
 algorithm run time varies really widely

1500
00:38:31,130 --> 00:38:33,730
 

1501
00:38:31,140 --> 00:38:35,950
 plus there's some other nice-to-haves

1502
00:38:33,720 --> 00:38:35,950
 

1503
00:38:33,730 --> 00:38:37,599
 that we're gonna turn out to want so

1504
00:38:35,940 --> 00:38:37,599
 

1505
00:38:35,950 --> 00:38:39,190
 we're gonna want to be able to do

1506
00:38:37,589 --> 00:38:39,190
 

1507
00:38:37,599 --> 00:38:41,410
 unbiased learning in the presence of

1508
00:38:39,180 --> 00:38:41,410
 

1509
00:38:39,190 --> 00:38:43,869
 censored observations which is to say if

1510
00:38:41,400 --> 00:38:43,869
 

1511
00:38:41,410 --> 00:38:45,789
 I cap a run if I just don't manage to

1512
00:38:43,859 --> 00:38:45,789
 

1513
00:38:43,869 --> 00:38:47,289
 complete the run I want to say that

1514
00:38:45,779 --> 00:38:47,289
 

1515
00:38:45,789 --> 00:38:48,670
 gives me a lower bound on its run time

1516
00:38:47,279 --> 00:38:48,670
 

1517
00:38:47,289 --> 00:38:50,609
 but I don't want to treat that like a

1518
00:38:48,660 --> 00:38:50,609
 

1519
00:38:48,670 --> 00:38:53,650
 run time observation so that's a

1520
00:38:50,599 --> 00:38:53,650
 

1521
00:38:50,609 --> 00:38:56,319
 censored observation and that also like

1522
00:38:53,640 --> 00:38:56,319
 

1523
00:38:53,650 --> 00:38:58,690
 a test time on some previously unseen

1524
00:38:56,309 --> 00:38:58,690
 

1525
00:38:56,319 --> 00:39:00,880
 test input to be able to get uncertainty

1526
00:38:58,680 --> 00:39:00,880
 

1527
00:38:58,690 --> 00:39:03,029
 estimates that say how confident is my

1528
00:39:00,870 --> 00:39:03,029
 

1529
00:39:00,880 --> 00:39:06,490
 model in the prediction that it's making

1530
00:39:03,019 --> 00:39:06,490
 

1531
00:39:03,029 --> 00:39:08,410
 we've tried you know a giant grab bag of

1532
00:39:06,480 --> 00:39:08,410
 

1533
00:39:06,490 --> 00:39:11,980
 every regression method Under the Sun

1534
00:39:08,400 --> 00:39:11,980
 

1535
00:39:08,410 --> 00:39:14,170
 from various parametric methods to

1536
00:39:11,970 --> 00:39:14,170
 

1537
00:39:11,980 --> 00:39:16,329
 Gaussian processes to deep networks and

1538
00:39:14,160 --> 00:39:16,329
 

1539
00:39:14,170 --> 00:39:17,980
 today we've had the most success with

1540
00:39:16,319 --> 00:39:17,980
 

1541
00:39:16,329 --> 00:39:19,750
 random forests of regression trees which

1542
00:39:17,970 --> 00:39:19,750
 

1543
00:39:17,980 --> 00:39:22,839
 most of what we'll report here is based

1544
00:39:19,740 --> 00:39:22,839
 

1545
00:39:19,750 --> 00:39:25,779
 on and that's especially because of the

1546
00:39:22,829 --> 00:39:25,779
 

1547
00:39:22,839 --> 00:39:27,250
 really discontinuous nature of of the

1548
00:39:25,769 --> 00:39:27,250
 

1549
00:39:25,779 --> 00:39:30,759
 relationship between the response and

1550
00:39:27,240 --> 00:39:30,759
 

1551
00:39:27,250 --> 00:39:32,049
 the features all right I guess finally I

1552
00:39:30,749 --> 00:39:32,049
 

1553
00:39:30,759 --> 00:39:34,299
 should say something about the features

1554
00:39:32,039 --> 00:39:34,299
 

1555
00:39:32,049 --> 00:39:36,730
 so clearly features are gonna be pretty

1556
00:39:34,289 --> 00:39:36,730
 

1557
00:39:34,299 --> 00:39:39,579
 important here I'm mapping from a raw

1558
00:39:36,720 --> 00:39:39,579
 

1559
00:39:36,730 --> 00:39:41,440
 problem input to a runtime and the only

1560
00:39:39,569 --> 00:39:41,440
 

1561
00:39:39,579 --> 00:39:42,549
 way that can work surely is because the

1562
00:39:41,430 --> 00:39:42,549
 

1563
00:39:41,440 --> 00:39:45,279
 features are capturing something

1564
00:39:42,539 --> 00:39:45,279
 

1565
00:39:42,549 --> 00:39:46,779
 important and we've come up with

1566
00:39:45,269 --> 00:39:46,779
 

1567
00:39:45,279 --> 00:39:48,910
 different features for each problem

1568
00:39:46,769 --> 00:39:48,910
 

1569
00:39:46,779 --> 00:39:51,039
 distribution but what I can tell you is

1570
00:39:48,900 --> 00:39:51,039
 

1571
00:39:48,910 --> 00:39:52,630
 we haven't really had to think that hard

1572
00:39:51,029 --> 00:39:52,630
 

1573
00:39:51,039 --> 00:39:54,220
 about it typically what we've come up

1574
00:39:52,620 --> 00:39:54,220
 

1575
00:39:52,630 --> 00:39:56,259
 with after a day or two on the

1576
00:39:54,210 --> 00:39:56,259
 

1577
00:39:54,220 --> 00:39:58,299
 whiteboard and then implemented gets us

1578
00:39:56,249 --> 00:39:58,299
 

1579
00:39:56,259 --> 00:39:59,740
 pretty much all of the way there every

1580
00:39:58,289 --> 00:39:59,740
 

1581
00:39:58,299 --> 00:40:01,839
 time we do it

1582
00:39:59,730 --> 00:40:01,839
 

1583
00:39:59,740 --> 00:40:03,910
 and you can use these kinds of ideas

1584
00:40:01,829 --> 00:40:03,910
 

1585
00:40:01,839 --> 00:40:05,410
 when you move to a new problem so I'm

1586
00:40:03,900 --> 00:40:05,410
 

1587
00:40:03,910 --> 00:40:07,510
 not saying you know anything you dream

1588
00:40:05,400 --> 00:40:07,510
 

1589
00:40:05,410 --> 00:40:09,850
 up would work but this sort of family

1590
00:40:07,500 --> 00:40:09,850
 

1591
00:40:07,510 --> 00:40:12,490
 tends to work so we tend to think about

1592
00:40:09,840 --> 00:40:12,490
 

1593
00:40:09,850 --> 00:40:14,290
 things like problem size features we

1594
00:40:12,480 --> 00:40:14,290
 

1595
00:40:12,490 --> 00:40:16,060
 tend to build constraint graphs out of

1596
00:40:14,280 --> 00:40:16,060
 

1597
00:40:14,290 --> 00:40:19,030
 the problem input and then do statistics

1598
00:40:16,050 --> 00:40:19,030
 

1599
00:40:16,060 --> 00:40:20,740
 on the constraint graph like what's the

1600
00:40:19,020 --> 00:40:20,740
 

1601
00:40:19,030 --> 00:40:22,390
 average degree of a node in the

1602
00:40:20,730 --> 00:40:22,390
 

1603
00:40:20,740 --> 00:40:24,430
 constraint graph how clustered are the

1604
00:40:22,380 --> 00:40:24,430
 

1605
00:40:22,390 --> 00:40:25,810
 nodes in the constraint graph what our

1606
00:40:24,420 --> 00:40:25,810
 

1607
00:40:24,430 --> 00:40:29,290
 path lengths like in the constraint

1608
00:40:25,800 --> 00:40:29,290
 

1609
00:40:25,810 --> 00:40:31,240
 graph there's there's a way of getting

1610
00:40:29,280 --> 00:40:31,240
 

1611
00:40:29,290 --> 00:40:35,380
 an estimate of the size of a search

1612
00:40:31,230 --> 00:40:35,380
 

1613
00:40:31,240 --> 00:40:36,640
 space due to Don Knuth which we use and

1614
00:40:35,370 --> 00:40:36,640
 

1615
00:40:35,380 --> 00:40:38,590
 then you can look at various heuristics

1616
00:40:36,630 --> 00:40:38,590
 

1617
00:40:36,640 --> 00:40:40,270
 or relaxation --hz that people actually

1618
00:40:38,580 --> 00:40:40,270
 

1619
00:40:38,590 --> 00:40:42,400
 use in solvers and you can turn those

1620
00:40:40,260 --> 00:40:42,400
 

1621
00:40:40,270 --> 00:40:44,020
 into features so in sat you can say

1622
00:40:42,390 --> 00:40:44,020
 

1623
00:40:42,400 --> 00:40:45,609
 something like how many unit

1624
00:40:44,010 --> 00:40:45,609
 

1625
00:40:44,020 --> 00:40:49,300
 propagations are you able to do at

1626
00:40:45,599 --> 00:40:49,300
 

1627
00:40:45,609 --> 00:40:51,820
 different depths as a function of just

1628
00:40:49,290 --> 00:40:51,820
 

1629
00:40:49,300 --> 00:40:53,170
 random probing and we do this not

1630
00:40:51,810 --> 00:40:53,170
 

1631
00:40:51,820 --> 00:40:54,520
 because we think that's gonna solve the

1632
00:40:53,160 --> 00:40:54,520
 

1633
00:40:53,170 --> 00:40:56,350
 problem but because it's a number that

1634
00:40:54,510 --> 00:40:56,350
 

1635
00:40:54,520 --> 00:40:58,180
 tells us something about how amenable

1636
00:40:56,340 --> 00:40:58,180
 

1637
00:40:56,350 --> 00:41:01,180
 the instance is to simplification by

1638
00:40:58,170 --> 00:41:01,180
 

1639
00:40:58,180 --> 00:41:03,160
 this heuristic or if I just run a local

1640
00:41:01,170 --> 00:41:03,160
 

1641
00:41:01,180 --> 00:41:04,810
 search salt solver for some bounded

1642
00:41:03,150 --> 00:41:04,810
 

1643
00:41:03,160 --> 00:41:06,400
 amount of time and then I measure

1644
00:41:04,800 --> 00:41:06,400
 

1645
00:41:04,810 --> 00:41:08,140
 statistics about what it does across

1646
00:41:06,390 --> 00:41:08,140
 

1647
00:41:06,400 --> 00:41:09,670
 random restarts and that's another

1648
00:41:08,130 --> 00:41:09,670
 

1649
00:41:08,140 --> 00:41:11,830
 number that we found to be very helpful

1650
00:41:09,660 --> 00:41:11,830
 

1651
00:41:09,670 --> 00:41:13,600
 and finally you can take something like

1652
00:41:11,820 --> 00:41:13,600
 

1653
00:41:11,830 --> 00:41:15,910
 the linear programming relaxation of the

1654
00:41:13,590 --> 00:41:15,910
 

1655
00:41:13,600 --> 00:41:17,410
 problem and say how close to integral is

1656
00:41:15,900 --> 00:41:17,410
 

1657
00:41:15,910 --> 00:41:20,050
 it we know what's the norm of the

1658
00:41:17,400 --> 00:41:20,050
 

1659
00:41:17,410 --> 00:41:21,340
 integer slack vector and that's another

1660
00:41:20,040 --> 00:41:21,340
 

1661
00:41:20,050 --> 00:41:23,410
 thing that tells you something about how

1662
00:41:21,330 --> 00:41:23,410
 

1663
00:41:21,340 --> 00:41:25,450
 meaningful it is to attack by a

1664
00:41:23,400 --> 00:41:25,450
 

1665
00:41:23,410 --> 00:41:27,490
 heuristic what we found that's

1666
00:41:25,440 --> 00:41:27,490
 

1667
00:41:25,450 --> 00:41:29,200
 interesting is we don't actually have to

1668
00:41:27,480 --> 00:41:29,200
 

1669
00:41:27,490 --> 00:41:31,630
 be using those heuristics yourself in

1670
00:41:29,190 --> 00:41:31,630
 

1671
00:41:29,200 --> 00:41:33,580
 your solver some heuristic that you

1672
00:41:31,620 --> 00:41:33,580
 

1673
00:41:31,630 --> 00:41:35,440
 completely don't use in your own solver

1674
00:41:33,570 --> 00:41:35,440
 

1675
00:41:33,580 --> 00:41:37,150
 such as a local search heuristic to

1676
00:41:35,430 --> 00:41:37,150
 

1677
00:41:35,440 --> 00:41:39,220
 think about a complete solver

1678
00:41:37,140 --> 00:41:39,220
 

1679
00:41:37,150 --> 00:41:42,250
 nevertheless can be a really informative

1680
00:41:39,210 --> 00:41:42,250
 

1681
00:41:39,220 --> 00:41:46,180
 source of information okay

1682
00:41:42,240 --> 00:41:46,180
 

1683
00:41:42,250 --> 00:41:49,540
 now I'm gonna move on to my last item in

1684
00:41:46,170 --> 00:41:49,540
 

1685
00:41:46,180 --> 00:41:51,910
 my section which is a case study so I'm

1686
00:41:49,530 --> 00:41:51,910
 

1687
00:41:49,540 --> 00:41:54,400
 gonna tell you about well first of all

1688
00:41:51,900 --> 00:41:54,400
 

1689
00:41:51,910 --> 00:41:56,290
 let me just say algorithm configuration

1690
00:41:54,390 --> 00:41:56,290
 

1691
00:41:54,400 --> 00:41:58,930
 has been used at this point in a really

1692
00:41:56,280 --> 00:41:58,930
 

1693
00:41:56,290 --> 00:42:02,080
 wide range of applications both by us

1694
00:41:58,920 --> 00:42:02,080
 

1695
00:41:58,930 --> 00:42:05,170
 and by many colleagues in industry and

1696
00:42:02,070 --> 00:42:05,170
 

1697
00:42:02,080 --> 00:42:06,310
 academia this is a list of some of the

1698
00:42:05,160 --> 00:42:06,310
 

1699
00:42:05,170 --> 00:42:08,740
 things that we know about there are

1700
00:42:06,300 --> 00:42:08,740
 

1701
00:42:06,310 --> 00:42:12,280
 probably many more that the high-level

1702
00:42:08,730 --> 00:42:12,280
 

1703
00:42:08,740 --> 00:42:15,250
 takeaway is it just tends to work pretty

1704
00:42:12,270 --> 00:42:15,250
 

1705
00:42:12,280 --> 00:42:16,780
 well in really different domains the

1706
00:42:15,240 --> 00:42:16,780
 

1707
00:42:15,250 --> 00:42:19,030
 main thing that you would want to think

1708
00:42:16,770 --> 00:42:19,030
 

1709
00:42:16,780 --> 00:42:20,980
 that this would work well for you is a

1710
00:42:19,020 --> 00:42:20,980
 

1711
00:42:19,030 --> 00:42:23,619
 really high variation in

1712
00:42:20,970 --> 00:42:23,619
 

1713
00:42:20,980 --> 00:42:25,840
 times across different configurations of

1714
00:42:23,609 --> 00:42:25,840
 

1715
00:42:23,619 --> 00:42:28,119
 your algorithm obviously if you have an

1716
00:42:25,830 --> 00:42:28,119
 

1717
00:42:25,840 --> 00:42:29,500
 algorithm that is incredibly robust in

1718
00:42:28,109 --> 00:42:29,500
 

1719
00:42:28,119 --> 00:42:31,780
 its performance as a function of its

1720
00:42:29,490 --> 00:42:31,780
 

1721
00:42:29,500 --> 00:42:35,100
 parameters you shouldn't expect to see

1722
00:42:31,770 --> 00:42:35,100
 

1723
00:42:31,780 --> 00:42:37,420
 much impact from automatic configuration

1724
00:42:35,090 --> 00:42:37,420
 

1725
00:42:35,100 --> 00:42:40,720
 so the case study that I want to tell

1726
00:42:37,410 --> 00:42:40,720
 

1727
00:42:37,420 --> 00:42:41,950
 you about and it concerns an auction

1728
00:42:40,710 --> 00:42:41,950
 

1729
00:42:40,720 --> 00:42:44,080
 that the Federal Communication

1730
00:42:41,940 --> 00:42:44,080
 

1731
00:42:41,950 --> 00:42:46,210
 Commission held a couple of years ago to

1732
00:42:44,070 --> 00:42:46,210
 

1733
00:42:44,080 --> 00:42:49,240
 repurpose radio spectrum from broadcast

1734
00:42:46,200 --> 00:42:49,240
 

1735
00:42:46,210 --> 00:42:51,850
 television to wireless internet this was

1736
00:42:49,230 --> 00:42:51,850
 

1737
00:42:49,240 --> 00:42:53,619
 a pretty big deal it was across all of

1738
00:42:51,840 --> 00:42:53,619
 

1739
00:42:51,850 --> 00:42:55,780
 Canada in the United States and it

1740
00:42:53,609 --> 00:42:55,780
 

1741
00:42:53,619 --> 00:42:58,330
 grossed the government almost twenty

1742
00:42:55,770 --> 00:42:58,330
 

1743
00:42:55,780 --> 00:43:01,390
 billion dollars about ten billion of it

1744
00:42:58,320 --> 00:43:01,390
 

1745
00:42:58,330 --> 00:43:03,160
 was paid to television broadcasters who

1746
00:43:01,380 --> 00:43:03,160
 

1747
00:43:01,390 --> 00:43:05,260
 voluntarily sold the government their

1748
00:43:03,150 --> 00:43:05,260
 

1749
00:43:03,160 --> 00:43:08,890
 broadcast licenses and stopped being

1750
00:43:05,250 --> 00:43:08,890
 

1751
00:43:05,260 --> 00:43:10,630
 broadcasters and everyone who didn't do

1752
00:43:08,880 --> 00:43:10,630
 

1753
00:43:08,890 --> 00:43:13,030
 this and all of the broadcaster's who

1754
00:43:10,620 --> 00:43:13,030
 

1755
00:43:10,630 --> 00:43:15,460
 remained on the air got repacked into

1756
00:43:13,020 --> 00:43:15,460
 

1757
00:43:13,030 --> 00:43:17,290
 potentially new channels so that they

1758
00:43:15,450 --> 00:43:17,290
 

1759
00:43:15,460 --> 00:43:19,630
 could get kind of smushed down into a

1760
00:43:17,280 --> 00:43:19,630
 

1761
00:43:17,290 --> 00:43:22,330
 reduced spectrum band and the remaining

1762
00:43:19,620 --> 00:43:22,330
 

1763
00:43:19,630 --> 00:43:23,920
 spectrum was nice and free and clear and

1764
00:43:22,320 --> 00:43:23,920
 

1765
00:43:22,330 --> 00:43:27,130
 could be sold off to mobile phone

1766
00:43:23,910 --> 00:43:27,130
 

1767
00:43:23,920 --> 00:43:29,020
 companies and there was then the second

1768
00:43:27,120 --> 00:43:29,020
 

1769
00:43:27,130 --> 00:43:31,390
 auction that did this resale and the

1770
00:43:29,010 --> 00:43:31,390
 

1771
00:43:29,020 --> 00:43:33,910
 government pocketed the difference which

1772
00:43:31,380 --> 00:43:33,910
 

1773
00:43:31,390 --> 00:43:36,280
 after paying the returning costs of the

1774
00:43:33,900 --> 00:43:36,280
 

1775
00:43:33,910 --> 00:43:37,930
 the stations that got moved around ended

1776
00:43:36,270 --> 00:43:37,930
 

1777
00:43:36,280 --> 00:43:40,420
 up being a net of seven billion dollars

1778
00:43:37,920 --> 00:43:40,420
 

1779
00:43:37,930 --> 00:43:43,210
 so not bad for you know a couple of

1780
00:43:40,410 --> 00:43:43,210
 

1781
00:43:40,420 --> 00:43:44,920
 years work and algorithm configuration

1782
00:43:43,200 --> 00:43:44,920
 

1783
00:43:43,210 --> 00:43:47,080
 was really central to the success of

1784
00:43:44,910 --> 00:43:47,080
 

1785
00:43:44,920 --> 00:43:48,880
 this application we wrote the solver

1786
00:43:47,070 --> 00:43:48,880
 

1787
00:43:47,080 --> 00:43:51,850
 that the the government used in this

1788
00:43:48,870 --> 00:43:51,850
 

1789
00:43:48,880 --> 00:43:53,500
 application and it was really

1790
00:43:51,840 --> 00:43:53,500
 

1791
00:43:51,850 --> 00:43:56,440
 appropriate for algorithm configuration

1792
00:43:53,490 --> 00:43:56,440
 

1793
00:43:53,500 --> 00:43:59,200
 for several reasons and one was we knew

1794
00:43:56,430 --> 00:43:59,200
 

1795
00:43:56,440 --> 00:44:00,640
 in advance what the constraint graph

1796
00:43:59,190 --> 00:44:00,640
 

1797
00:43:59,200 --> 00:44:03,040
 that the problem was going to be drawn

1798
00:44:00,630 --> 00:44:03,040
 

1799
00:44:00,640 --> 00:44:04,450
 from was going to be so we didn't want

1800
00:44:03,030 --> 00:44:04,450
 

1801
00:44:03,040 --> 00:44:06,160
 to so let me tell you what the

1802
00:44:04,440 --> 00:44:06,160
 

1803
00:44:04,450 --> 00:44:09,490
 subproblem was that we needed to think

1804
00:44:06,150 --> 00:44:09,490
 

1805
00:44:06,160 --> 00:44:11,560
 about there was this repacking problem

1806
00:44:09,480 --> 00:44:11,560
 

1807
00:44:09,490 --> 00:44:13,600
 so the auction had descending prices for

1808
00:44:11,550 --> 00:44:13,600
 

1809
00:44:11,560 --> 00:44:15,580
 the different stations and every time

1810
00:44:13,590 --> 00:44:15,580
 

1811
00:44:13,600 --> 00:44:17,140
 you had to think about whether one

1812
00:44:15,570 --> 00:44:17,140
 

1813
00:44:15,580 --> 00:44:20,290
 station should be offered a lower price

1814
00:44:17,130 --> 00:44:20,290
 

1815
00:44:17,140 --> 00:44:23,140
 or not you had to ask could that station

1816
00:44:20,280 --> 00:44:23,140
 

1817
00:44:20,290 --> 00:44:25,780
 turn my offer down and leave the auction

1818
00:44:23,130 --> 00:44:25,780
 

1819
00:44:23,140 --> 00:44:27,730
 and be put back on the air into the

1820
00:44:25,770 --> 00:44:27,730
 

1821
00:44:25,780 --> 00:44:29,140
 reduced band of spectrum given that a

1822
00:44:27,720 --> 00:44:29,140
 

1823
00:44:27,730 --> 00:44:30,670
 bunch of other people are also back on

1824
00:44:29,130 --> 00:44:30,670
 

1825
00:44:29,140 --> 00:44:32,230
 the air and there's less space than

1826
00:44:30,660 --> 00:44:32,230
 

1827
00:44:30,670 --> 00:44:34,119
 there was before and you have to

1828
00:44:32,220 --> 00:44:34,119
 

1829
00:44:32,230 --> 00:44:37,690
 have come up with station values to

1830
00:44:34,109 --> 00:44:37,690
 

1831
00:44:34,119 --> 00:44:40,060
 assign to everybody and you know if the

1832
00:44:37,680 --> 00:44:40,060
 

1833
00:44:37,690 --> 00:44:41,410
 answer was yes then you would offer them

1834
00:44:40,050 --> 00:44:41,410
 

1835
00:44:40,060 --> 00:44:43,900
 a lower price and see if they would take

1836
00:44:41,400 --> 00:44:43,900
 

1837
00:44:41,410 --> 00:44:45,520
 it and if the answer was no then

1838
00:44:43,890 --> 00:44:45,520
 

1839
00:44:43,900 --> 00:44:46,960
 something terrible would happen if they

1840
00:44:45,510 --> 00:44:46,960
 

1841
00:44:45,520 --> 00:44:48,579
 turned you down and so you didn't want

1842
00:44:46,950 --> 00:44:48,579
 

1843
00:44:46,960 --> 00:44:49,810
 to take that risk and so you would leave

1844
00:44:48,569 --> 00:44:49,810
 

1845
00:44:48,579 --> 00:44:52,420
 them at the last price that they had

1846
00:44:49,800 --> 00:44:52,420
 

1847
00:44:49,810 --> 00:44:55,390
 accepted and they would so-called become

1848
00:44:52,410 --> 00:44:55,390
 

1849
00:44:52,420 --> 00:44:57,280
 frozen so this would happen about a

1850
00:44:55,380 --> 00:44:57,280
 

1851
00:44:55,390 --> 00:44:59,700
 hundred thousand times per auction and

1852
00:44:57,270 --> 00:44:59,700
 

1853
00:44:57,280 --> 00:45:02,829
 of those hundred thousand problems about

1854
00:44:59,690 --> 00:45:02,829
 

1855
00:44:59,700 --> 00:45:04,660
 20 percent of them were non-trivial in

1856
00:45:02,819 --> 00:45:04,660
 

1857
00:45:02,829 --> 00:45:06,579
 the sense that we couldn't just directly

1858
00:45:04,650 --> 00:45:06,579
 

1859
00:45:04,660 --> 00:45:09,220
 augment a previous solution to get a

1860
00:45:06,569 --> 00:45:09,220
 

1861
00:45:06,579 --> 00:45:11,859
 valid new solution but something more

1862
00:45:09,210 --> 00:45:11,859
 

1863
00:45:09,220 --> 00:45:14,500
 had to happen and that that was a

1864
00:45:11,849 --> 00:45:14,500
 

1865
00:45:11,859 --> 00:45:16,420
 problem for us because this was a graph

1866
00:45:14,490 --> 00:45:16,420
 

1867
00:45:14,500 --> 00:45:19,660
 coloring problem that involved about

1868
00:45:16,410 --> 00:45:19,660
 

1869
00:45:16,420 --> 00:45:21,970
 three thousand nodes about 25 different

1870
00:45:19,650 --> 00:45:21,970
 

1871
00:45:19,660 --> 00:45:23,680
 colors to color the graph and about

1872
00:45:21,960 --> 00:45:23,680
 

1873
00:45:21,970 --> 00:45:25,119
 three million different interference

1874
00:45:23,670 --> 00:45:25,119
 

1875
00:45:23,680 --> 00:45:27,040
 constraints between nodes in the graph

1876
00:45:25,109 --> 00:45:27,040
 

1877
00:45:25,119 --> 00:45:30,880
 and this was something we had to solve

1878
00:45:27,030 --> 00:45:30,880
 

1879
00:45:27,040 --> 00:45:33,040
 about 20 thousand times in a high-stakes

1880
00:45:30,870 --> 00:45:33,040
 

1881
00:45:30,880 --> 00:45:36,339
 auction in which billions of dollars

1882
00:45:33,030 --> 00:45:36,339
 

1883
00:45:33,040 --> 00:45:38,230
 were being traded now there was another

1884
00:45:36,329 --> 00:45:38,230
 

1885
00:45:36,339 --> 00:45:40,839
 really nice thing about this application

1886
00:45:38,220 --> 00:45:40,839
 

1887
00:45:38,230 --> 00:45:43,089
 which was if we didn't if we weren't

1888
00:45:40,829 --> 00:45:43,089
 

1889
00:45:40,839 --> 00:45:45,010
 able to solve an instance disastrous

1890
00:45:43,079 --> 00:45:45,010
 

1891
00:45:43,089 --> 00:45:46,359
 things didn't happen to us if we

1892
00:45:45,000 --> 00:45:46,359
 

1893
00:45:45,010 --> 00:45:48,310
 couldn't come back with an answer about

1894
00:45:46,349 --> 00:45:48,310
 

1895
00:45:46,359 --> 00:45:49,900
 whether a station was repack about we

1896
00:45:48,300 --> 00:45:49,900
 

1897
00:45:48,310 --> 00:45:53,349
 would just decide that it wasn't repack

1898
00:45:49,890 --> 00:45:53,349
 

1899
00:45:49,900 --> 00:45:55,119
 a ball and that that was okay that just

1900
00:45:53,339 --> 00:45:55,119
 

1901
00:45:53,349 --> 00:45:56,650
 made mean we would freeze them at too

1902
00:45:55,109 --> 00:45:56,650
 

1903
00:45:55,119 --> 00:45:58,510
 high a price we might pay them more than

1904
00:45:56,640 --> 00:45:58,510
 

1905
00:45:56,650 --> 00:46:01,150
 we should pay them but a disaster

1906
00:45:58,500 --> 00:46:01,150
 

1907
00:45:58,510 --> 00:46:02,980
 wouldn't strike but every time we could

1908
00:46:01,140 --> 00:46:02,980
 

1909
00:46:01,150 --> 00:46:06,099
 get a little bit better at solving more

1910
00:46:02,970 --> 00:46:06,099
 

1911
00:46:02,980 --> 00:46:07,420
 optimization problems we would prevent

1912
00:46:06,089 --> 00:46:07,420
 

1913
00:46:06,099 --> 00:46:09,510
 the government from over paying and

1914
00:46:07,410 --> 00:46:09,510
 

1915
00:46:07,420 --> 00:46:11,770
 because prices fell geometrically

1916
00:46:09,500 --> 00:46:11,770
 

1917
00:46:09,510 --> 00:46:14,230
 starting prices for each station were in

1918
00:46:11,760 --> 00:46:14,230
 

1919
00:46:11,770 --> 00:46:16,030
 the tens of millions of dollars so we

1920
00:46:14,220 --> 00:46:16,030
 

1921
00:46:14,230 --> 00:46:17,829
 could really make enormous differences

1922
00:46:16,020 --> 00:46:17,829
 

1923
00:46:16,030 --> 00:46:19,210
 in how much money the government had to

1924
00:46:17,819 --> 00:46:19,210
 

1925
00:46:17,829 --> 00:46:23,200
 pay by solving just a handful of

1926
00:46:19,200 --> 00:46:23,200
 

1927
00:46:19,210 --> 00:46:24,220
 problems better and so what was cool

1928
00:46:23,190 --> 00:46:24,220
 

1929
00:46:23,200 --> 00:46:27,460
 about this from an algorithm

1930
00:46:24,210 --> 00:46:27,460
 

1931
00:46:24,220 --> 00:46:28,839
 configuration perspective is we knew

1932
00:46:27,450 --> 00:46:28,839
 

1933
00:46:27,460 --> 00:46:30,579
 that we wanted an algorithm that worked

1934
00:46:28,829 --> 00:46:30,579
 

1935
00:46:28,839 --> 00:46:32,230
 on the constraint graph of the United

1936
00:46:30,569 --> 00:46:32,230
 

1937
00:46:30,579 --> 00:46:34,329
 States it didn't have to work in China

1938
00:46:32,220 --> 00:46:34,329
 

1939
00:46:32,230 --> 00:46:36,220
 it didn't have to work in Europe it had

1940
00:46:34,319 --> 00:46:36,220
 

1941
00:46:34,329 --> 00:46:37,780
 to work on you know sub graphs of this

1942
00:46:36,210 --> 00:46:37,780
 

1943
00:46:36,220 --> 00:46:41,460
 given constraint graph so it was

1944
00:46:37,770 --> 00:46:41,460
 

1945
00:46:37,780 --> 00:46:44,930
 enormous but it was well understood so

1946
00:46:41,450 --> 00:46:44,930
 

1947
00:46:41,460 --> 00:46:46,700
 to get data for doing this analysis

1948
00:46:44,920 --> 00:46:46,700
 

1949
00:46:44,930 --> 00:46:49,400
 wrote a full reverse auction simulator

1950
00:46:46,690 --> 00:46:49,400
 

1951
00:46:46,700 --> 00:46:51,410
 which is its own talk it was a daunting

1952
00:46:49,390 --> 00:46:51,410
 

1953
00:46:49,400 --> 00:46:54,020
 thing but anyway we built it we

1954
00:46:51,400 --> 00:46:54,020
 

1955
00:46:51,410 --> 00:46:55,970
 generated station valuations and then we

1956
00:46:54,010 --> 00:46:55,970
 

1957
00:46:54,020 --> 00:46:57,530
 simulated auctions to see the problems

1958
00:46:55,960 --> 00:46:57,530
 

1959
00:46:55,970 --> 00:46:59,630
 that would actually arise in a simulated

1960
00:46:57,520 --> 00:46:59,630
 

1961
00:46:57,530 --> 00:47:02,120
 auction and and in this way we generated

1962
00:46:59,620 --> 00:47:02,120
 

1963
00:46:59,630 --> 00:47:03,950
 about 60,000 problems and our goal was

1964
00:47:02,110 --> 00:47:03,950
 

1965
00:47:02,120 --> 00:47:06,500
 to solve problems within a one-minute

1966
00:47:03,940 --> 00:47:06,500
 

1967
00:47:03,950 --> 00:47:08,270
 cutoff so when I first got involved in

1968
00:47:06,490 --> 00:47:08,270
 

1969
00:47:06,500 --> 00:47:09,980
 the project the FCC was thinking about

1970
00:47:08,260 --> 00:47:09,980
 

1971
00:47:08,270 --> 00:47:11,960
 using mixed integer programming solvers

1972
00:47:09,970 --> 00:47:11,960
 

1973
00:47:09,980 --> 00:47:14,600
 and this is how well they were able to

1974
00:47:11,950 --> 00:47:14,600
 

1975
00:47:11,960 --> 00:47:17,210
 do so on this graph on the x-axis you

1976
00:47:14,590 --> 00:47:17,210
 

1977
00:47:14,600 --> 00:47:19,040
 see run time on a log scale and on the

1978
00:47:17,200 --> 00:47:19,040
 

1979
00:47:17,210 --> 00:47:20,720
 y-axis you see the fraction of the

1980
00:47:19,030 --> 00:47:20,720
 

1981
00:47:19,040 --> 00:47:22,340
 non-trivial problems that we encountered

1982
00:47:20,710 --> 00:47:22,340
 

1983
00:47:20,720 --> 00:47:24,380
 that were solvable by the solver within

1984
00:47:22,330 --> 00:47:24,380
 

1985
00:47:22,340 --> 00:47:27,020
 the one minute cut off and this was

1986
00:47:24,370 --> 00:47:27,020
 

1987
00:47:24,380 --> 00:47:29,810
 appallingly bad you see SEAPLEX could

1988
00:47:27,010 --> 00:47:29,810
 

1989
00:47:27,020 --> 00:47:32,330
 solve about 15% of the problems in guro

1990
00:47:29,800 --> 00:47:32,330
 

1991
00:47:29,810 --> 00:47:33,530
 B could solve about 1/3 so we could not

1992
00:47:32,320 --> 00:47:33,530
 

1993
00:47:32,330 --> 00:47:34,730
 have run an auction this way we would

1994
00:47:33,520 --> 00:47:34,730
 

1995
00:47:33,530 --> 00:47:37,610
 have been paying all kinds of people

1996
00:47:34,720 --> 00:47:37,610
 

1997
00:47:34,730 --> 00:47:39,710
 super high prices so the first thing we

1998
00:47:37,600 --> 00:47:39,710
 

1999
00:47:37,610 --> 00:47:41,360
 noticed was this sounded a lot more like

2000
00:47:39,700 --> 00:47:41,360
 

2001
00:47:39,710 --> 00:47:42,920
 a satisfiability problem than a mixed

2002
00:47:41,350 --> 00:47:42,920
 

2003
00:47:41,360 --> 00:47:44,240
 integer programming problem because it's

2004
00:47:42,910 --> 00:47:44,240
 

2005
00:47:42,920 --> 00:47:45,980
 graph coloring there were there's no

2006
00:47:44,230 --> 00:47:45,980
 

2007
00:47:44,240 --> 00:47:48,200
 objective function there no real values

2008
00:47:45,970 --> 00:47:48,200
 

2009
00:47:45,980 --> 00:47:50,300
 and there are tons of Sat solvers out

2010
00:47:48,190 --> 00:47:50,300
 

2011
00:47:48,200 --> 00:47:51,710
 there so we took kind of every SATs over

2012
00:47:50,290 --> 00:47:51,710
 

2013
00:47:50,300 --> 00:47:53,420
 in the world and tried running it on

2014
00:47:51,700 --> 00:47:53,420
 

2015
00:47:51,710 --> 00:47:56,780
 this problem and they were indeed much

2016
00:47:53,410 --> 00:47:56,780
 

2017
00:47:53,420 --> 00:47:59,600
 better but the best among them could get

2018
00:47:56,770 --> 00:47:59,600
 

2019
00:47:56,780 --> 00:48:02,450
 up to sort of 80% accuracy at local

2020
00:47:59,590 --> 00:48:02,450
 

2021
00:47:59,600 --> 00:48:04,100
 search level called G novelty plus and

2022
00:48:02,440 --> 00:48:04,100
 

2023
00:48:02,450 --> 00:48:05,510
 some of them were much worse I you see

2024
00:48:04,090 --> 00:48:05,510
 

2025
00:48:04,100 --> 00:48:07,340
 statins dine here that I told you about

2026
00:48:05,500 --> 00:48:07,340
 

2027
00:48:05,510 --> 00:48:10,550
 before is the dark blue line that just

2028
00:48:07,330 --> 00:48:10,550
 

2029
00:48:07,340 --> 00:48:12,470
 flatlines it did alright for a while but

2030
00:48:10,540 --> 00:48:12,470
 

2031
00:48:10,550 --> 00:48:17,570
 but been just saturates down at about

2032
00:48:12,460 --> 00:48:17,570
 

2033
00:48:12,470 --> 00:48:20,600
 30% so but but still 80% was definitely

2034
00:48:17,560 --> 00:48:20,600
 

2035
00:48:17,570 --> 00:48:22,340
 not good enough for us so then we we did

2036
00:48:20,590 --> 00:48:22,340
 

2037
00:48:20,600 --> 00:48:23,960
 what I've been arguing throughout this

2038
00:48:22,330 --> 00:48:23,960
 

2039
00:48:22,340 --> 00:48:25,930
 talk that you would want to do we set up

2040
00:48:23,950 --> 00:48:25,930
 

2041
00:48:23,960 --> 00:48:28,850
 an algorithm design hypothesis space

2042
00:48:25,920 --> 00:48:28,850
 

2043
00:48:25,930 --> 00:48:30,320
 that said you do want to use a complete

2044
00:48:28,840 --> 00:48:30,320
 

2045
00:48:28,850 --> 00:48:32,360
 solver do you want to use a local search

2046
00:48:30,310 --> 00:48:32,360
 

2047
00:48:30,320 --> 00:48:34,310
 solver and conditional on that choice

2048
00:48:32,350 --> 00:48:34,310
 

2049
00:48:32,360 --> 00:48:36,890
 which solver parameters and conditional

2050
00:48:34,300 --> 00:48:36,890
 

2051
00:48:34,310 --> 00:48:38,690
 on that choice which sub parameters plus

2052
00:48:36,880 --> 00:48:38,690
 

2053
00:48:36,890 --> 00:48:40,310
 we also thought of various problem

2054
00:48:38,680 --> 00:48:40,310
 

2055
00:48:38,690 --> 00:48:42,800
 specific speed ups that might or might

2056
00:48:40,300 --> 00:48:42,800
 

2057
00:48:40,310 --> 00:48:44,870
 not be a good idea like various ways of

2058
00:48:42,790 --> 00:48:44,870
 

2059
00:48:42,800 --> 00:48:47,450
 reusing past solutions and decomposing

2060
00:48:44,860 --> 00:48:47,450
 

2061
00:48:44,870 --> 00:48:48,650
 the problem and caching schemes and then

2062
00:48:47,440 --> 00:48:48,650
 

2063
00:48:47,450 --> 00:48:51,800
 we thought about other problem

2064
00:48:48,640 --> 00:48:51,800
 

2065
00:48:48,650 --> 00:48:53,330
 independent heuristics like constraint

2066
00:48:51,790 --> 00:48:53,330
 

2067
00:48:51,800 --> 00:48:55,310
 propagation and different ways of

2068
00:48:53,320 --> 00:48:55,310
 

2069
00:48:53,330 --> 00:48:57,080
 encoding the problem into sat and we

2070
00:48:55,300 --> 00:48:57,080
 

2071
00:48:55,310 --> 00:48:58,710
 took all of this and made this enormous

2072
00:48:57,070 --> 00:48:58,710
 

2073
00:48:57,080 --> 00:49:00,330
 design space

2074
00:48:58,700 --> 00:49:00,330
 

2075
00:48:58,710 --> 00:49:02,520
 and we gave it to an algorithm

2076
00:49:00,320 --> 00:49:02,520
 

2077
00:49:00,330 --> 00:49:04,380
 configurator which is Frank will tell

2078
00:49:02,510 --> 00:49:04,380
 

2079
00:49:02,520 --> 00:49:07,470
 you about how it works in a minute and

2080
00:49:04,370 --> 00:49:07,470
 

2081
00:49:04,380 --> 00:49:09,120
 here's what we got so the you see the

2082
00:49:07,460 --> 00:49:09,120
 

2083
00:49:07,470 --> 00:49:11,640
 best Sat algorithm was previously

2084
00:49:09,110 --> 00:49:11,640
 

2085
00:49:09,120 --> 00:49:13,440
 getting 80% and saben stein which I

2086
00:49:11,630 --> 00:49:13,440
 

2087
00:49:11,640 --> 00:49:14,760
 mentioned to you before turns out to

2088
00:49:13,430 --> 00:49:14,760
 

2089
00:49:13,440 --> 00:49:15,840
 have been the best thing we configured

2090
00:49:14,750 --> 00:49:15,840
 

2091
00:49:14,760 --> 00:49:18,870
 all kinds of different things

2092
00:49:15,830 --> 00:49:18,870
 

2093
00:49:15,840 --> 00:49:21,510
 but Simon's done got up to about 93%

2094
00:49:18,860 --> 00:49:21,510
 

2095
00:49:18,870 --> 00:49:23,340
 accuracy by itself just by running

2096
00:49:21,500 --> 00:49:23,340
 

2097
00:49:21,510 --> 00:49:24,870
 algorithm configuration so really

2098
00:49:23,330 --> 00:49:24,870
 

2099
00:49:23,340 --> 00:49:26,790
 enormous scope for things to get better

2100
00:49:24,860 --> 00:49:26,790
 

2101
00:49:24,870 --> 00:49:30,540
 it also got much faster on the shorter

2102
00:49:26,780 --> 00:49:30,540
 

2103
00:49:26,790 --> 00:49:33,270
 easier problems we weren't content with

2104
00:49:30,530 --> 00:49:33,270
 

2105
00:49:30,540 --> 00:49:34,860
 that though because we know from our

2106
00:49:33,260 --> 00:49:34,860
 

2107
00:49:33,270 --> 00:49:36,330
 past experience that often different

2108
00:49:34,850 --> 00:49:36,330
 

2109
00:49:34,860 --> 00:49:39,240
 solvers perform well on different

2110
00:49:36,320 --> 00:49:39,240
 

2111
00:49:36,330 --> 00:49:41,100
 instances so it makes sense sometimes to

2112
00:49:39,230 --> 00:49:41,100
 

2113
00:49:39,240 --> 00:49:42,720
 build an algorithm portfolio you know

2114
00:49:41,090 --> 00:49:42,720
 

2115
00:49:41,100 --> 00:49:45,030
 just as you wouldn't want to hold one

2116
00:49:42,710 --> 00:49:45,030
 

2117
00:49:42,720 --> 00:49:46,950
 stock it can make more sense to hold a

2118
00:49:45,020 --> 00:49:46,950
 

2119
00:49:45,030 --> 00:49:49,290
 stock portfolio you might not want to

2120
00:49:46,940 --> 00:49:49,290
 

2121
00:49:46,950 --> 00:49:51,030
 bet on one algorithm it might be good to

2122
00:49:49,280 --> 00:49:51,030
 

2123
00:49:49,290 --> 00:49:53,970
 kind of use an ensemble method of

2124
00:49:51,020 --> 00:49:53,970
 

2125
00:49:51,030 --> 00:49:55,470
 different algorithms we've over the

2126
00:49:53,960 --> 00:49:55,470
 

2127
00:49:53,970 --> 00:49:55,890
 years developed something called sat

2128
00:49:55,460 --> 00:49:55,890
 

2129
00:49:55,470 --> 00:49:57,720
 Zilla

2130
00:49:55,880 --> 00:49:57,720
 

2131
00:49:55,890 --> 00:49:59,190
 which is an algorithm portfolio that

2132
00:49:57,710 --> 00:49:59,190
 

2133
00:49:57,720 --> 00:50:01,470
 uses machine learning to choose

2134
00:49:59,180 --> 00:50:01,470
 

2135
00:49:59,190 --> 00:50:03,030
 algorithms on a per instance basis but

2136
00:50:01,460 --> 00:50:03,030
 

2137
00:50:01,470 --> 00:50:05,340
 you can also just run all the algorithms

2138
00:50:03,020 --> 00:50:05,340
 

2139
00:50:03,030 --> 00:50:07,280
 together in parallel which works if you

2140
00:50:05,330 --> 00:50:07,280
 

2141
00:50:05,340 --> 00:50:11,130
 have a small number of algorithms and

2142
00:50:07,270 --> 00:50:11,130
 

2143
00:50:07,280 --> 00:50:13,230
 lots of computers we have a method

2144
00:50:11,120 --> 00:50:13,230
 

2145
00:50:11,130 --> 00:50:15,060
 called Hydra which is a way of using

2146
00:50:13,220 --> 00:50:15,060
 

2147
00:50:13,230 --> 00:50:17,240
 algorithm configuration to learn a

2148
00:50:15,050 --> 00:50:17,240
 

2149
00:50:15,060 --> 00:50:19,650
 portfolio of complementary algorithms

2150
00:50:17,230 --> 00:50:19,650
 

2151
00:50:17,240 --> 00:50:22,530
 and basically it works because of the

2152
00:50:19,640 --> 00:50:22,530
 

2153
00:50:19,650 --> 00:50:23,970
 fact that our performance objective as a

2154
00:50:22,520 --> 00:50:23,970
 

2155
00:50:22,530 --> 00:50:26,820
 function of the number of algorithms is

2156
00:50:23,960 --> 00:50:26,820
 

2157
00:50:23,970 --> 00:50:28,560
 sub modular so every time I get

2158
00:50:26,810 --> 00:50:28,560
 

2159
00:50:26,820 --> 00:50:29,610
 decreasing marginal returns by adding an

2160
00:50:28,550 --> 00:50:29,610
 

2161
00:50:28,560 --> 00:50:31,260
 algorithm to bigger and bigger

2162
00:50:29,600 --> 00:50:31,260
 

2163
00:50:29,610 --> 00:50:33,690
 portfolios and that means it makes sense

2164
00:50:31,250 --> 00:50:33,690
 

2165
00:50:31,260 --> 00:50:35,790
 to kind of greedily add one algorithm at

2166
00:50:33,680 --> 00:50:35,790
 

2167
00:50:33,690 --> 00:50:37,290
 a time and then update my objective

2168
00:50:35,780 --> 00:50:37,290
 

2169
00:50:35,790 --> 00:50:38,870
 function to be the marginal gains that

2170
00:50:37,280 --> 00:50:38,870
 

2171
00:50:37,290 --> 00:50:41,850
 I'm getting over the current portfolio

2172
00:50:38,860 --> 00:50:41,850
 

2173
00:50:38,870 --> 00:50:44,130
 so we did that and and we eventually

2174
00:50:41,840 --> 00:50:44,130
 

2175
00:50:41,850 --> 00:50:46,020
 build something we called sat FC which

2176
00:50:44,120 --> 00:50:46,020
 

2177
00:50:44,130 --> 00:50:47,790
 is the the dark line at the top here

2178
00:50:46,010 --> 00:50:47,790
 

2179
00:50:46,020 --> 00:50:51,020
 there was now getting something like I

2180
00:50:47,780 --> 00:50:51,020
 

2181
00:50:47,790 --> 00:50:54,300
 think 96 or 97 percent solution quality

2182
00:50:51,010 --> 00:50:54,300
 

2183
00:50:51,020 --> 00:50:56,610
 and the last thing I want to tell you is

2184
00:50:54,290 --> 00:50:56,610
 

2185
00:50:54,300 --> 00:50:58,440
 I mean this should didn't demonstrate to

2186
00:50:56,600 --> 00:50:58,440
 

2187
00:50:56,610 --> 00:51:00,030
 you that this algorithm worked

2188
00:50:58,430 --> 00:51:00,030
 

2189
00:50:58,440 --> 00:51:01,940
 dramatically better than anything we

2190
00:51:00,020 --> 00:51:01,940
 

2191
00:51:00,030 --> 00:51:04,470
 could find without configuration

2192
00:51:01,930 --> 00:51:04,470
 

2193
00:51:01,940 --> 00:51:06,150
 hardening Lee it also turns out that it

2194
00:51:04,460 --> 00:51:06,150
 

2195
00:51:04,470 --> 00:51:08,280
 made an enormous difference to the

2196
00:51:06,140 --> 00:51:08,280
 

2197
00:51:06,150 --> 00:51:09,330
 outcome of the auction so at least based

2198
00:51:08,270 --> 00:51:09,330
 

2199
00:51:08,280 --> 00:51:11,160
 on our simulations

2200
00:51:09,320 --> 00:51:11,160
 

2201
00:51:09,330 --> 00:51:13,320
 we've tried running our similar

2202
00:51:11,150 --> 00:51:13,320
 

2203
00:51:11,160 --> 00:51:16,770
 where we swap in different algorithms of

2204
00:51:13,310 --> 00:51:16,770
 

2205
00:51:13,320 --> 00:51:18,570
 different quality and we can measure how

2206
00:51:16,760 --> 00:51:18,570
 

2207
00:51:16,770 --> 00:51:20,190
 much would it cost the government to run

2208
00:51:18,560 --> 00:51:20,190
 

2209
00:51:18,570 --> 00:51:22,500
 the algorithm with these different

2210
00:51:20,180 --> 00:51:22,500
 

2211
00:51:20,190 --> 00:51:24,840
 solvers and how much loss in efficiency

2212
00:51:22,490 --> 00:51:24,840
 

2213
00:51:22,500 --> 00:51:26,700
 how much better a job of picking the

2214
00:51:24,830 --> 00:51:26,700
 

2215
00:51:24,840 --> 00:51:30,660
 high-value stations would the auction do

2216
00:51:26,690 --> 00:51:30,660
 

2217
00:51:26,700 --> 00:51:35,070
 and you see SEAPLEX and Goro B are the

2218
00:51:30,650 --> 00:51:35,070
 

2219
00:51:30,660 --> 00:51:36,960
 purple and blue dots as we move to

2220
00:51:35,060 --> 00:51:36,960
 

2221
00:51:35,070 --> 00:51:38,730
 better and better set solvers we we get

2222
00:51:36,950 --> 00:51:38,730
 

2223
00:51:36,960 --> 00:51:41,160
 better in both dimensions and we end up

2224
00:51:38,720 --> 00:51:41,160
 

2225
00:51:38,730 --> 00:51:42,480
 saving billions of dollars and also you

2226
00:51:41,150 --> 00:51:42,480
 

2227
00:51:41,160 --> 00:51:45,360
 know doing a better a better job of

2228
00:51:42,470 --> 00:51:45,360
 

2229
00:51:42,480 --> 00:51:47,160
 buying out the right station so in the

2230
00:51:45,350 --> 00:51:47,160
 

2231
00:51:45,360 --> 00:51:48,600
 end I you know I think this really

2232
00:51:47,150 --> 00:51:48,600
 

2233
00:51:47,160 --> 00:51:50,310
 demonstrated all of the bells and

2234
00:51:48,590 --> 00:51:50,310
 

2235
00:51:48,600 --> 00:51:52,110
 whistles of algorithm configuration and

2236
00:51:50,300 --> 00:51:52,110
 

2237
00:51:50,310 --> 00:51:52,530
 showed that it's really ready for

2238
00:51:52,100 --> 00:51:52,530
 

2239
00:51:52,110 --> 00:51:55,140
 primetime

2240
00:51:52,520 --> 00:51:55,140
 

2241
00:51:52,530 --> 00:51:57,030
 so having said all of that I want to

2242
00:51:55,130 --> 00:51:57,030
 

2243
00:51:55,140 --> 00:51:58,890
 hand off to Frank who hopefully have

2244
00:51:57,020 --> 00:51:58,890
 

2245
00:51:57,030 --> 00:52:00,870
 rabbit whetted your appetite to find out

2246
00:51:58,880 --> 00:52:00,870
 

2247
00:51:58,890 --> 00:52:11,130
 how this stuff actually works and he'll

2248
00:52:00,860 --> 00:52:11,130
 

2249
00:52:00,870 --> 00:52:13,230
 start telling you thanks Karen yeah so

2250
00:52:11,120 --> 00:52:13,230
 

2251
00:52:11,130 --> 00:52:15,900
 I'm going to talk about the practical

2252
00:52:13,220 --> 00:52:15,900
 

2253
00:52:13,230 --> 00:52:17,600
 part of algorithm configuration in this

2254
00:52:15,890 --> 00:52:17,600
 

2255
00:52:15,900 --> 00:52:19,650
 part I'll first tell you about

2256
00:52:17,590 --> 00:52:19,650
 

2257
00:52:17,600 --> 00:52:21,360
 sequential model based algorithm

2258
00:52:19,640 --> 00:52:21,360
 

2259
00:52:19,650 --> 00:52:24,320
 configuration which is actually the

2260
00:52:21,350 --> 00:52:24,320
 

2261
00:52:21,360 --> 00:52:26,340
 algorithm that Kevin used in this FCC

2262
00:52:24,310 --> 00:52:26,340
 

2263
00:52:24,320 --> 00:52:30,240
 competition in order to configure these

2264
00:52:26,330 --> 00:52:30,240
 

2265
00:52:26,340 --> 00:52:32,010
 algorithms it turns out that SMAC is a

2266
00:52:30,230 --> 00:52:32,010
 

2267
00:52:30,240 --> 00:52:33,330
 Bayesian optimization algorithm so next

2268
00:52:32,000 --> 00:52:33,330
 

2269
00:52:32,010 --> 00:52:35,880
 I'll tell you a little bit about the

2270
00:52:33,320 --> 00:52:35,880
 

2271
00:52:33,330 --> 00:52:37,770
 details of how we attack the base an

2272
00:52:35,870 --> 00:52:37,770
 

2273
00:52:35,880 --> 00:52:41,460
 optimization problem in this space of

2274
00:52:37,760 --> 00:52:41,460
 

2275
00:52:37,770 --> 00:52:43,050
 algorithms then I'm also going to cover

2276
00:52:41,450 --> 00:52:43,050
 

2277
00:52:41,460 --> 00:52:45,150
 some other algorithm configuration

2278
00:52:43,040 --> 00:52:45,150
 

2279
00:52:43,050 --> 00:52:49,290
 methods out there and then show you some

2280
00:52:45,140 --> 00:52:49,290
 

2281
00:52:45,150 --> 00:52:50,490
 more case studies and evaluations and

2282
00:52:49,280 --> 00:52:50,490
 

2283
00:52:49,290 --> 00:52:52,980
 after that we're going to have some time

2284
00:52:50,480 --> 00:52:52,980
 

2285
00:52:50,490 --> 00:52:57,870
 for questions and then the theoretical

2286
00:52:52,970 --> 00:52:57,870
 

2287
00:52:52,980 --> 00:53:00,960
 part and then more extensions so recall

2288
00:52:57,860 --> 00:53:00,960
 

2289
00:52:57,870 --> 00:53:02,910
 what what Kevin told you about the

2290
00:53:00,950 --> 00:53:02,910
 

2291
00:53:00,960 --> 00:53:06,600
 algorithm configuration problem so we

2292
00:53:02,900 --> 00:53:06,600
 

2293
00:53:02,910 --> 00:53:08,910
 have this goal of finding a single

2294
00:53:06,590 --> 00:53:08,910
 

2295
00:53:06,600 --> 00:53:11,700
 static configuration that does well on

2296
00:53:08,900 --> 00:53:11,700
 

2297
00:53:08,910 --> 00:53:14,070
 average across the instances from this

2298
00:53:11,690 --> 00:53:14,070
 

2299
00:53:11,700 --> 00:53:16,050
 distribution so there's two components

2300
00:53:14,060 --> 00:53:16,050
 

2301
00:53:14,070 --> 00:53:18,540
 that augurs and configuration methods

2302
00:53:16,040 --> 00:53:18,540
 

2303
00:53:16,050 --> 00:53:21,210
 need to have in some sense or the other

2304
00:53:18,530 --> 00:53:21,210
 

2305
00:53:18,540 --> 00:53:23,100
 so we first need to select new

2306
00:53:21,200 --> 00:53:23,100
 

2307
00:53:21,210 --> 00:53:24,810
 configurations that we actually want to

2308
00:53:23,090 --> 00:53:24,810
 

2309
00:53:23,100 --> 00:53:26,730
 evaluate

2310
00:53:24,800 --> 00:53:26,730
 

2311
00:53:24,810 --> 00:53:29,790
 this really large combinatorial space

2312
00:53:26,720 --> 00:53:29,790
 

2313
00:53:26,730 --> 00:53:32,670
 and then when we have them it's actually

2314
00:53:29,780 --> 00:53:32,670
 

2315
00:53:29,790 --> 00:53:34,740
 non-trivial how we evaluate them and how

2316
00:53:32,660 --> 00:53:34,740
 

2317
00:53:32,670 --> 00:53:36,720
 we compare them against the best thing

2318
00:53:34,730 --> 00:53:36,720
 

2319
00:53:34,740 --> 00:53:38,670
 we have so far so it's not just a black

2320
00:53:36,710 --> 00:53:38,670
 

2321
00:53:36,720 --> 00:53:41,250
 box optimization problem where you then

2322
00:53:38,660 --> 00:53:41,250
 

2323
00:53:38,670 --> 00:53:43,370
 query the function but well there's this

2324
00:53:41,240 --> 00:53:43,370
 

2325
00:53:41,250 --> 00:53:46,410
 question how many instances do you run

2326
00:53:43,360 --> 00:53:46,410
 

2327
00:53:43,370 --> 00:53:51,540
 which runtimes to use for each of these

2328
00:53:46,400 --> 00:53:51,540
 

2329
00:53:46,410 --> 00:53:54,390
 instances etc and so what what smack

2330
00:53:51,530 --> 00:53:54,390
 

2331
00:53:51,540 --> 00:53:56,490
 does is use these algorithm runtime

2332
00:53:54,380 --> 00:53:56,490
 

2333
00:53:54,390 --> 00:53:59,190
 prediction methods that Kevin talked

2334
00:53:56,480 --> 00:53:59,190
 

2335
00:53:56,490 --> 00:54:00,900
 about to learn a model from some

2336
00:53:59,180 --> 00:54:00,900
 

2337
00:53:59,190 --> 00:54:02,100
 performance data that we've collected so

2338
00:54:00,890 --> 00:54:02,100
 

2339
00:54:00,900 --> 00:54:04,530
 far it's going to be an active learning

2340
00:54:02,090 --> 00:54:04,530
 

2341
00:54:02,100 --> 00:54:06,360
 algorithm and then use this model in

2342
00:54:04,520 --> 00:54:06,360
 

2343
00:54:04,530 --> 00:54:09,180
 order to set select promising

2344
00:54:06,350 --> 00:54:09,180
 

2345
00:54:06,360 --> 00:54:11,460
 configurations and then it takes these

2346
00:54:09,170 --> 00:54:11,460
 

2347
00:54:09,180 --> 00:54:14,970
 configurations and compares them against

2348
00:54:11,450 --> 00:54:14,970
 

2349
00:54:11,460 --> 00:54:16,860
 the best configuration so far and yeah

2350
00:54:14,960 --> 00:54:16,860
 

2351
00:54:14,970 --> 00:54:19,940
 you initialize it by some runs in repeat

2352
00:54:16,850 --> 00:54:19,940
 

2353
00:54:16,860 --> 00:54:23,010
 until times updates and anytime Ivor's

2354
00:54:19,930 --> 00:54:23,010
 

2355
00:54:19,940 --> 00:54:24,990
 so this first part here that's going to

2356
00:54:23,000 --> 00:54:24,990
 

2357
00:54:23,010 --> 00:54:26,250
 be based on optimization and the second

2358
00:54:24,980 --> 00:54:26,250
 

2359
00:54:24,990 --> 00:54:30,150
 part I'm going to tell you about

2360
00:54:26,240 --> 00:54:30,150
 

2361
00:54:26,250 --> 00:54:33,450
 afterwards but here I'm only going to

2362
00:54:30,140 --> 00:54:33,450
 

2363
00:54:30,150 --> 00:54:35,160
 give you the brief update on you know

2364
00:54:33,440 --> 00:54:35,160
 

2365
00:54:33,450 --> 00:54:37,380
 what what is based on optimization and

2366
00:54:35,150 --> 00:54:37,380
 

2367
00:54:35,160 --> 00:54:39,930
 then in the next section I'm gonna dig

2368
00:54:37,370 --> 00:54:39,930
 

2369
00:54:37,380 --> 00:54:42,210
 and deeper into how exactly do we use

2370
00:54:39,920 --> 00:54:42,210
 

2371
00:54:39,930 --> 00:54:43,860
 base and optimization for this so based

2372
00:54:42,200 --> 00:54:43,860
 

2373
00:54:42,210 --> 00:54:46,260
 on optimization is a very generic

2374
00:54:43,850 --> 00:54:46,260
 

2375
00:54:43,860 --> 00:54:49,080
 approach from the statistics literature

2376
00:54:46,250 --> 00:54:49,080
 

2377
00:54:46,260 --> 00:54:51,480
 it fits a probabilistic model to the

2378
00:54:49,070 --> 00:54:51,480
 

2379
00:54:49,080 --> 00:54:54,900
 collected function sample so so here we

2380
00:54:51,470 --> 00:54:54,900
 

2381
00:54:51,480 --> 00:54:57,810
 are in this black box setting so we have

2382
00:54:54,890 --> 00:54:57,810
 

2383
00:54:54,900 --> 00:55:00,300
 a function that's a true objective here

2384
00:54:57,800 --> 00:55:00,300
 

2385
00:54:57,810 --> 00:55:02,280
 so you can think of this as one

2386
00:55:00,290 --> 00:55:02,280
 

2387
00:55:00,300 --> 00:55:04,020
 parameter of your algorithm and I can

2388
00:55:02,270 --> 00:55:04,020
 

2389
00:55:02,280 --> 00:55:06,240
 only plot this with one parameter but of

2390
00:55:04,010 --> 00:55:06,240
 

2391
00:55:04,020 --> 00:55:07,980
 course it works in many dimensions so

2392
00:55:06,230 --> 00:55:07,980
 

2393
00:55:06,240 --> 00:55:10,440
 you have this true objective and you

2394
00:55:07,970 --> 00:55:10,440
 

2395
00:55:07,980 --> 00:55:13,020
 have evaluated different settings of

2396
00:55:10,430 --> 00:55:13,020
 

2397
00:55:10,440 --> 00:55:14,850
 your algorithm and so you have in this

2398
00:55:13,010 --> 00:55:14,850
 

2399
00:55:13,020 --> 00:55:16,260
 black box setting you have evaluated the

2400
00:55:14,840 --> 00:55:16,260
 

2401
00:55:14,850 --> 00:55:18,780
 function you know the function at those

2402
00:55:16,250 --> 00:55:18,780
 

2403
00:55:16,260 --> 00:55:20,910
 points then you fit some probabilistic

2404
00:55:18,770 --> 00:55:20,910
 

2405
00:55:18,780 --> 00:55:22,590
 model in in this case here a Gaussian

2406
00:55:20,900 --> 00:55:22,590
 

2407
00:55:20,910 --> 00:55:25,560
 process later on for us it will be a

2408
00:55:22,580 --> 00:55:25,560
 

2409
00:55:22,590 --> 00:55:28,650
 random forest in order to predict for

2410
00:55:25,550 --> 00:55:28,650
 

2411
00:55:25,560 --> 00:55:29,970
 new configurations what is going to be

2412
00:55:28,640 --> 00:55:29,970
 

2413
00:55:28,650 --> 00:55:31,800
 the performance and you also have an

2414
00:55:29,960 --> 00:55:31,800
 

2415
00:55:29,970 --> 00:55:34,050
 uncertainty estimate and then you use

2416
00:55:31,790 --> 00:55:34,050
 

2417
00:55:31,800 --> 00:55:36,210
 that in order to guide your optimization

2418
00:55:34,040 --> 00:55:36,210
 

2419
00:55:34,050 --> 00:55:38,370
 process trading off exploration versus

2420
00:55:36,200 --> 00:55:38,370
 

2421
00:55:36,210 --> 00:55:41,100
 exploitation through a so-called

2422
00:55:38,360 --> 00:55:41,100
 

2423
00:55:38,370 --> 00:55:43,530
 acquisition function so for example here

2424
00:55:41,090 --> 00:55:43,530
 

2425
00:55:41,100 --> 00:55:45,270
 so we we want to maximize in this case

2426
00:55:43,520 --> 00:55:45,270
 

2427
00:55:43,530 --> 00:55:49,500
 we want to have a high mean but also

2428
00:55:45,260 --> 00:55:49,500
 

2429
00:55:45,270 --> 00:55:51,570
 high uncertainty in order to look into

2430
00:55:49,490 --> 00:55:51,570
 

2431
00:55:49,500 --> 00:55:54,150
 new parts of the configuration space

2432
00:55:51,560 --> 00:55:54,150
 

2433
00:55:51,570 --> 00:55:56,370
 that we haven't explored so far so in

2434
00:55:54,140 --> 00:55:56,370
 

2435
00:55:54,150 --> 00:55:58,830
 this case we would evaluate this point

2436
00:55:56,360 --> 00:55:58,830
 

2437
00:55:56,370 --> 00:56:02,240
 next evaluate the function get this

2438
00:55:58,820 --> 00:56:02,240
 

2439
00:55:58,830 --> 00:56:04,350
 function value refit our model and

2440
00:56:02,230 --> 00:56:04,350
 

2441
00:56:02,240 --> 00:56:07,860
 recompute our acquisition function

2442
00:56:04,340 --> 00:56:07,860
 

2443
00:56:04,350 --> 00:56:09,480
 example here next and iterate until time

2444
00:56:07,850 --> 00:56:09,480
 

2445
00:56:07,860 --> 00:56:11,640
 is up so this is popular in the

2446
00:56:09,470 --> 00:56:11,640
 

2447
00:56:09,480 --> 00:56:12,510
 statistic literature it's very efficient

2448
00:56:11,630 --> 00:56:12,510
 

2449
00:56:11,640 --> 00:56:14,730
 in the number of function evaluations

2450
00:56:12,500 --> 00:56:14,730
 

2451
00:56:12,510 --> 00:56:17,070
 and then it works when the objective is

2452
00:56:14,720 --> 00:56:17,070
 

2453
00:56:14,730 --> 00:56:19,320
 not convex noisy has unknown derivatives

2454
00:56:17,060 --> 00:56:19,320
 

2455
00:56:17,070 --> 00:56:21,860
 etc so it's very very nice and it also

2456
00:56:19,310 --> 00:56:21,860
 

2457
00:56:19,320 --> 00:56:24,600
 has a recent convergence results for

2458
00:56:21,850 --> 00:56:24,600
 

2459
00:56:21,860 --> 00:56:26,370
 certain assumptions that unfortunately

2460
00:56:24,590 --> 00:56:26,370
 

2461
00:56:24,600 --> 00:56:30,690
 in the case of Ivor's and configuration

2462
00:56:26,360 --> 00:56:30,690
 

2463
00:56:26,370 --> 00:56:33,420
 with all its non stationarity etc are

2464
00:56:30,680 --> 00:56:33,420
 

2465
00:56:30,690 --> 00:56:35,790
 not really going to hold but for for

2466
00:56:33,410 --> 00:56:35,790
 

2467
00:56:33,420 --> 00:56:39,480
 nice function smooth functions etc you

2468
00:56:35,780 --> 00:56:39,480
 

2469
00:56:35,790 --> 00:56:40,680
 can actually prove convergence rates so

2470
00:56:39,470 --> 00:56:40,680
 

2471
00:56:39,480 --> 00:56:43,320
 as I said I'm going to talk more about

2472
00:56:40,670 --> 00:56:43,320
 

2473
00:56:40,680 --> 00:56:45,390
 based optimization later but suffice it

2474
00:56:43,310 --> 00:56:45,390
 

2475
00:56:43,320 --> 00:56:46,980
 to say that well we're going to use this

2476
00:56:45,380 --> 00:56:46,980
 

2477
00:56:45,390 --> 00:56:48,720
 based optimization in order to pick the

2478
00:56:46,970 --> 00:56:48,720
 

2479
00:56:46,980 --> 00:56:50,070
 configurations now I'm first going to

2480
00:56:48,710 --> 00:56:50,070
 

2481
00:56:48,720 --> 00:56:53,550
 talk about what do we actually do with

2482
00:56:50,060 --> 00:56:53,550
 

2483
00:56:50,070 --> 00:56:54,690
 these configurations so we're going to

2484
00:56:53,540 --> 00:56:54,690
 

2485
00:56:53,550 --> 00:56:57,060
 compare them against the best

2486
00:56:54,680 --> 00:56:57,060
 

2487
00:56:54,690 --> 00:56:58,350
 configuration found so far and the first

2488
00:56:57,050 --> 00:56:58,350
 

2489
00:56:57,060 --> 00:57:01,340
 natural question there is how many

2490
00:56:58,340 --> 00:57:01,340
 

2491
00:56:58,350 --> 00:57:04,890
 instances are we going to use for that

2492
00:57:01,330 --> 00:57:04,890
 

2493
00:57:01,340 --> 00:57:07,110
 and here recall that instance hardness

2494
00:57:04,880 --> 00:57:07,110
 

2495
00:57:04,890 --> 00:57:08,910
 actually varies there is some instances

2496
00:57:07,100 --> 00:57:08,910
 

2497
00:57:07,110 --> 00:57:11,490
 that are really easy we can solve them

2498
00:57:08,900 --> 00:57:11,490
 

2499
00:57:08,910 --> 00:57:14,010
 in milliseconds but others really take a

2500
00:57:11,480 --> 00:57:14,010
 

2501
00:57:11,490 --> 00:57:16,740
 long time hours or in the worst case

2502
00:57:14,000 --> 00:57:16,740
 

2503
00:57:14,010 --> 00:57:18,600
 with really poor configurations days or

2504
00:57:16,730 --> 00:57:18,600
 

2505
00:57:16,740 --> 00:57:20,940
 years or some configurations actually

2506
00:57:18,590 --> 00:57:20,940
 

2507
00:57:18,600 --> 00:57:22,980
 would never solve the instance and we

2508
00:57:20,930 --> 00:57:22,980
 

2509
00:57:20,940 --> 00:57:26,160
 aim to minimize cost in expectation

2510
00:57:22,970 --> 00:57:26,160
 

2511
00:57:22,980 --> 00:57:27,960
 across these instances so the simplest

2512
00:57:26,150 --> 00:57:27,960
 

2513
00:57:26,160 --> 00:57:29,310
 thing you could think of well I'm just

2514
00:57:27,950 --> 00:57:29,310
 

2515
00:57:27,960 --> 00:57:31,860
 going to pick some fixed number of

2516
00:57:29,300 --> 00:57:31,860
 

2517
00:57:29,310 --> 00:57:33,300
 instances and gonna use that for each of

2518
00:57:31,850 --> 00:57:33,300
 

2519
00:57:31,860 --> 00:57:35,670
 the evaluation casts this as a

2520
00:57:33,290 --> 00:57:35,670
 

2521
00:57:33,300 --> 00:57:38,130
 blackboard optimization problem and be

2522
00:57:35,660 --> 00:57:38,130
 

2523
00:57:35,670 --> 00:57:41,220
 done with that but that's not going to

2524
00:57:38,120 --> 00:57:41,220
 

2525
00:57:38,130 --> 00:57:43,470
 work because the question is how large

2526
00:57:41,210 --> 00:57:43,470
 

2527
00:57:41,220 --> 00:57:46,530
 do you choose n if you choose n too

2528
00:57:43,460 --> 00:57:46,530
 

2529
00:57:43,470 --> 00:57:48,750
 small then you're going to over tune to

2530
00:57:46,520 --> 00:57:48,750
 

2531
00:57:46,530 --> 00:57:50,710
 those instances so that's the same

2532
00:57:48,740 --> 00:57:50,710
 

2533
00:57:48,750 --> 00:57:51,910
 phenomenon as overfitting to

2534
00:57:50,700 --> 00:57:51,910
 

2535
00:57:50,710 --> 00:57:54,760
 particular part of your training

2536
00:57:51,900 --> 00:57:54,760
 

2537
00:57:51,910 --> 00:57:57,280
 distribution and if you're fit if you

2538
00:57:54,750 --> 00:57:57,280
 

2539
00:57:54,760 --> 00:57:58,930
 choose the end too large millions of

2540
00:57:57,270 --> 00:57:58,930
 

2541
00:57:57,280 --> 00:58:00,220
 instances for example well then every

2542
00:57:58,920 --> 00:58:00,220
 

2543
00:57:58,930 --> 00:58:02,350
 function evaluation is going to take

2544
00:58:00,210 --> 00:58:02,350
 

2545
00:58:00,220 --> 00:58:06,100
 forever and you're gonna be out of

2546
00:58:02,340 --> 00:58:06,100
 

2547
00:58:02,350 --> 00:58:08,080
 computer resources by by the time you

2548
00:58:06,090 --> 00:58:08,080
 

2549
00:58:06,100 --> 00:58:09,250
 ended up evaluating your first

2550
00:58:08,070 --> 00:58:09,250
 

2551
00:58:08,080 --> 00:58:11,860
 configuration and you're not going to

2552
00:58:09,240 --> 00:58:11,860
 

2553
00:58:09,250 --> 00:58:14,230
 make progress so neither of that of

2554
00:58:11,850 --> 00:58:14,230
 

2555
00:58:11,860 --> 00:58:16,150
 those are going to work and what we

2556
00:58:14,220 --> 00:58:16,150
 

2557
00:58:14,230 --> 00:58:17,710
 instead do is we raise new

2558
00:58:16,140 --> 00:58:17,710
 

2559
00:58:16,150 --> 00:58:20,890
 configurations against the best known

2560
00:58:17,700 --> 00:58:20,890
 

2561
00:58:17,710 --> 00:58:23,080
 configuration so far we actually use the

2562
00:58:20,880 --> 00:58:23,080
 

2563
00:58:20,890 --> 00:58:25,270
 same instances and the same seeds as we

2564
00:58:23,070 --> 00:58:25,270
 

2565
00:58:23,080 --> 00:58:26,830
 previously previously used for the

2566
00:58:25,260 --> 00:58:26,830
 

2567
00:58:25,270 --> 00:58:29,020
 incumbent configurations so that we are

2568
00:58:26,820 --> 00:58:29,020
 

2569
00:58:26,830 --> 00:58:31,600
 comparable so we're comparing apples to

2570
00:58:29,010 --> 00:58:31,600
 

2571
00:58:29,020 --> 00:58:32,920
 apples and don't compare one run on this

2572
00:58:31,590 --> 00:58:32,920
 

2573
00:58:31,600 --> 00:58:35,740
 instance and another run on this

2574
00:58:32,910 --> 00:58:35,740
 

2575
00:58:32,920 --> 00:58:39,180
 instance where the instances have vastly

2576
00:58:35,730 --> 00:58:39,180
 

2577
00:58:35,740 --> 00:58:41,830
 different hardnesses and we aggressively

2578
00:58:39,170 --> 00:58:41,830
 

2579
00:58:39,180 --> 00:58:44,380
 discard new configurations if they

2580
00:58:41,820 --> 00:58:44,380
 

2581
00:58:41,830 --> 00:58:46,960
 perform worse than the incumbent based

2582
00:58:44,370 --> 00:58:46,960
 

2583
00:58:44,380 --> 00:58:49,120
 on their shared runs in particular we do

2584
00:58:46,950 --> 00:58:49,120
 

2585
00:58:46,960 --> 00:58:52,210
 one run if that one run is slower than

2586
00:58:49,110 --> 00:58:52,210
 

2587
00:58:49,120 --> 00:58:54,820
 the incumbent on that instance with that

2588
00:58:52,200 --> 00:58:54,820
 

2589
00:58:52,210 --> 00:58:56,350
 seed we're going to drop it and we might

2590
00:58:54,810 --> 00:58:56,350
 

2591
00:58:54,820 --> 00:58:59,350
 come back to it later on if the model

2592
00:58:56,340 --> 00:58:59,350
 

2593
00:58:56,350 --> 00:59:00,850
 tells us we should come back but there

2594
00:58:59,340 --> 00:59:00,850
 

2595
00:58:59,350 --> 00:59:03,370
 is no requirement for a statistical

2596
00:59:00,840 --> 00:59:03,370
 

2597
00:59:00,850 --> 00:59:04,960
 domination for example because this

2598
00:59:03,360 --> 00:59:04,960
 

2599
00:59:03,370 --> 00:59:06,750
 would be really just far too inefficient

2600
00:59:04,950 --> 00:59:06,750
 

2601
00:59:04,960 --> 00:59:08,350
 there is an exponentially large

2602
00:59:06,740 --> 00:59:08,350
 

2603
00:59:06,750 --> 00:59:10,240
 exponentially large number of

2604
00:59:08,340 --> 00:59:10,240
 

2605
00:59:08,350 --> 00:59:12,400
 configurations that we really don't want

2606
00:59:10,230 --> 00:59:12,400
 

2607
00:59:10,240 --> 00:59:14,020
 to waste time with bad configurations we

2608
00:59:12,390 --> 00:59:14,020
 

2609
00:59:12,400 --> 00:59:17,260
 want to get to the good configurations

2610
00:59:14,010 --> 00:59:17,260
 

2611
00:59:14,020 --> 00:59:19,510
 as quickly as possible and we allowed to

2612
00:59:17,250 --> 00:59:19,510
 

2613
00:59:17,260 --> 00:59:21,160
 do that because the search component can

2614
00:59:19,500 --> 00:59:21,160
 

2615
00:59:19,510 --> 00:59:22,930
 tell us to go back to previously

2616
00:59:21,150 --> 00:59:22,930
 

2617
00:59:21,160 --> 00:59:25,870
 evaluated configurations that were

2618
00:59:22,920 --> 00:59:25,870
 

2619
00:59:22,930 --> 00:59:27,460
 discarded based on some unlucky run even

2620
00:59:25,860 --> 00:59:27,460
 

2621
00:59:25,870 --> 00:59:30,550
 the best configuration is not going to

2622
00:59:27,450 --> 00:59:30,550
 

2623
00:59:27,460 --> 00:59:34,180
 be the best at every instance but we can

2624
00:59:30,540 --> 00:59:34,180
 

2625
00:59:30,550 --> 00:59:36,040
 still recover from that and also for the

2626
00:59:34,170 --> 00:59:36,040
 

2627
00:59:34,180 --> 00:59:38,020
 incumbent well how many runs do we have

2628
00:59:36,030 --> 00:59:38,020
 

2629
00:59:36,040 --> 00:59:39,670
 there we start with one run but over

2630
00:59:38,010 --> 00:59:39,670
 

2631
00:59:38,020 --> 00:59:41,470
 time we actually add more runs to that

2632
00:59:39,660 --> 00:59:41,470
 

2633
00:59:39,670 --> 00:59:42,880
 in order to build up confidence in the

2634
00:59:41,460 --> 00:59:42,880
 

2635
00:59:41,470 --> 00:59:45,280
 thing that we're going to return in the

2636
00:59:42,870 --> 00:59:45,280
 

2637
00:59:42,880 --> 00:59:47,010
 end so we keep this incumbent that's

2638
00:59:45,270 --> 00:59:47,010
 

2639
00:59:45,280 --> 00:59:49,750
 getting better and better over time and

2640
00:59:47,000 --> 00:59:49,750
 

2641
00:59:47,010 --> 00:59:51,550
 based on that we can make this

2642
00:59:49,740 --> 00:59:51,550
 

2643
00:59:49,750 --> 00:59:54,790
 observation that if our configuration

2644
00:59:51,540 --> 00:59:54,790
 

2645
00:59:51,550 --> 00:59:58,180
 space is finite then actually smack with

2646
00:59:54,780 --> 00:59:58,180
 

2647
00:59:54,790 --> 00:59:59,770
 probability well that the probability

2648
00:59:58,170 --> 00:59:59,770
 

2649
00:59:58,180 --> 01:00:02,020
 that smack finds the true optimal

2650
00:59:59,760 --> 01:00:02,020
 

2651
00:59:59,770 --> 01:00:02,770
 parameter configuration approaches one

2652
01:00:02,010 --> 01:00:02,770
 

2653
01:00:02,020 --> 01:00:06,220
 as

2654
01:00:02,760 --> 01:00:06,220
 

2655
01:00:02,770 --> 01:00:08,590
 goes to infinity and that is actually

2656
01:00:06,210 --> 01:00:08,590
 

2657
01:00:06,220 --> 01:00:11,560
 relatively trivial observation but I'm

2658
01:00:08,580 --> 01:00:11,560
 

2659
01:00:08,590 --> 01:00:13,120
 mentioning this because well pretty much

2660
01:00:11,550 --> 01:00:13,120
 

2661
01:00:11,560 --> 01:00:15,400
 all the other configuration methods out

2662
01:00:13,110 --> 01:00:15,400
 

2663
01:00:13,120 --> 01:00:18,040
 there in the literature that don't have

2664
01:00:15,390 --> 01:00:18,040
 

2665
01:00:15,400 --> 01:00:20,260
 theoretical guarantees don't don't have

2666
01:00:18,030 --> 01:00:20,260
 

2667
01:00:18,040 --> 01:00:21,820
 this property they're there they can

2668
01:00:20,250 --> 01:00:21,820
 

2669
01:00:20,260 --> 01:00:24,460
 stagnate and even give an infinite time

2670
01:00:21,810 --> 01:00:24,460
 

2671
01:00:21,820 --> 01:00:28,390
 they don't they're not guaranteed to

2672
01:00:24,450 --> 01:00:28,390
 

2673
01:00:24,460 --> 01:00:31,950
 find the optimal so you can save more

2674
01:00:28,380 --> 01:00:31,950
 

2675
01:00:28,390 --> 01:00:34,990
 time than this aggressive capping

2676
01:00:31,940 --> 01:00:34,990
 

2677
01:00:31,950 --> 01:00:37,810
 aggressive racing by also using an

2678
01:00:34,980 --> 01:00:37,810
 

2679
01:00:34,990 --> 01:00:40,060
 adaptive capping mechanism so if we know

2680
01:00:37,800 --> 01:00:40,060
 

2681
01:00:37,810 --> 01:00:44,650
 our configuration our best known

2682
01:00:40,050 --> 01:00:44,650
 

2683
01:00:40,060 --> 01:00:48,070
 configuration takes 20 seconds in this

2684
01:00:44,640 --> 01:00:48,070
 

2685
01:00:44,650 --> 01:00:49,660
 case here and our new configuration

2686
01:00:48,060 --> 01:00:49,660
 

2687
01:00:48,070 --> 01:00:52,450
 that's going to be evaluated takes

2688
01:00:49,650 --> 01:00:52,450
 

2689
01:00:49,660 --> 01:00:55,900
 something longer than 20 seconds maybe a

2690
01:00:52,440 --> 01:00:55,900
 

2691
01:00:52,450 --> 01:00:57,670
 year maybe 21 seconds we can just cut it

2692
01:00:55,890 --> 01:00:57,670
 

2693
01:00:55,900 --> 01:00:59,380
 off after 20 seconds and we know it's

2694
01:00:57,660 --> 01:00:59,380
 

2695
01:00:57,670 --> 01:01:01,000
 not going to be better and it's going to

2696
01:00:59,370 --> 01:01:01,000
 

2697
01:00:59,380 --> 01:01:02,740
 be dominated and we're going to cut it

2698
01:01:00,990 --> 01:01:02,740
 

2699
01:01:01,000 --> 01:01:04,630
 off and maybe later on come back and

2700
01:01:02,730 --> 01:01:04,630
 

2701
01:01:02,740 --> 01:01:08,530
 evaluate it with with longer run times

2702
01:01:04,620 --> 01:01:08,530
 

2703
01:01:04,630 --> 01:01:11,080
 and yeah so we can terminate that about

2704
01:01:08,520 --> 01:01:11,080
 

2705
01:01:08,530 --> 01:01:12,760
 well the evaluation early and this

2706
01:01:11,070 --> 01:01:12,760
 

2707
01:01:11,080 --> 01:01:15,370
 observation will still hold and smack

2708
01:01:12,750 --> 01:01:15,370
 

2709
01:01:12,760 --> 01:01:17,290
 will still find the optimum and this is

2710
01:01:15,360 --> 01:01:17,290
 

2711
01:01:15,370 --> 01:01:19,210
 actually completely independent off the

2712
01:01:17,280 --> 01:01:19,210
 

2713
01:01:17,290 --> 01:01:21,460
 model inside of smack this this is also

2714
01:01:19,200 --> 01:01:21,460
 

2715
01:01:19,210 --> 01:01:25,150
 true if smack uses random search in

2716
01:01:21,450 --> 01:01:25,150
 

2717
01:01:21,460 --> 01:01:27,400
 order to pick the configurations all

2718
01:01:25,140 --> 01:01:27,400
 

2719
01:01:25,150 --> 01:01:30,040
 right so that was a part on how do we

2720
01:01:27,390 --> 01:01:30,040
 

2721
01:01:27,400 --> 01:01:31,120
 compare to this to the best

2722
01:01:30,030 --> 01:01:31,120
 

2723
01:01:30,040 --> 01:01:32,680
 configuration we're going to use this

2724
01:01:31,110 --> 01:01:32,680
 

2725
01:01:31,120 --> 01:01:34,740
 aggressive capping that's aggressively

2726
01:01:32,670 --> 01:01:34,740
 

2727
01:01:32,680 --> 01:01:37,960
 throwing away bad configurations and

2728
01:01:34,730 --> 01:01:37,960
 

2729
01:01:34,740 --> 01:01:39,970
 adaptively cap once we know that we

2730
01:01:37,950 --> 01:01:39,970
 

2731
01:01:37,960 --> 01:01:42,850
 reverse and the incumbent on this

2732
01:01:39,960 --> 01:01:42,850
 

2733
01:01:39,970 --> 01:01:45,010
 particular instance so that that's a

2734
01:01:42,840 --> 01:01:45,010
 

2735
01:01:42,850 --> 01:01:46,360
 high-level summary of smack and just

2736
01:01:45,000 --> 01:01:46,360
 

2737
01:01:45,010 --> 01:01:48,340
 want to mention that all of the

2738
01:01:46,350 --> 01:01:48,340
 

2739
01:01:46,360 --> 01:01:50,650
 components here actually really matter

2740
01:01:48,330 --> 01:01:50,650
 

2741
01:01:48,340 --> 01:01:54,250
 for performance so here I'm plotting

2742
01:01:50,640 --> 01:01:54,250
 

2743
01:01:50,650 --> 01:01:59,290
 random search on optimizing SEAPLEX were

2744
01:01:54,240 --> 01:01:59,290
 

2745
01:01:54,250 --> 01:02:02,350
 76 parameters on a communitarian actions

2746
01:01:59,280 --> 01:02:02,350
 

2747
01:01:59,290 --> 01:02:05,200
 and random search in this case actually

2748
01:02:02,340 --> 01:02:05,200
 

2749
01:02:02,350 --> 01:02:06,940
 didn't do anything there were a thousand

2750
01:02:05,190 --> 01:02:06,940
 

2751
01:02:05,200 --> 01:02:08,650
 instances so this would use a thousand

2752
01:02:06,930 --> 01:02:08,650
 

2753
01:02:06,940 --> 01:02:10,030
 instances to evaluate every

2754
01:02:08,640 --> 01:02:10,030
 

2755
01:02:08,650 --> 01:02:12,130
 configuration and it would just be so

2756
01:02:10,020 --> 01:02:12,130
 

2757
01:02:10,030 --> 01:02:14,770
 slow that it wouldn't do anything if you

2758
01:02:12,120 --> 01:02:14,770
 

2759
01:02:12,130 --> 01:02:16,510
 don't use these thousand instances but

2760
01:02:14,760 --> 01:02:16,510
 

2761
01:02:14,770 --> 01:02:19,900
 use a erasing or top of that

2762
01:02:16,500 --> 01:02:19,900
 

2763
01:02:16,510 --> 01:02:21,790
 it actually starts making progress and

2764
01:02:19,890 --> 01:02:21,790
 

2765
01:02:19,900 --> 01:02:24,760
 then if you also do adaptive capping on

2766
01:02:21,780 --> 01:02:24,760
 

2767
01:02:21,790 --> 01:02:26,740
 top of that it gets yet better but still

2768
01:02:24,750 --> 01:02:26,740
 

2769
01:02:24,760 --> 01:02:28,240
 if you do base an optimization compared

2770
01:02:26,730 --> 01:02:28,240
 

2771
01:02:26,740 --> 01:02:31,810
 to random searches still have a speed-up

2772
01:02:28,230 --> 01:02:31,810
 

2773
01:02:28,240 --> 01:02:34,000
 of two hundred fold so having said that

2774
01:02:31,800 --> 01:02:34,000
 

2775
01:02:31,810 --> 01:02:39,030
 let's dig in a little bit deeper into

2776
01:02:33,990 --> 01:02:39,030
 

2777
01:02:34,000 --> 01:02:41,920
 the space and optimization component so

2778
01:02:39,020 --> 01:02:41,920
 

2779
01:02:39,030 --> 01:02:43,540
 just to remind you there there's a lot

2780
01:02:41,910 --> 01:02:43,540
 

2781
01:02:41,920 --> 01:02:45,880
 of challenges that algorithm

2782
01:02:43,530 --> 01:02:45,880
 

2783
01:02:43,540 --> 01:02:48,010
 configuration poses to basing

2784
01:02:45,870 --> 01:02:48,010
 

2785
01:02:45,880 --> 01:02:49,480
 optimization Kevin already mentioned

2786
01:02:48,000 --> 01:02:49,480
 

2787
01:02:48,010 --> 01:02:52,000
 most of these so there's high

2788
01:02:49,470 --> 01:02:52,000
 

2789
01:02:49,480 --> 01:02:54,460
 dimensionality with low effective

2790
01:02:51,990 --> 01:02:54,460
 

2791
01:02:52,000 --> 01:02:56,320
 dimensionality usually there's only a

2792
01:02:54,450 --> 01:02:56,320
 

2793
01:02:54,460 --> 01:02:58,030
 couple of key parameters that are really

2794
01:02:56,310 --> 01:02:58,030
 

2795
01:02:56,320 --> 01:02:59,770
 important and a lot of other parameters

2796
01:02:58,020 --> 01:02:59,770
 

2797
01:02:58,030 --> 01:03:02,140
 it yeah you can set this to some

2798
01:02:59,760 --> 01:03:02,140
 

2799
01:02:59,770 --> 01:03:03,730
 something and it will still work and the

2800
01:03:02,130 --> 01:03:03,730
 

2801
01:03:02,140 --> 01:03:06,130
 key parameters if you set those right

2802
01:03:03,720 --> 01:03:06,130
 

2803
01:03:03,730 --> 01:03:07,390
 you're going to do well there's

2804
01:03:06,120 --> 01:03:07,390
 

2805
01:03:06,130 --> 01:03:09,160
 parameters that are discrete those

2806
01:03:07,380 --> 01:03:09,160
 

2807
01:03:07,390 --> 01:03:10,810
 parameters that are continuous there's

2808
01:03:09,150 --> 01:03:10,810
 

2809
01:03:09,160 --> 01:03:14,530
 lots of conditionality in these

2810
01:03:10,800 --> 01:03:14,530
 

2811
01:03:10,810 --> 01:03:16,990
 algorithm design spaces and for each of

2812
01:03:14,520 --> 01:03:16,990
 

2813
01:03:14,530 --> 01:03:18,490
 these complications there are actually

2814
01:03:16,980 --> 01:03:18,490
 

2815
01:03:16,990 --> 01:03:20,950
 algorithms in the based optimization

2816
01:03:18,480 --> 01:03:20,950
 

2817
01:03:18,490 --> 01:03:23,560
 literature with Gaussian processes that

2818
01:03:20,940 --> 01:03:23,560
 

2819
01:03:20,950 --> 01:03:25,450
 tackle these so it's not like there is

2820
01:03:23,550 --> 01:03:25,450
 

2821
01:03:23,560 --> 01:03:27,160
 no based optimization approach with

2822
01:03:25,440 --> 01:03:27,160
 

2823
01:03:25,450 --> 01:03:29,859
 Gaussian processes that could do this

2824
01:03:27,150 --> 01:03:29,859
 

2825
01:03:27,160 --> 01:03:31,530
 but that there is no single approach

2826
01:03:29,849 --> 01:03:31,530
 

2827
01:03:29,859 --> 01:03:33,850
 that does it all

2828
01:03:31,520 --> 01:03:33,850
 

2829
01:03:31,530 --> 01:03:35,410
 there's also non-standard noise in

2830
01:03:33,840 --> 01:03:35,410
 

2831
01:03:33,850 --> 01:03:38,410
 particular non Gaussian noise which is

2832
01:03:35,400 --> 01:03:38,410
 

2833
01:03:35,410 --> 01:03:40,119
 not very nice for Gaussian processes the

2834
01:03:38,400 --> 01:03:40,119
 

2835
01:03:38,410 --> 01:03:42,280
 noise is heteroskedastic different

2836
01:03:40,109 --> 01:03:42,280
 

2837
01:03:40,119 --> 01:03:45,850
 parameters actually yield different

2838
01:03:42,270 --> 01:03:45,850
 

2839
01:03:42,280 --> 01:03:48,070
 noise distributions and you want to be

2840
01:03:45,840 --> 01:03:48,070
 

2841
01:03:45,850 --> 01:03:50,859
 efficient so it doesn't help you if your

2842
01:03:48,060 --> 01:03:50,859
 

2843
01:03:48,070 --> 01:03:53,650
 based optimization model needs an hour

2844
01:03:50,849 --> 01:03:53,650
 

2845
01:03:50,859 --> 01:03:56,080
 to fit the gaussian process to your data

2846
01:03:53,640 --> 01:03:56,080
 

2847
01:03:53,650 --> 01:03:57,670
 and then you do a function evaluation

2848
01:03:56,070 --> 01:03:57,670
 

2849
01:03:56,080 --> 01:03:58,960
 and your algorithm runs for five seconds

2850
01:03:57,660 --> 01:03:58,960
 

2851
01:03:57,670 --> 01:04:01,320
 and then you think for an hour and then

2852
01:03:58,950 --> 01:04:01,320
 

2853
01:03:58,960 --> 01:04:03,730
 you run for five seconds but you need to

2854
01:04:01,310 --> 01:04:03,730
 

2855
01:04:01,320 --> 01:04:06,700
 fit your models really quickly in

2856
01:04:03,720 --> 01:04:06,700
 

2857
01:04:03,730 --> 01:04:11,170
 particular faster than the actual

2858
01:04:06,690 --> 01:04:11,170
 

2859
01:04:06,700 --> 01:04:13,480
 algorithm algorithms take to run and so

2860
01:04:11,160 --> 01:04:13,480
 

2861
01:04:11,170 --> 01:04:15,850
 there's all these challenges and what we

2862
01:04:13,470 --> 01:04:15,850
 

2863
01:04:13,480 --> 01:04:17,880
 want to use is random forests and they

2864
01:04:15,840 --> 01:04:17,880
 

2865
01:04:15,850 --> 01:04:20,740
 actually address all of these different

2866
01:04:17,870 --> 01:04:20,740
 

2867
01:04:17,880 --> 01:04:23,590
 issues and censoring is actually not

2868
01:04:20,730 --> 01:04:23,590
 

2869
01:04:20,740 --> 01:04:26,260
 even on here but one thing that that is

2870
01:04:23,580 --> 01:04:26,260
 

2871
01:04:23,590 --> 01:04:28,720
 not typically done in random forests is

2872
01:04:26,250 --> 01:04:28,720
 

2873
01:04:26,260 --> 01:04:29,799
 to have uncertainty estimates so that we

2874
01:04:28,710 --> 01:04:29,799
 

2875
01:04:28,720 --> 01:04:31,420
 do need to introduce an

2876
01:04:29,789 --> 01:04:31,420
 

2877
01:04:29,799 --> 01:04:33,489
 certainty estimates into random forests

2878
01:04:31,410 --> 01:04:33,489
 

2879
01:04:31,420 --> 01:04:36,549
 and I'm going to tell you how we did

2880
01:04:33,479 --> 01:04:36,549
 

2881
01:04:33,489 --> 01:04:40,150
 that so we adapted regression trees to

2882
01:04:36,539 --> 01:04:40,150
 

2883
01:04:36,549 --> 01:04:42,400
 store in each leaf not only the mean

2884
01:04:40,140 --> 01:04:42,400
 

2885
01:04:40,150 --> 01:04:44,739
 predictions so you have some data and we

2886
01:04:42,390 --> 01:04:44,739
 

2887
01:04:42,400 --> 01:04:47,469
 split it recursively in each leaf you

2888
01:04:44,729 --> 01:04:47,469
 

2889
01:04:44,739 --> 01:04:49,209
 end up for some data and we we save the

2890
01:04:47,459 --> 01:04:49,209
 

2891
01:04:47,469 --> 01:04:54,939
 mean but also the variance of the leaf

2892
01:04:49,199 --> 01:04:54,939
 

2893
01:04:49,209 --> 01:04:56,529
 and then we view the random forest as a

2894
01:04:54,929 --> 01:04:56,529
 

2895
01:04:54,939 --> 01:04:59,829
 mixture model of these different trees

2896
01:04:56,519 --> 01:04:59,829
 

2897
01:04:56,529 --> 01:05:02,109
 and get a predictive distribution by the

2898
01:04:59,819 --> 01:05:02,109
 

2899
01:04:59,829 --> 01:05:04,449
 law of total variance that basically

2900
01:05:02,099 --> 01:05:04,449
 

2901
01:05:02,109 --> 01:05:07,679
 combines the the mean of the variances

2902
01:05:04,439 --> 01:05:07,679
 

2903
01:05:04,449 --> 01:05:09,999
 plus the variance of the means and

2904
01:05:07,669 --> 01:05:09,999
 

2905
01:05:07,679 --> 01:05:12,039
 that's going to give us a mean and a

2906
01:05:09,989 --> 01:05:12,039
 

2907
01:05:09,999 --> 01:05:14,229
 variance and we can plug those into the

2908
01:05:12,029 --> 01:05:14,229
 

2909
01:05:12,039 --> 01:05:16,269
 standard acquisition functions that we

2910
01:05:14,219 --> 01:05:16,269
 

2911
01:05:14,229 --> 01:05:18,699
 use typically in Gaussian and cause the

2912
01:05:16,259 --> 01:05:18,699
 

2913
01:05:16,269 --> 01:05:20,529
 process based based on optimization in

2914
01:05:18,689 --> 01:05:20,529
 

2915
01:05:18,699 --> 01:05:21,160
 order to trade off exploration and

2916
01:05:20,519 --> 01:05:21,160
 

2917
01:05:20,529 --> 01:05:23,529
 exploitation

2918
01:05:21,150 --> 01:05:23,529
 

2919
01:05:21,160 --> 01:05:24,999
 I should mention there's another recent

2920
01:05:23,519 --> 01:05:24,999
 

2921
01:05:23,529 --> 01:05:26,439
 variant that that's quite nice for

2922
01:05:24,989 --> 01:05:26,439
 

2923
01:05:24,999 --> 01:05:29,709
 uncertainty and random forests

2924
01:05:26,429 --> 01:05:29,709
 

2925
01:05:26,439 --> 01:05:31,479
 that's Mondrian forests and we've been

2926
01:05:29,699 --> 01:05:31,479
 

2927
01:05:29,709 --> 01:05:34,599
 looking into using these and based

2928
01:05:31,469 --> 01:05:34,599
 

2929
01:05:31,479 --> 01:05:36,789
 optimization they they have some they're

2930
01:05:34,589 --> 01:05:36,789
 

2931
01:05:34,599 --> 01:05:38,859
 very nice uncertainty estimates but

2932
01:05:36,779 --> 01:05:38,859
 

2933
01:05:36,789 --> 01:05:41,410
 sometimes a predictive performance is

2934
01:05:38,849 --> 01:05:41,410
 

2935
01:05:38,859 --> 01:05:44,410
 just not very good so we haven't really

2936
01:05:41,400 --> 01:05:44,410
 

2937
01:05:41,410 --> 01:05:45,759
 found that in algorithm configuration

2938
01:05:44,400 --> 01:05:45,759
 

2939
01:05:44,410 --> 01:05:49,269
 they work better there there are certain

2940
01:05:45,749 --> 01:05:49,269
 

2941
01:05:45,759 --> 01:05:51,400
 cases where they do work better all

2942
01:05:49,259 --> 01:05:51,400
 

2943
01:05:49,269 --> 01:05:55,059
 right another modification of random

2944
01:05:51,390 --> 01:05:55,059
 

2945
01:05:51,400 --> 01:05:57,459
 forests we need to make is how we decide

2946
01:05:55,049 --> 01:05:57,459
 

2947
01:05:55,059 --> 01:05:59,019
 about split points so here we have one

2948
01:05:57,449 --> 01:05:59,019
 

2949
01:05:57,459 --> 01:06:01,059
 single split of the data here we're just

2950
01:05:59,009 --> 01:06:01,059
 

2951
01:05:59,019 --> 01:06:04,029
 three data points and we have the split

2952
01:06:01,049 --> 01:06:04,029
 

2953
01:06:01,059 --> 01:06:05,650
 on parameter to so parameter to that

2954
01:06:04,019 --> 01:06:05,650
 

2955
01:06:04,029 --> 01:06:09,099
 this just says all the data points that

2956
01:06:05,640 --> 01:06:09,099
 

2957
01:06:05,650 --> 01:06:11,829
 have parameter to smaller equals 3.5 go

2958
01:06:09,089 --> 01:06:11,829
 

2959
01:06:09,099 --> 01:06:15,519
 here so that's this one point and the

2960
01:06:11,819 --> 01:06:15,519
 

2961
01:06:11,829 --> 01:06:19,569
 other two points go here the standard

2962
01:06:15,509 --> 01:06:19,569
 

2963
01:06:15,519 --> 01:06:21,999
 approach to use as this split point here

2964
01:06:19,559 --> 01:06:21,999
 

2965
01:06:19,569 --> 01:06:26,319
 is to set it in the middle between the

2966
01:06:21,989 --> 01:06:26,319
 

2967
01:06:21,999 --> 01:06:28,449
 two critical values two and five but if

2968
01:06:26,309 --> 01:06:28,449
 

2969
01:06:26,319 --> 01:06:33,759
 we do that deterministically then we end

2970
01:06:28,439 --> 01:06:33,759
 

2971
01:06:28,449 --> 01:06:35,319
 up with a fairly yeah degenerate model

2972
01:06:33,749 --> 01:06:35,319
 

2973
01:06:33,759 --> 01:06:38,019
 that that doesn't have a lot of

2974
01:06:35,309 --> 01:06:38,019
 

2975
01:06:35,319 --> 01:06:39,519
 uncertainty and what we rather advocate

2976
01:06:38,009 --> 01:06:39,519
 

2977
01:06:38,019 --> 01:06:41,800
 is actually through sample the split

2978
01:06:39,509 --> 01:06:41,800
 

2979
01:06:39,519 --> 01:06:45,730
 point between these critical values

2980
01:06:41,790 --> 01:06:45,730
 

2981
01:06:41,800 --> 01:06:47,710
 and you and this is very important to

2982
01:06:45,720 --> 01:06:47,710
 

2983
01:06:45,730 --> 01:06:49,330
 get smooth uncertainty estimates so if

2984
01:06:47,700 --> 01:06:49,330
 

2985
01:06:47,710 --> 01:06:51,730
 you don't sample the split points if you

2986
01:06:49,320 --> 01:06:51,730
 

2987
01:06:49,330 --> 01:06:53,280
 just split at the midpoint between the

2988
01:06:51,720 --> 01:06:53,280
 

2989
01:06:51,730 --> 01:06:56,260
 critical values you get these very

2990
01:06:53,270 --> 01:06:56,260
 

2991
01:06:53,280 --> 01:07:00,190
 choppy looking plots where your

2992
01:06:56,250 --> 01:07:00,190
 

2993
01:06:56,260 --> 01:07:02,410
 piecewise constant whereas if you sample

2994
01:07:00,180 --> 01:07:02,410
 

2995
01:07:00,190 --> 01:07:05,040
 then given enough trees and you actually

2996
01:07:02,400 --> 01:07:05,040
 

2997
01:07:02,410 --> 01:07:07,630
 end up with a piecewise linear

2998
01:07:05,030 --> 01:07:07,630
 

2999
01:07:05,040 --> 01:07:09,850
 approximation and importantly your

3000
01:07:07,620 --> 01:07:09,850
 

3001
01:07:07,630 --> 01:07:11,290
 uncertainty grows away from the date and

3002
01:07:09,840 --> 01:07:11,290
 

3003
01:07:09,850 --> 01:07:13,660
 the data points and that's what you need

3004
01:07:11,280 --> 01:07:13,660
 

3005
01:07:11,290 --> 01:07:16,650
 in order to really balance exploration

3006
01:07:13,650 --> 01:07:16,650
 

3007
01:07:13,660 --> 01:07:19,330
 and exploitation and this gets even more

3008
01:07:16,640 --> 01:07:19,330
 

3009
01:07:16,650 --> 01:07:22,180
 exposed if you don't do bootstrapping

3010
01:07:19,320 --> 01:07:22,180
 

3011
01:07:19,330 --> 01:07:23,710
 then you just get these really bad

3012
01:07:22,170 --> 01:07:23,710
 

3013
01:07:22,180 --> 01:07:26,140
 predictions that you could not do based

3014
01:07:23,700 --> 01:07:26,140
 

3015
01:07:23,710 --> 01:07:28,450
 optimization with if you split at mid

3016
01:07:26,130 --> 01:07:28,450
 

3017
01:07:26,140 --> 01:07:30,670
 points and if you sample then you get

3018
01:07:28,440 --> 01:07:30,670
 

3019
01:07:28,450 --> 01:07:31,990
 actually these quite nicer predictions

3020
01:07:30,660 --> 01:07:31,990
 

3021
01:07:30,670 --> 01:07:37,330
 that you can do based an optimization

3022
01:07:31,980 --> 01:07:37,330
 

3023
01:07:31,990 --> 01:07:38,860
 with all right one other issue that I

3024
01:07:37,320 --> 01:07:38,860
 

3025
01:07:37,330 --> 01:07:41,230
 haven't told you about yet that I've

3026
01:07:38,850 --> 01:07:41,230
 

3027
01:07:38,860 --> 01:07:42,730
 swept under the rug is that well the

3028
01:07:41,220 --> 01:07:42,730
 

3029
01:07:41,230 --> 01:07:46,360
 runtime prediction models that Kevin

3030
01:07:42,720 --> 01:07:46,360
 

3031
01:07:42,730 --> 01:07:49,570
 talked about model give us a model that

3032
01:07:46,350 --> 01:07:49,570
 

3033
01:07:46,360 --> 01:07:53,410
 take as input parameters and the

3034
01:07:49,560 --> 01:07:53,410
 

3035
01:07:49,570 --> 01:07:56,020
 instance features and then predict the

3036
01:07:53,400 --> 01:07:56,020
 

3037
01:07:53,410 --> 01:07:57,520
 runtime but in order to do base an

3038
01:07:56,010 --> 01:07:57,520
 

3039
01:07:56,020 --> 01:07:59,320
 optimization we actually only want a

3040
01:07:57,510 --> 01:07:59,320
 

3041
01:07:57,520 --> 01:08:00,940
 model that takes parameter settings and

3042
01:07:59,310 --> 01:08:00,940
 

3043
01:07:59,320 --> 01:08:03,400
 gives us a marginal model across the

3044
01:08:00,930 --> 01:08:03,400
 

3045
01:08:00,940 --> 01:08:06,280
 instances so how do we do that how do we

3046
01:08:03,390 --> 01:08:06,280
 

3047
01:08:03,400 --> 01:08:08,080
 marginalize over the instances well the

3048
01:08:06,270 --> 01:08:08,080
 

3049
01:08:06,280 --> 01:08:10,060
 intuition is we just predict for each of

3050
01:08:08,070 --> 01:08:10,060
 

3051
01:08:08,080 --> 01:08:14,430
 the instances we sample a lot of

3052
01:08:10,050 --> 01:08:14,430
 

3053
01:08:10,060 --> 01:08:17,440
 instances and then compute the mean but

3054
01:08:14,420 --> 01:08:17,440
 

3055
01:08:14,430 --> 01:08:19,150
 in random forests actually you can do

3056
01:08:17,430 --> 01:08:19,150
 

3057
01:08:17,440 --> 01:08:20,799
 this a lot more efficiently and you can

3058
01:08:19,140 --> 01:08:20,799
 

3059
01:08:19,150 --> 01:08:22,630
 do this if you have a distribution of

3060
01:08:20,789 --> 01:08:22,630
 

3061
01:08:20,799 --> 01:08:24,339
 instances that's infinite you can still

3062
01:08:22,620 --> 01:08:24,339
 

3063
01:08:22,630 --> 01:08:28,540
 do this because all the computation and

3064
01:08:24,329 --> 01:08:28,540
 

3065
01:08:24,339 --> 01:08:30,790
 regression trees is just a computation

3066
01:08:28,530 --> 01:08:30,790
 

3067
01:08:28,540 --> 01:08:32,950
 of which leaves you you fall into so you

3068
01:08:30,780 --> 01:08:32,950
 

3069
01:08:30,790 --> 01:08:35,380
 always have this finite partition of

3070
01:08:32,940 --> 01:08:35,380
 

3071
01:08:32,950 --> 01:08:37,690
 your data even if your of your space of

3072
01:08:35,370 --> 01:08:37,690
 

3073
01:08:35,380 --> 01:08:41,020
 instances is infinite you can still

3074
01:08:37,680 --> 01:08:41,020
 

3075
01:08:37,690 --> 01:08:44,400
 compute these expectations and do so

3076
01:08:41,010 --> 01:08:44,400
 

3077
01:08:41,020 --> 01:08:47,950
 quite efficiently by just doing a linear

3078
01:08:44,390 --> 01:08:47,950
 

3079
01:08:44,400 --> 01:08:49,810
 predict linear algorithm over the the

3080
01:08:47,940 --> 01:08:49,810
 

3081
01:08:47,950 --> 01:08:51,460
 leaves of your model and sometimes it's

3082
01:08:49,800 --> 01:08:51,460
 

3083
01:08:49,810 --> 01:08:52,810
 actually also a lot faster sometimes

3084
01:08:51,450 --> 01:08:52,810
 

3085
01:08:51,460 --> 01:08:57,250
 it's logarithmic in the number of

3086
01:08:52,800 --> 01:08:57,250
 

3087
01:08:52,810 --> 01:08:59,350
 at point yeah so putting that all

3088
01:08:57,240 --> 01:08:59,350
 

3089
01:08:57,250 --> 01:09:02,190
 together we have based optimization with

3090
01:08:59,340 --> 01:09:02,190
 

3091
01:08:59,350 --> 01:09:04,810
 random forests your plots look like this

3092
01:09:02,180 --> 01:09:04,810
 

3093
01:09:02,190 --> 01:09:08,680
 of the uncertainty estimates and if you

3094
01:09:04,800 --> 01:09:08,680
 

3095
01:09:04,810 --> 01:09:11,230
 have sensor data then well we have we

3096
01:09:08,670 --> 01:09:11,230
 

3097
01:09:08,680 --> 01:09:13,690
 have data points that are an observation

3098
01:09:11,220 --> 01:09:13,690
 

3099
01:09:11,230 --> 01:09:16,000
 that is capped but it's kept below the

3100
01:09:13,680 --> 01:09:16,000
 

3101
01:09:13,690 --> 01:09:17,319
 true function value so here in red

3102
01:09:15,990 --> 01:09:17,319
 

3103
01:09:16,000 --> 01:09:19,600
 there's a true function value and then

3104
01:09:17,309 --> 01:09:19,600
 

3105
01:09:17,319 --> 01:09:23,140
 blue there's our observation and we can

3106
01:09:19,590 --> 01:09:23,140
 

3107
01:09:19,600 --> 01:09:26,620
 fit a model that well estimates higher

3108
01:09:23,130 --> 01:09:26,620
 

3109
01:09:23,140 --> 01:09:29,020
 than than this capping value by by using

3110
01:09:26,610 --> 01:09:29,020
 

3111
01:09:26,620 --> 01:09:31,420
 an approach that's kind of an

3112
01:09:29,010 --> 01:09:31,420
 

3113
01:09:29,020 --> 01:09:33,880
 expectation maximization approach to

3114
01:09:31,410 --> 01:09:33,880
 

3115
01:09:31,420 --> 01:09:36,339
 fill in these censored values and we

3116
01:09:33,870 --> 01:09:36,339
 

3117
01:09:33,880 --> 01:09:37,930
 make predictions that are above the

3118
01:09:36,329 --> 01:09:37,930
 

3119
01:09:36,339 --> 01:09:40,690
 censoring thresholds and we can then

3120
01:09:37,920 --> 01:09:40,690
 

3121
01:09:37,930 --> 01:09:43,600
 still do based optimization under

3122
01:09:40,680 --> 01:09:43,600
 

3123
01:09:40,690 --> 01:09:47,050
 censoring these predictions are not

3124
01:09:43,590 --> 01:09:47,050
 

3125
01:09:43,600 --> 01:09:49,540
 great for for the sensor data points but

3126
01:09:47,040 --> 01:09:49,540
 

3127
01:09:47,050 --> 01:09:52,210
 actually it's important to realize that

3128
01:09:49,530 --> 01:09:52,210
 

3129
01:09:49,540 --> 01:09:54,460
 we don't need to make really great

3130
01:09:52,200 --> 01:09:54,460
 

3131
01:09:52,210 --> 01:09:57,010
 predictions for the bad configurations

3132
01:09:54,450 --> 01:09:57,010
 

3133
01:09:54,460 --> 01:09:58,750
 all we care about is which are the best

3134
01:09:57,000 --> 01:09:58,750
 

3135
01:09:57,010 --> 01:10:01,810
 configurations and those we need to

3136
01:09:58,740 --> 01:10:01,810
 

3137
01:09:58,750 --> 01:10:03,040
 really get make good predictions for for

3138
01:10:01,800 --> 01:10:03,040
 

3139
01:10:01,810 --> 01:10:05,320
 the censored ones we just want to

3140
01:10:03,030 --> 01:10:05,320
 

3141
01:10:03,040 --> 01:10:07,990
 predict well this is bad I don't really

3142
01:10:05,310 --> 01:10:07,990
 

3143
01:10:05,320 --> 01:10:09,670
 hear exactly how bad it is and our

3144
01:10:07,980 --> 01:10:09,670
 

3145
01:10:07,990 --> 01:10:14,160
 position function should not try to

3146
01:10:09,660 --> 01:10:14,160
 

3147
01:10:09,670 --> 01:10:16,480
 really find out how bad it is all right

3148
01:10:14,150 --> 01:10:16,480
 

3149
01:10:14,160 --> 01:10:19,410
 finally we also want to handle a

3150
01:10:16,470 --> 01:10:19,410
 

3151
01:10:16,480 --> 01:10:22,180
 conditionality and in random forests

3152
01:10:19,400 --> 01:10:22,180
 

3153
01:10:19,410 --> 01:10:26,350
 it's actually quite natural how you do

3154
01:10:22,170 --> 01:10:26,350
 

3155
01:10:22,180 --> 01:10:28,990
 that so in in a in one point of the

3156
01:10:26,340 --> 01:10:28,990
 

3157
01:10:26,350 --> 01:10:32,110
 regression tree at one node you just

3158
01:10:28,980 --> 01:10:32,110
 

3159
01:10:28,990 --> 01:10:34,750
 look at well which parameters are

3160
01:10:32,100 --> 01:10:34,750
 

3161
01:10:32,110 --> 01:10:36,730
 guaranteed to be active at this point so

3162
01:10:34,740 --> 01:10:36,730
 

3163
01:10:34,750 --> 01:10:41,590
 looking at the past from the root to

3164
01:10:36,720 --> 01:10:41,590
 

3165
01:10:36,730 --> 01:10:43,600
 this node is it guaranteed that my that

3166
01:10:41,580 --> 01:10:43,600
 

3167
01:10:41,590 --> 01:10:46,030
 all the parents of a conditional

3168
01:10:43,590 --> 01:10:46,030
 

3169
01:10:43,600 --> 01:10:48,130
 parameter are set such that this

3170
01:10:46,020 --> 01:10:48,130
 

3171
01:10:46,030 --> 01:10:53,860
 condition of parameter is active so for

3172
01:10:48,120 --> 01:10:53,860
 

3173
01:10:48,130 --> 01:10:55,570
 example if I have a I sat solver that

3174
01:10:53,850 --> 01:10:55,570
 

3175
01:10:53,860 --> 01:10:57,100
 has two different components and each of

3176
01:10:55,560 --> 01:10:57,100
 

3177
01:10:55,570 --> 01:11:02,800
 these components have it has a parameter

3178
01:10:57,090 --> 01:11:02,800
 

3179
01:10:57,100 --> 01:11:04,870
 then my first check would be well am I

3180
01:11:02,790 --> 01:11:04,870
 

3181
01:11:02,800 --> 01:11:06,820
 sure that I'm in component one if so

3182
01:11:04,860 --> 01:11:06,820
 

3183
01:11:04,870 --> 01:11:07,140
 then I then I'm fine to split on the

3184
01:11:06,810 --> 01:11:07,140
 

3185
01:11:06,820 --> 01:11:09,660
 parm

3186
01:11:07,130 --> 01:11:09,660
 

3187
01:11:07,140 --> 01:11:13,410
 of componentOne if there could also be

3188
01:11:09,650 --> 01:11:13,410
 

3189
01:11:09,660 --> 01:11:19,200
 parameter predictions that come here

3190
01:11:13,400 --> 01:11:19,200
 

3191
01:11:13,410 --> 01:11:23,550
 that I need to there's an echo I'm I

3192
01:11:19,190 --> 01:11:23,550
 

3193
01:11:19,200 --> 01:11:25,380
 really I'm thrown off by that but if

3194
01:11:23,540 --> 01:11:25,380
 

3195
01:11:23,550 --> 01:11:28,710
 there if there are data points that come

3196
01:11:25,370 --> 01:11:28,710
 

3197
01:11:25,380 --> 01:11:31,080
 to this this point that could belong to

3198
01:11:28,700 --> 01:11:31,080
 

3199
01:11:28,710 --> 01:11:32,640
 the other i'm component and not to this

3200
01:11:31,070 --> 01:11:32,640
 

3201
01:11:31,080 --> 01:11:34,200
 component then i'm not allowed to split

3202
01:11:32,630 --> 01:11:34,200
 

3203
01:11:32,640 --> 01:11:37,670
 this so that's how we deal with

3204
01:11:34,190 --> 01:11:37,670
 

3205
01:11:34,200 --> 01:11:40,230
 conditionality in random forests

3206
01:11:37,660 --> 01:11:40,230
 

3207
01:11:37,670 --> 01:11:41,490
 empirically then Gaussian processes and

3208
01:11:40,220 --> 01:11:41,490
 

3209
01:11:40,230 --> 01:11:43,980
 random forests both have their

3210
01:11:41,480 --> 01:11:43,980
 

3211
01:11:41,490 --> 01:11:46,710
 advantages so low dimensional continuous

3212
01:11:43,970 --> 01:11:46,710
 

3213
01:11:43,980 --> 01:11:50,040
 settings Gaussian processes are actually

3214
01:11:46,700 --> 01:11:50,040
 

3215
01:11:46,710 --> 01:11:51,840
 typically quite a bit better but in the

3216
01:11:50,030 --> 01:11:51,840
 

3217
01:11:50,040 --> 01:11:55,110
 high dimensional conditional case that's

3218
01:11:51,830 --> 01:11:55,110
 

3219
01:11:51,840 --> 01:12:02,040
 really where random forests work very

3220
01:11:55,100 --> 01:12:02,040
 

3221
01:11:55,110 --> 01:12:03,510
 well also as I mentioned before we need

3222
01:12:02,030 --> 01:12:03,510
 

3223
01:12:02,040 --> 01:12:05,610
 to be computationally efficient and

3224
01:12:03,500 --> 01:12:05,610
 

3225
01:12:03,510 --> 01:12:08,580
 random forests are quite a bit more

3226
01:12:05,600 --> 01:12:08,580
 

3227
01:12:05,610 --> 01:12:10,080
 efficient than standard GPS bowls and in

3228
01:12:08,570 --> 01:12:10,080
 

3229
01:12:08,580 --> 01:12:11,820
 terms of training and in terms of

3230
01:12:10,070 --> 01:12:11,820
 

3231
01:12:10,080 --> 01:12:13,980
 prediction time prediction is important

3232
01:12:11,810 --> 01:12:13,980
 

3233
01:12:11,820 --> 01:12:15,090
 because we do predictions all the time

3234
01:12:13,970 --> 01:12:15,090
 

3235
01:12:13,980 --> 01:12:19,470
 in order to optimize the acquisition

3236
01:12:15,080 --> 01:12:19,470
 

3237
01:12:15,090 --> 01:12:21,180
 function and empirically rescale a whole

3238
01:12:19,460 --> 01:12:21,180
 

3239
01:12:19,470 --> 01:12:23,030
 lot better than Gaussian processes and

3240
01:12:21,170 --> 01:12:23,030
 

3241
01:12:21,180 --> 01:12:25,110
 also actually quite a bit better than

3242
01:12:23,020 --> 01:12:25,110
 

3243
01:12:23,030 --> 01:12:29,100
 deep neural networks or global

3244
01:12:25,100 --> 01:12:29,100
 

3245
01:12:25,110 --> 01:12:32,960
 optimization finally scaling with high

3246
01:12:29,090 --> 01:12:32,960
 

3247
01:12:29,100 --> 01:12:36,300
 dimensions so we evaluated the setting

3248
01:12:32,950 --> 01:12:36,300
 

3249
01:12:32,960 --> 01:12:38,190
 from from one of the papers on scaling

3250
01:12:36,290 --> 01:12:38,190
 

3251
01:12:36,300 --> 01:12:41,610
 to to really high dimensionality Swiss

3252
01:12:38,180 --> 01:12:41,610
 

3253
01:12:38,190 --> 01:12:43,170
 trapeze where we use two important

3254
01:12:41,600 --> 01:12:43,170
 

3255
01:12:41,610 --> 01:12:44,940
 dimensions as brown and test function

3256
01:12:43,160 --> 01:12:44,940
 

3257
01:12:43,170 --> 01:12:49,170
 and then just added unimportant

3258
01:12:44,930 --> 01:12:49,170
 

3259
01:12:44,940 --> 01:12:51,810
 dimensions and Gaussian processes really

3260
01:12:49,160 --> 01:12:51,810
 

3261
01:12:49,170 --> 01:12:54,540
 break down with like 25 dimensions or so

3262
01:12:51,800 --> 01:12:54,540
 

3263
01:12:51,810 --> 01:12:56,040
 and it turns out that smack actually

3264
01:12:54,530 --> 01:12:56,040
 

3265
01:12:54,540 --> 01:12:57,870
 gets better if you add some more

3266
01:12:56,030 --> 01:12:57,870
 

3267
01:12:56,040 --> 01:12:59,640
 dimensions because it helps out the

3268
01:12:57,860 --> 01:12:59,640
 

3269
01:12:57,870 --> 01:13:01,950
 random forests do some more exploration

3270
01:12:59,630 --> 01:13:01,950
 

3271
01:12:59,640 --> 01:13:04,650
 up to a certain points or was 25

3272
01:13:01,940 --> 01:13:04,650
 

3273
01:13:01,950 --> 01:13:06,630
 dimensions that actually is better in

3274
01:13:04,640 --> 01:13:06,630
 

3275
01:13:04,650 --> 01:13:08,160
 doing the optimization than with two

3276
01:13:06,620 --> 01:13:08,160
 

3277
01:13:06,630 --> 01:13:10,020
 dimensions and then we're seven

3278
01:13:08,150 --> 01:13:10,020
 

3279
01:13:08,160 --> 01:13:11,340
 dimensions that it still works and still

3280
01:13:10,010 --> 01:13:11,340
 

3281
01:13:10,020 --> 01:13:13,620
 figures out these two important

3282
01:13:11,330 --> 01:13:13,620
 

3283
01:13:11,340 --> 01:13:15,660
 dimensions and those are the reasons

3284
01:13:13,610 --> 01:13:15,660
 

3285
01:13:13,620 --> 01:13:19,260
 that let me use random forests in the

3286
01:13:15,650 --> 01:13:19,260
 

3287
01:13:15,660 --> 01:13:20,489
 end okay so having talked about smack

3288
01:13:19,250 --> 01:13:20,489
 

3289
01:13:19,260 --> 01:13:25,560
 I'll now talk about some of

3290
01:13:20,479 --> 01:13:25,560
 

3291
01:13:20,489 --> 01:13:28,469
 algorithm configuration methods there's

3292
01:13:25,550 --> 01:13:28,469
 

3293
01:13:25,560 --> 01:13:30,210
 a lot of black box optimization methods

3294
01:13:28,459 --> 01:13:30,210
 

3295
01:13:28,469 --> 01:13:32,219
 under the Sun there's evolutionary

3296
01:13:30,200 --> 01:13:32,219
 

3297
01:13:30,210 --> 01:13:34,770
 strategies this morning Jeff clue and

3298
01:13:32,209 --> 01:13:34,770
 

3299
01:13:32,219 --> 01:13:37,500
 talked about some of these for example

3300
01:13:34,760 --> 01:13:37,500
 

3301
01:13:34,770 --> 01:13:39,690
 there they're CMAs which is a very

3302
01:13:37,490 --> 01:13:39,690
 

3303
01:13:37,500 --> 01:13:41,790
 popular approach for continuous black

3304
01:13:39,680 --> 01:13:41,790
 

3305
01:13:39,690 --> 01:13:43,350
 box optimization that has actually shown

3306
01:13:41,780 --> 01:13:43,350
 

3307
01:13:41,790 --> 01:13:45,510
 strong results for continuous hyper

3308
01:13:43,340 --> 01:13:45,510
 

3309
01:13:43,350 --> 01:13:48,270
 parameter optimization especially if you

3310
01:13:45,500 --> 01:13:48,270
 

3311
01:13:45,510 --> 01:13:50,130
 have parallel resources and that also

3312
01:13:48,260 --> 01:13:50,130
 

3313
01:13:48,270 --> 01:13:51,690
 has even shown strong results for

3314
01:13:50,120 --> 01:13:51,690
 

3315
01:13:50,130 --> 01:13:54,780
 optimizing neural network parameters so

3316
01:13:51,680 --> 01:13:54,780
 

3317
01:13:51,690 --> 01:13:58,080
 even in very high dimensions for example

3318
01:13:54,770 --> 01:13:58,080
 

3319
01:13:54,780 --> 01:13:59,700
 as an alternative to RL there's also

3320
01:13:58,070 --> 01:13:59,700
 

3321
01:13:58,080 --> 01:14:01,860
 differential evolution particle swarm

3322
01:13:59,690 --> 01:14:01,860
 

3323
01:13:59,700 --> 01:14:03,420
 optimization so all kinds of different

3324
01:14:01,850 --> 01:14:03,420
 

3325
01:14:01,860 --> 01:14:05,280
 algorithms and they could be used for

3326
01:14:03,410 --> 01:14:05,280
 

3327
01:14:03,420 --> 01:14:07,920
 algorithm configuration if you have

3328
01:14:05,270 --> 01:14:07,920
 

3329
01:14:05,280 --> 01:14:10,500
 purely continuous parameters which

3330
01:14:07,910 --> 01:14:10,500
 

3331
01:14:07,920 --> 01:14:12,180
 typically is not the case but maybe the

3332
01:14:10,490 --> 01:14:12,180
 

3333
01:14:10,500 --> 01:14:14,190
 problem could be reformulated to be

3334
01:14:12,170 --> 01:14:14,190
 

3335
01:14:12,180 --> 01:14:16,530
 purely continuous and then you could use

3336
01:14:14,180 --> 01:14:16,530
 

3337
01:14:14,190 --> 01:14:19,530
 these but people haven't really done

3338
01:14:16,520 --> 01:14:19,530
 

3339
01:14:16,530 --> 01:14:21,810
 that so far there's also lots of

3340
01:14:19,520 --> 01:14:21,810
 

3341
01:14:19,530 --> 01:14:23,280
 approaches for model selection so in

3342
01:14:21,800 --> 01:14:23,280
 

3343
01:14:21,810 --> 01:14:26,040
 particular there is for example this

3344
01:14:23,270 --> 01:14:26,040
 

3345
01:14:23,280 --> 01:14:30,920
 hefting races that was in Europe's paper

3346
01:14:26,030 --> 01:14:30,920
 

3347
01:14:26,040 --> 01:14:33,810
 a long time ago by now which simply just

3348
01:14:30,910 --> 01:14:33,810
 

3349
01:14:30,920 --> 01:14:36,420
 estimates a a mean and a variance for

3350
01:14:33,800 --> 01:14:36,420
 

3351
01:14:33,810 --> 01:14:38,400
 each of the models to race and if one of

3352
01:14:36,410 --> 01:14:38,400
 

3353
01:14:36,420 --> 01:14:42,960
 the bounds dominates the other bound

3354
01:14:38,390 --> 01:14:42,960
 

3355
01:14:38,400 --> 01:14:44,640
 then it stops the worst one and there's

3356
01:14:42,950 --> 01:14:44,640
 

3357
01:14:42,960 --> 01:14:46,590
 other approaches that follow up on that

3358
01:14:44,630 --> 01:14:46,590
 

3359
01:14:44,640 --> 01:14:48,480
 in particular a phrase that has a

3360
01:14:46,580 --> 01:14:48,480
 

3361
01:14:46,590 --> 01:14:51,060
 similar idea to have ting races but it

3362
01:14:48,470 --> 01:14:51,060
 

3363
01:14:48,480 --> 01:14:53,280
 uses a statistical test instead of

3364
01:14:51,050 --> 01:14:53,280
 

3365
01:14:51,060 --> 01:14:56,790
 hafting bounds namely the F test to

3366
01:14:53,270 --> 01:14:56,790
 

3367
01:14:53,280 --> 01:14:59,940
 check whether there is any statistical

3368
01:14:56,780 --> 01:14:59,940
 

3369
01:14:56,790 --> 01:15:02,550
 significance in in the the differences

3370
01:14:59,930 --> 01:15:02,550
 

3371
01:14:59,940 --> 01:15:04,530
 and if that F test succeeds then it

3372
01:15:02,540 --> 01:15:04,530
 

3373
01:15:02,550 --> 01:15:06,330
 follows where is pairwise t-test and

3374
01:15:04,520 --> 01:15:06,330
 

3375
01:15:04,530 --> 01:15:09,270
 throws out the the dominated

3376
01:15:06,320 --> 01:15:09,270
 

3377
01:15:06,330 --> 01:15:12,330
 configurations and then the iterated F

3378
01:15:09,260 --> 01:15:12,330
 

3379
01:15:09,270 --> 01:15:13,680
 raise continuous on that and builds on

3380
01:15:12,320 --> 01:15:13,680
 

3381
01:15:12,330 --> 01:15:15,360
 that and maintains a probability

3382
01:15:13,670 --> 01:15:15,360
 

3383
01:15:13,680 --> 01:15:18,930
 distribution over which configurations

3384
01:15:15,350 --> 01:15:18,930
 

3385
01:15:15,360 --> 01:15:20,430
 might be good samples K of them racism

3386
01:15:18,920 --> 01:15:20,430
 

3387
01:15:18,930 --> 01:15:21,930
 with F raised and then updates this

3388
01:15:20,420 --> 01:15:21,930
 

3389
01:15:20,430 --> 01:15:22,980
 distribution with the results of the

3390
01:15:21,920 --> 01:15:22,980
 

3391
01:15:21,930 --> 01:15:25,050
 race

3392
01:15:22,970 --> 01:15:25,050
 

3393
01:15:22,980 --> 01:15:27,030
 however these racing algorithms tend to

3394
01:15:25,040 --> 01:15:27,030
 

3395
01:15:25,050 --> 01:15:30,870
 focus on solution quality optimization

3396
01:15:27,020 --> 01:15:30,870
 

3397
01:15:27,030 --> 01:15:32,910
 and yeah that they actually quite

3398
01:15:30,860 --> 01:15:32,910
 

3399
01:15:30,870 --> 01:15:35,880
 related to ban

3400
01:15:32,900 --> 01:15:35,880
 

3401
01:15:32,910 --> 01:15:40,130
 that Kevin will talk about in his part

3402
01:15:35,870 --> 01:15:40,130
 

3403
01:15:35,880 --> 01:15:42,510
 of in the next part about theory then

3404
01:15:40,120 --> 01:15:42,510
 

3405
01:15:40,130 --> 01:15:45,240
 the the first framework that actually

3406
01:15:42,500 --> 01:15:45,240
 

3407
01:15:42,510 --> 01:15:47,490
 introduced these ideas on adaptive

3408
01:15:45,230 --> 01:15:47,490
 

3409
01:15:45,240 --> 01:15:49,680
 capping and censoring was was param LS

3410
01:15:47,480 --> 01:15:49,680
 

3411
01:15:47,490 --> 01:15:51,750
 which is an iterated local search in

3412
01:15:49,670 --> 01:15:51,750
 

3413
01:15:49,680 --> 01:15:54,930
 hermetic configuration space so here is

3414
01:15:51,740 --> 01:15:54,930
 

3415
01:15:51,750 --> 01:15:56,340
 a animation of that so you initialize

3416
01:15:54,920 --> 01:15:56,340
 

3417
01:15:54,930 --> 01:15:58,860
 somewhere in the space and then you just

3418
01:15:56,330 --> 01:15:58,860
 

3419
01:15:56,340 --> 01:16:00,900
 do a local search to move up to some

3420
01:15:58,850 --> 01:16:00,900
 

3421
01:15:58,860 --> 01:16:02,490
 local optimum then you do some sort of

3422
01:16:00,890 --> 01:16:02,490
 

3423
01:16:00,900 --> 01:16:04,530
 perturbation to get somewhere else in

3424
01:16:02,480 --> 01:16:04,530
 

3425
01:16:02,490 --> 01:16:07,440
 the space do another local search and

3426
01:16:04,520 --> 01:16:07,440
 

3427
01:16:04,530 --> 01:16:09,360
 end up in a different part of the at a

3428
01:16:07,430 --> 01:16:09,360
 

3429
01:16:07,440 --> 01:16:10,860
 different optimum and then you have some

3430
01:16:09,350 --> 01:16:10,860
 

3431
01:16:09,360 --> 01:16:13,530
 acceptance criterion that decides

3432
01:16:10,850 --> 01:16:13,530
 

3433
01:16:10,860 --> 01:16:16,980
 whether to keep your your previous best

3434
01:16:13,520 --> 01:16:16,980
 

3435
01:16:13,530 --> 01:16:19,080
 optimum or the new one to continue the

3436
01:16:16,970 --> 01:16:19,080
 

3437
01:16:16,980 --> 01:16:21,060
 search from so you basically do a biased

3438
01:16:19,070 --> 01:16:21,060
 

3439
01:16:19,080 --> 01:16:24,720
 random walk over the Optima of your

3440
01:16:21,050 --> 01:16:24,720
 

3441
01:16:21,060 --> 01:16:27,470
 configuration space and iterate and

3442
01:16:24,710 --> 01:16:27,470
 

3443
01:16:24,720 --> 01:16:31,080
 again it's in any time algorithm and

3444
01:16:27,460 --> 01:16:31,080
 

3445
01:16:27,470 --> 01:16:32,910
 this this was really the first general

3446
01:16:31,070 --> 01:16:32,910
 

3447
01:16:31,080 --> 01:16:35,850
 configuration method for run time

3448
01:16:32,900 --> 01:16:35,850
 

3449
01:16:32,910 --> 01:16:40,850
 optimization and that we did by now

3450
01:16:35,840 --> 01:16:40,850
 

3451
01:16:35,850 --> 01:16:43,230
 actually what twelve years ago then

3452
01:16:40,840 --> 01:16:43,230
 

3453
01:16:40,850 --> 01:16:46,860
 genetic algorithms are also a very

3454
01:16:43,220 --> 01:16:46,860
 

3455
01:16:43,230 --> 01:16:49,740
 generic approach for optimizing in a

3456
01:16:46,850 --> 01:16:49,740
 

3457
01:16:46,860 --> 01:16:51,600
 space of discrete and sometimes also

3458
01:16:49,730 --> 01:16:51,600
 

3459
01:16:49,740 --> 01:16:52,740
 continuous parameters so what is a

3460
01:16:51,590 --> 01:16:52,740
 

3461
01:16:51,600 --> 01:16:54,990
 genetic algorithm you have some

3462
01:16:52,730 --> 01:16:54,990
 

3463
01:16:52,740 --> 01:16:57,030
 population of individuals called genomes

3464
01:16:54,980 --> 01:16:57,030
 

3465
01:16:54,990 --> 01:16:59,370
 and you modify those population by

3466
01:16:57,020 --> 01:16:59,370
 

3467
01:16:57,030 --> 01:17:02,400
 mutations that are random changes or

3468
01:16:59,360 --> 01:17:02,400
 

3469
01:16:59,370 --> 01:17:04,560
 crossovers that combine two parents to

3470
01:17:02,390 --> 01:17:04,560
 

3471
01:17:02,400 --> 01:17:05,970
 form a so-called offspring what does

3472
01:17:04,550 --> 01:17:05,970
 

3473
01:17:04,560 --> 01:17:07,890
 this mean for algorithm configuration

3474
01:17:05,960 --> 01:17:07,890
 

3475
01:17:05,970 --> 01:17:10,110
 while the genome is the parameter

3476
01:17:07,880 --> 01:17:10,110
 

3477
01:17:07,890 --> 01:17:11,640
 configuration and the crossover would

3478
01:17:10,100 --> 01:17:11,640
 

3479
01:17:10,110 --> 01:17:13,200
 take two parameter configurations and

3480
01:17:11,630 --> 01:17:13,200
 

3481
01:17:11,640 --> 01:17:15,690
 combine them somehow to form a new

3482
01:17:13,190 --> 01:17:15,690
 

3483
01:17:13,200 --> 01:17:17,820
 configuration this particular algorithm

3484
01:17:15,680 --> 01:17:17,820
 

3485
01:17:15,690 --> 01:17:19,740
 here has two genders there's one

3486
01:17:17,810 --> 01:17:19,740
 

3487
01:17:17,820 --> 01:17:21,420
 competitive gender and one

3488
01:17:19,730 --> 01:17:21,420
 

3489
01:17:19,740 --> 01:17:24,210
 non-competitive gender that that adds

3490
01:17:21,410 --> 01:17:24,210
 

3491
01:17:21,420 --> 01:17:26,010
 some diversity to the population and the

3492
01:17:24,200 --> 01:17:26,010
 

3493
01:17:24,210 --> 01:17:29,220
 selection pressure here is only on the

3494
01:17:26,000 --> 01:17:29,220
 

3495
01:17:26,010 --> 01:17:32,340
 on the one gender so that what you

3496
01:17:29,210 --> 01:17:32,340
 

3497
01:17:29,220 --> 01:17:34,320
 preserve this diversity one thing that's

3498
01:17:32,330 --> 01:17:34,320
 

3499
01:17:32,340 --> 01:17:36,350
 very nice about GTA is that it can

3500
01:17:34,310 --> 01:17:36,350
 

3501
01:17:34,320 --> 01:17:38,940
 exploit parallel resources very nicely

3502
01:17:36,340 --> 01:17:38,940
 

3503
01:17:36,350 --> 01:17:40,800
 because it evaluates all the population

3504
01:17:38,930 --> 01:17:40,800
 

3505
01:17:38,940 --> 01:17:42,240
 members in parallel and then the

3506
01:17:40,790 --> 01:17:42,240
 

3507
01:17:40,800 --> 01:17:44,160
 adaptive capping mechanism is actually

3508
01:17:42,230 --> 01:17:44,160
 

3509
01:17:42,240 --> 01:17:45,820
 coupled with that you can run all of

3510
01:17:44,150 --> 01:17:45,820
 

3511
01:17:44,160 --> 01:17:48,280
 your configurations in parallel

3512
01:17:45,810 --> 01:17:48,280
 

3513
01:17:45,820 --> 01:17:49,810
 and you stop when the first K succeed

3514
01:17:48,270 --> 01:17:49,810
 

3515
01:17:48,280 --> 01:17:54,100
 and those case arrived and the other

3516
01:17:49,800 --> 01:17:54,100
 

3517
01:17:49,810 --> 01:17:57,250
 ones died in terms of the number of

3518
01:17:54,090 --> 01:17:57,250
 

3519
01:17:54,100 --> 01:18:01,480
 instances it uses it's it increases its

3520
01:17:57,240 --> 01:18:01,480
 

3521
01:17:57,250 --> 01:18:04,450
 number of n in each iteration a linear

3522
01:18:01,470 --> 01:18:04,450
 

3523
01:18:01,480 --> 01:18:06,670
 increase from n start to an end that's

3524
01:18:04,440 --> 01:18:06,670
 

3525
01:18:04,450 --> 01:18:09,460
 somewhat suboptimal because well an end

3526
01:18:06,660 --> 01:18:09,460
 

3527
01:18:06,670 --> 01:18:13,660
 is still I'm not infinite so it's not

3528
01:18:09,450 --> 01:18:13,660
 

3529
01:18:09,460 --> 01:18:17,740
 going to - I'm converged to the optimum

3530
01:18:13,650 --> 01:18:17,740
 

3531
01:18:13,660 --> 01:18:19,420
 and also in the end there's going to be

3532
01:18:17,730 --> 01:18:19,420
 

3533
01:18:17,740 --> 01:18:23,080
 if there are bad configurations they

3534
01:18:19,410 --> 01:18:23,080
 

3535
01:18:19,420 --> 01:18:26,850
 still get end instances and and it's

3536
01:18:23,070 --> 01:18:26,850
 

3537
01:18:23,080 --> 01:18:29,950
 fairly slow to evaluate those all right

3538
01:18:26,840 --> 01:18:29,950
 

3539
01:18:26,850 --> 01:18:32,170
 so now I'll talk about some case studies

3540
01:18:29,940 --> 01:18:32,170
 

3541
01:18:29,950 --> 01:18:34,690
 and also comparing these configuration

3542
01:18:32,160 --> 01:18:34,690
 

3543
01:18:32,170 --> 01:18:37,570
 methods and telling you why why it is

3544
01:18:34,680 --> 01:18:37,570
 

3545
01:18:34,690 --> 01:18:40,900
 actually smack that like heaven used for

3546
01:18:37,560 --> 01:18:40,900
 

3547
01:18:37,570 --> 01:18:42,400
 example so I'll first tell you about two

3548
01:18:40,890 --> 01:18:42,400
 

3549
01:18:40,900 --> 01:18:44,350
 case studies that we actually did back

3550
01:18:42,390 --> 01:18:44,350
 

3551
01:18:42,400 --> 01:18:47,200
 in the day was perilous because that was

3552
01:18:44,340 --> 01:18:47,200
 

3553
01:18:44,350 --> 01:18:49,690
 the first configurator we had the first

3554
01:18:47,190 --> 01:18:49,690
 

3555
01:18:47,200 --> 01:18:51,400
 one was on on Sat encoded instances from

3556
01:18:49,680 --> 01:18:51,400
 

3557
01:18:49,690 --> 01:18:53,680
 formal verification so that that's the

3558
01:18:51,390 --> 01:18:53,680
 

3559
01:18:51,400 --> 01:18:56,200
 other big market of Sat solving these

3560
01:18:53,670 --> 01:18:56,200
 

3561
01:18:53,680 --> 01:18:57,490
 days an industrial market software

3562
01:18:56,190 --> 01:18:57,490
 

3563
01:18:56,200 --> 01:19:01,270
 verification and hardware verification

3564
01:18:57,480 --> 01:19:01,270
 

3565
01:18:57,490 --> 01:19:03,070
 there is well a lot of need for for

3566
01:19:01,260 --> 01:19:03,070
 

3567
01:19:01,270 --> 01:19:05,770
 verifying that that we don't have a null

3568
01:19:03,060 --> 01:19:05,770
 

3569
01:19:03,070 --> 01:19:08,530
 pointer exception in our codes and known

3570
01:19:05,760 --> 01:19:08,530
 

3571
01:19:05,770 --> 01:19:09,970
 no bugs in our chips and what we did

3572
01:19:08,520 --> 01:19:09,970
 

3573
01:19:08,530 --> 01:19:12,340
 back then we took the state-of-the-art

3574
01:19:09,960 --> 01:19:12,340
 

3575
01:19:09,970 --> 01:19:14,440
 research algorithm that was built for

3576
01:19:12,330 --> 01:19:14,440
 

3577
01:19:12,340 --> 01:19:18,940
 Sat based verification it's called spare

3578
01:19:14,430 --> 01:19:18,940
 

3579
01:19:14,440 --> 01:19:20,860
 and at 26 parameters we ran Pamela's for

3580
01:19:18,930 --> 01:19:20,860
 

3581
01:19:18,940 --> 01:19:22,360
 two days and 10 machines on a training

3582
01:19:20,850 --> 01:19:22,360
 

3583
01:19:20,860 --> 01:19:23,560
 set from it for each of these

3584
01:19:22,350 --> 01:19:23,560
 

3585
01:19:22,360 --> 01:19:25,660
 distributions hardware and software

3586
01:19:23,550 --> 01:19:25,660
 

3587
01:19:23,560 --> 01:19:28,180
 verification when we compared it to the

3588
01:19:25,650 --> 01:19:28,180
 

3589
01:19:25,660 --> 01:19:29,740
 manual manually engineered default that

3590
01:19:28,170 --> 01:19:29,740
 

3591
01:19:28,180 --> 01:19:32,920
 was based on one week of performance

3592
01:19:29,730 --> 01:19:32,920
 

3593
01:19:29,740 --> 01:19:36,400
 tuning and made it actually competitive

3594
01:19:32,910 --> 01:19:36,400
 

3595
01:19:32,920 --> 01:19:37,840
 to the state of the art and for the

3596
01:19:36,390 --> 01:19:37,840
 

3597
01:19:36,400 --> 01:19:40,150
 hardware verification setting we

3598
01:19:37,830 --> 01:19:40,150
 

3599
01:19:37,840 --> 01:19:42,490
 actually got a 4.5 full speed up on

3600
01:19:40,140 --> 01:19:42,490
 

3601
01:19:40,150 --> 01:19:45,730
 average and note that actually for the

3602
01:19:42,480 --> 01:19:45,730
 

3603
01:19:42,490 --> 01:19:47,530
 easy instances here the default is

3604
01:19:45,720 --> 01:19:47,530
 

3605
01:19:45,730 --> 01:19:49,540
 actually better but only for the hard

3606
01:19:47,520 --> 01:19:49,540
 

3607
01:19:47,530 --> 01:19:51,490
 instances the configured setting is

3608
01:19:49,530 --> 01:19:51,490
 

3609
01:19:49,540 --> 01:19:53,920
 actually better and that is because the

3610
01:19:51,480 --> 01:19:53,920
 

3611
01:19:51,490 --> 01:19:56,650
 oh my god Babbage the developer actually

3612
01:19:53,910 --> 01:19:56,650
 

3613
01:19:53,920 --> 01:19:58,810
 and coming up with this default actually

3614
01:19:56,640 --> 01:19:58,810
 

3615
01:19:56,650 --> 01:20:01,600
 kind of focused on the easier instances

3616
01:19:58,800 --> 01:20:01,600
 

3617
01:19:58,810 --> 01:20:03,520
 it's cheaper to evaluate on those but

3618
01:20:01,590 --> 01:20:03,520
 

3619
01:20:01,600 --> 01:20:05,770
 then kind of over fitted a bit to these

3620
01:20:03,510 --> 01:20:05,770
 

3621
01:20:03,520 --> 01:20:07,600
 easy instances and that is that is a

3622
01:20:05,760 --> 01:20:07,600
 

3623
01:20:05,770 --> 01:20:10,030
 pattern that we see quite often the

3624
01:20:07,590 --> 01:20:10,030
 

3625
01:20:07,600 --> 01:20:11,530
 defaults of algorithms often work well

3626
01:20:10,020 --> 01:20:11,530
 

3627
01:20:10,030 --> 01:20:14,680
 for easy instances but not so well for

3628
01:20:11,520 --> 01:20:14,680
 

3629
01:20:11,530 --> 01:20:16,120
 hard instances and then for the software

3630
01:20:14,670 --> 01:20:16,120
 

3631
01:20:14,680 --> 01:20:18,670
 verification setting we actually got a

3632
01:20:16,110 --> 01:20:18,670
 

3633
01:20:16,120 --> 01:20:20,710
 500 volt speed-up got a really nice

3634
01:20:18,660 --> 01:20:20,710
 

3635
01:20:18,670 --> 01:20:22,410
 configuration and and Domeier couldn't

3636
01:20:20,700 --> 01:20:22,410
 

3637
01:20:20,710 --> 01:20:25,260
 generate any software verification

3638
01:20:22,400 --> 01:20:25,260
 

3639
01:20:22,410 --> 01:20:27,370
 problems with this generator that

3640
01:20:25,250 --> 01:20:27,370
 

3641
01:20:25,260 --> 01:20:28,630
 wouldn't be solved in less than 10

3642
01:20:27,360 --> 01:20:28,630
 

3643
01:20:27,370 --> 01:20:30,670
 seconds where is the default

3644
01:20:28,620 --> 01:20:30,670
 

3645
01:20:28,630 --> 01:20:33,250
 configuration timed out after a day on

3646
01:20:30,660 --> 01:20:33,250
 

3647
01:20:30,670 --> 01:20:37,450
 those and based on that we actually won

3648
01:20:33,240 --> 01:20:37,450
 

3649
01:20:33,250 --> 01:20:38,680
 one track of the SMT competition the

3650
01:20:37,440 --> 01:20:38,680
 

3651
01:20:37,450 --> 01:20:41,520
 second case study I want to talk about

3652
01:20:38,670 --> 01:20:41,520
 

3653
01:20:38,680 --> 01:20:43,960
 is for mixed integer programming so

3654
01:20:41,510 --> 01:20:43,960
 

3655
01:20:41,520 --> 01:20:48,360
 mixed integer programming is this really

3656
01:20:43,950 --> 01:20:48,360
 

3657
01:20:43,960 --> 01:20:50,470
 nice formulation that combines well the

3658
01:20:48,350 --> 01:20:50,470
 

3659
01:20:48,360 --> 01:20:53,530
 the efficiency of solving linear

3660
01:20:50,460 --> 01:20:53,530
 

3661
01:20:50,470 --> 01:20:55,990
 programs with the representational

3662
01:20:53,520 --> 01:20:55,990
 

3663
01:20:53,530 --> 01:20:57,820
 capacity that you get by integer

3664
01:20:55,980 --> 01:20:57,820
 

3665
01:20:55,990 --> 01:21:00,460
 variables and that make the problem

3666
01:20:57,810 --> 01:21:00,460
 

3667
01:20:57,820 --> 01:21:03,100
 np-hard and we looked at the commercial

3668
01:21:00,450 --> 01:21:03,100
 

3669
01:21:00,460 --> 01:21:05,710
 lip solver SEAPLEX which at the time was

3670
01:21:03,090 --> 01:21:05,710
 

3671
01:21:03,100 --> 01:21:06,760
 a leading solver for 15 years licensed

3672
01:21:05,700 --> 01:21:06,760
 

3673
01:21:05,710 --> 01:21:09,250
 by a whole lot of different companies

3674
01:21:06,750 --> 01:21:09,250
 

3675
01:21:06,760 --> 01:21:12,580
 and universities and had a large

3676
01:21:09,240 --> 01:21:12,580
 

3677
01:21:09,250 --> 01:21:15,070
 configuration space and nevertheless we

3678
01:21:12,570 --> 01:21:15,070
 

3679
01:21:12,580 --> 01:21:17,380
 could improve it by perma less we got

3680
01:21:15,060 --> 01:21:17,380
 

3681
01:21:15,070 --> 01:21:18,970
 between 2 and 50 fold speed up this this

3682
01:21:17,370 --> 01:21:18,970
 

3683
01:21:17,380 --> 01:21:21,220
 year is a 50 fold speed-up on average

3684
01:21:18,960 --> 01:21:21,220
 

3685
01:21:18,970 --> 01:21:23,380
 and again largest beat ups for for

3686
01:21:21,210 --> 01:21:23,380
 

3687
01:21:21,220 --> 01:21:26,230
 harder problems and later work actually

3688
01:21:23,370 --> 01:21:26,230
 

3689
01:21:23,380 --> 01:21:29,110
 with the SEAPLEX team gave up to 10,000

3690
01:21:26,220 --> 01:21:29,110
 

3691
01:21:26,230 --> 01:21:31,030
 full speed ups where the default timed

3692
01:21:29,100 --> 01:21:31,030
 

3693
01:21:29,110 --> 01:21:33,360
 out after 3 hours and the found

3694
01:21:31,020 --> 01:21:33,360
 

3695
01:21:31,030 --> 01:21:36,760
 configuration solve problems in a second

3696
01:21:33,350 --> 01:21:36,760
 

3697
01:21:33,360 --> 01:21:37,780
 and you can also this is a one case

3698
01:21:36,750 --> 01:21:37,780
 

3699
01:21:36,760 --> 01:21:40,150
 where we don't talk about runtime

3700
01:21:37,770 --> 01:21:40,150
 

3701
01:21:37,780 --> 01:21:43,000
 optimization so you can also use this in

3702
01:21:40,140 --> 01:21:43,000
 

3703
01:21:40,150 --> 01:21:46,450
 order to reduce optimality gaps of

3704
01:21:42,990 --> 01:21:46,450
 

3705
01:21:43,000 --> 01:21:48,520
 SEAPLEX so we can just change the

3706
01:21:46,440 --> 01:21:48,520
 

3707
01:21:46,450 --> 01:21:50,740
 objective function of parameter source

3708
01:21:48,510 --> 01:21:50,740
 

3709
01:21:48,520 --> 01:21:52,510
 mac or anything and then optimize a

3710
01:21:50,730 --> 01:21:52,510
 

3711
01:21:50,740 --> 01:21:54,100
 different criterion i'm in this case

3712
01:21:52,500 --> 01:21:54,100
 

3713
01:21:52,510 --> 01:21:58,470
 optimality gap the difference between

3714
01:21:54,090 --> 01:21:58,470
 

3715
01:21:54,100 --> 01:22:00,910
 the ratio between lower and upper bounds

3716
01:21:58,460 --> 01:22:00,910
 

3717
01:21:58,470 --> 01:22:03,400
 we also compared this to the SEAPLEX

3718
01:22:00,900 --> 01:22:03,400
 

3719
01:22:00,910 --> 01:22:05,410
 tooling tool which was introduced in

3720
01:22:03,390 --> 01:22:05,410
 

3721
01:22:03,400 --> 01:22:08,290
 version 11 just after primer less came

3722
01:22:05,400 --> 01:22:08,290
 

3723
01:22:05,410 --> 01:22:09,970
 out and i'm just evaluate some

3724
01:22:08,280 --> 01:22:09,970
 

3725
01:22:08,290 --> 01:22:11,210
 predefined good configurations and

3726
01:22:09,960 --> 01:22:11,210
 

3727
01:22:09,970 --> 01:22:13,010
 returns the best one

3728
01:22:11,200 --> 01:22:13,010
 

3729
01:22:11,210 --> 01:22:16,010
 and the required runtime for doing that

3730
01:22:13,000 --> 01:22:16,010
 

3731
01:22:13,010 --> 01:22:18,380
 is well that varies sometimes it takes

3732
01:22:16,000 --> 01:22:18,380
 

3733
01:22:16,010 --> 01:22:21,080
 less an hour sometimes weeks it does its

3734
01:22:18,370 --> 01:22:21,080
 

3735
01:22:18,380 --> 01:22:23,900
 own thing and then returns and so for

3736
01:22:21,070 --> 01:22:23,900
 

3737
01:22:21,080 --> 01:22:25,190
 example on the setting here it just

3738
01:22:23,890 --> 01:22:25,190
 

3739
01:22:23,900 --> 01:22:27,980
 finds something that's better than

3740
01:22:25,180 --> 01:22:27,980
 

3741
01:22:25,190 --> 01:22:29,560
 default so lower is better but parama

3742
01:22:27,970 --> 01:22:29,560
 

3743
01:22:27,980 --> 01:22:32,380
 less isn't any time algorithm and

3744
01:22:29,550 --> 01:22:32,380
 

3745
01:22:29,560 --> 01:22:34,610
 actually at every point dominates us and

3746
01:22:32,370 --> 01:22:34,610
 

3747
01:22:32,380 --> 01:22:36,680
 there was actually our worse result and

3748
01:22:34,600 --> 01:22:36,680
 

3749
01:22:34,610 --> 01:22:38,270
 our best result was this where the

3750
01:22:36,670 --> 01:22:38,270
 

3751
01:22:36,680 --> 01:22:41,420
 tuning tool actually returned the

3752
01:22:38,260 --> 01:22:41,420
 

3753
01:22:38,270 --> 01:22:46,250
 default after a couple of days and we

3754
01:22:41,410 --> 01:22:46,250
 

3755
01:22:41,420 --> 01:22:48,830
 started improving on it by a 50 fold all

3756
01:22:46,240 --> 01:22:48,830
 

3757
01:22:46,250 --> 01:22:51,140
 right why did we talk about smack

3758
01:22:48,820 --> 01:22:51,140
 

3759
01:22:48,830 --> 01:22:53,150
 because Mac actually works better than

3760
01:22:51,130 --> 01:22:53,150
 

3761
01:22:51,140 --> 01:22:54,860
 Parimal as even though I showed you

3762
01:22:53,140 --> 01:22:54,860
 

3763
01:22:53,150 --> 01:22:57,040
 these these case studies based on karma

3764
01:22:54,850 --> 01:22:57,040
 

3765
01:22:54,860 --> 01:23:00,620
 less afterwards we actually ran smack on

3766
01:22:57,030 --> 01:23:00,620
 

3767
01:22:57,040 --> 01:23:01,940
 SEAPLEX and I'm optimizing spare and in

3768
01:23:00,610 --> 01:23:01,940
 

3769
01:23:00,620 --> 01:23:06,650
 both cases actually got better results

3770
01:23:01,930 --> 01:23:06,650
 

3771
01:23:01,940 --> 01:23:08,090
 and also better results than GGA I've

3772
01:23:06,640 --> 01:23:08,090
 

3773
01:23:06,650 --> 01:23:10,070
 one last case study that I want to talk

3774
01:23:08,080 --> 01:23:10,070
 

3775
01:23:08,090 --> 01:23:13,400
 about and this is a configurable Sat

3776
01:23:10,060 --> 01:23:13,400
 

3777
01:23:10,070 --> 01:23:14,930
 solver competition so first let me let

3778
01:23:13,390 --> 01:23:14,930
 

3779
01:23:13,400 --> 01:23:15,680
 me tell you about the standard set

3780
01:23:14,920 --> 01:23:15,680
 

3781
01:23:14,930 --> 01:23:17,270
 competition

3782
01:23:15,670 --> 01:23:17,270
 

3783
01:23:15,680 --> 01:23:20,480
 it's an annual competition of Sat

3784
01:23:17,260 --> 01:23:20,480
 

3785
01:23:17,270 --> 01:23:23,090
 solvers where you score sat solvers by

3786
01:23:20,470 --> 01:23:23,090
 

3787
01:23:20,480 --> 01:23:24,890
 their performance on instances these

3788
01:23:23,080 --> 01:23:24,890
 

3789
01:23:23,090 --> 01:23:27,440
 that are selected by the competition

3790
01:23:24,880 --> 01:23:27,440
 

3791
01:23:24,890 --> 01:23:29,360
 organizers and there's medals given for

3792
01:23:27,430 --> 01:23:29,360
 

3793
01:23:27,440 --> 01:23:31,970
 algorithms that have the best average

3794
01:23:29,350 --> 01:23:31,970
 

3795
01:23:29,360 --> 01:23:34,160
 performance across these instances we're

3796
01:23:31,960 --> 01:23:34,160
 

3797
01:23:31,970 --> 01:23:35,750
 solve a default and implicitly this does

3798
01:23:34,150 --> 01:23:35,750
 

3799
01:23:34,160 --> 01:23:39,350
 kind of highlight solvers that have good

3800
01:23:35,740 --> 01:23:39,350
 

3801
01:23:35,750 --> 01:23:41,420
 default in the CSEC we turned this

3802
01:23:39,340 --> 01:23:41,420
 

3803
01:23:39,350 --> 01:23:43,040
 around and actually better reflect the

3804
01:23:41,410 --> 01:23:43,040
 

3805
01:23:41,420 --> 01:23:45,500
 application setting where we have

3806
01:23:43,030 --> 01:23:45,500
 

3807
01:23:43,040 --> 01:23:48,560
 homogeneous instances they're all kind

3808
01:23:45,490 --> 01:23:48,560
 

3809
01:23:45,500 --> 01:23:50,510
 of similar and we actually automatically

3810
01:23:48,550 --> 01:23:50,510
 

3811
01:23:48,560 --> 01:23:52,220
 optimized parameters on a training set

3812
01:23:50,500 --> 01:23:52,220
 

3813
01:23:50,510 --> 01:23:55,390
 of a distribution and then give medals

3814
01:23:52,210 --> 01:23:55,390
 

3815
01:23:52,220 --> 01:23:58,310
 to the algorithms that are best after

3816
01:23:55,380 --> 01:23:58,310
 

3817
01:23:55,390 --> 01:24:00,110
 configuration on those instances and the

3818
01:23:58,300 --> 01:24:00,110
 

3819
01:23:58,310 --> 01:24:03,740
 configuration we use smack Carmela's and

3820
01:24:00,100 --> 01:24:03,740
 

3821
01:24:00,110 --> 01:24:06,530
 GTA all of them and the first result was

3822
01:24:03,730 --> 01:24:06,530
 

3823
01:24:03,740 --> 01:24:09,980
 that's over performance often improved a

3824
01:24:06,520 --> 01:24:09,980
 

3825
01:24:06,530 --> 01:24:11,540
 lot for all of these solvers sometimes

3826
01:24:09,970 --> 01:24:11,540
 

3827
01:24:09,980 --> 01:24:14,240
 substantially reducing the time out

3828
01:24:11,530 --> 01:24:14,240
 

3829
01:24:11,540 --> 01:24:17,990
 sometimes from all time out to zero time

3830
01:24:14,230 --> 01:24:17,990
 

3831
01:24:14,240 --> 01:24:20,180
 out the second result is that the

3832
01:24:17,980 --> 01:24:20,180
 

3833
01:24:17,990 --> 01:24:23,060
 ranking the relative ranking of solvers

3834
01:24:20,170 --> 01:24:23,060
 

3835
01:24:20,180 --> 01:24:24,500
 actually changed so in this setting here

3836
01:24:23,050 --> 01:24:24,500
 

3837
01:24:23,060 --> 01:24:26,840
 what was

3838
01:24:24,490 --> 01:24:26,840
 

3839
01:24:24,500 --> 01:24:28,820
 one two three bris a default would have

3840
01:24:26,830 --> 01:24:28,820
 

3841
01:24:26,840 --> 01:24:32,000
 actually been six four and five and

3842
01:24:28,810 --> 01:24:32,000
 

3843
01:24:28,820 --> 01:24:34,760
 nowhere near the best one in terms of

3844
01:24:31,990 --> 01:24:34,760
 

3845
01:24:32,000 --> 01:24:36,650
 the default and the third result is that

3846
01:24:34,750 --> 01:24:36,650
 

3847
01:24:34,760 --> 01:24:38,600
 smack actually yielded larger results a

3848
01:24:36,640 --> 01:24:38,600
 

3849
01:24:36,650 --> 01:24:40,760
 larger speed ups and both powerless and

3850
01:24:38,590 --> 01:24:40,760
 

3851
01:24:38,600 --> 01:24:45,520
 GGA again consistent with the other

3852
01:24:40,750 --> 01:24:45,520
 

3853
01:24:40,760 --> 01:24:48,350
 results before alright at this point

3854
01:24:45,510 --> 01:24:48,350
 

3855
01:24:45,520 --> 01:24:50,420
 well I hope to have convinced you that

3856
01:24:48,340 --> 01:24:50,420
 

3857
01:24:48,350 --> 01:24:53,180
 algorithm configuration is a practical

3858
01:24:50,410 --> 01:24:53,180
 

3859
01:24:50,420 --> 01:24:54,980
 tool we'll next talk about theoretical

3860
01:24:53,170 --> 01:24:54,980
 

3861
01:24:53,180 --> 01:24:56,989
 guarantees but here we wanted to pause

3862
01:24:54,970 --> 01:24:56,989
 

3863
01:24:54,980 --> 01:25:00,070
 for a little bit and give you an

3864
01:24:56,979 --> 01:25:00,070
 

3865
01:24:56,989 --> 01:25:00,070
 opportunity to ask some questions

3866
01:25:01,760 --> 01:25:01,760
 

3867
01:25:01,770 --> 01:25:08,119
[Applause]

3868
01:25:10,579 --> 01:25:10,579
 

3869
01:25:10,589 --> 01:25:15,059
 so if you do have questions please come

3870
01:25:12,859 --> 01:25:15,059
 

3871
01:25:12,869 --> 01:25:17,819
 up to one of the microphones so that you

3872
01:25:15,049 --> 01:25:17,819
 

3873
01:25:15,059 --> 01:25:19,889
 can be heard and if you'd like to just

3874
01:25:17,809 --> 01:25:19,889
 

3875
01:25:17,819 --> 01:25:22,260
 get up and stretch your legs or use the

3876
01:25:19,879 --> 01:25:22,260
 

3877
01:25:19,889 --> 01:25:23,999
 restroom for a minute

3878
01:25:22,250 --> 01:25:23,999
 

3879
01:25:22,260 --> 01:25:27,209
 regardless take out of five minutes

3880
01:25:23,989 --> 01:25:27,209
 

3881
01:25:23,999 --> 01:25:29,369
 before we come back so get up move

3882
01:25:27,199 --> 01:25:29,369
 

3883
01:25:27,209 --> 01:25:31,709
 around but do come back because the

3884
01:25:29,359 --> 01:25:31,709
 

3885
01:25:29,369 --> 01:25:34,550
 theorems are coming next and they're the

3886
01:25:31,699 --> 01:25:34,550
 

3887
01:25:31,709 --> 01:25:36,539
 best part was there a question yeah

3888
01:25:34,540 --> 01:25:36,539
 

3889
01:25:34,550 --> 01:25:41,429
 there's a question we need to make sure

3890
01:25:36,529 --> 01:25:41,429
 

3891
01:25:36,539 --> 01:25:44,069
 that the mic actually works wondering so

3892
01:25:41,419 --> 01:25:44,069
 

3893
01:25:41,429 --> 01:25:45,479
 as you shot with smack you can really

3894
01:25:44,059 --> 01:25:45,479
 

3895
01:25:44,069 --> 01:25:48,359
 increase the performance of these

3896
01:25:45,469 --> 01:25:48,359
 

3897
01:25:45,479 --> 01:25:51,629
 solvers so I'm wondering for your first

3898
01:25:48,349 --> 01:25:51,629
 

3899
01:25:48,359 --> 01:25:54,539
 part Kevin's talk do you think there's a

3900
01:25:51,619 --> 01:25:54,539
 

3901
01:25:51,629 --> 01:25:56,939
 risk of the algorithm timing prediction

3902
01:25:54,529 --> 01:25:56,939
 

3903
01:25:54,539 --> 01:25:59,459
 overfitting to particular solvers that

3904
01:25:56,929 --> 01:25:59,459
 

3905
01:25:56,939 --> 01:26:01,499
 you're using because I mean as you

3906
01:25:59,449 --> 01:26:01,499
 

3907
01:25:59,459 --> 01:26:04,079
 showed by smack you have all these

3908
01:26:01,489 --> 01:26:04,079
 

3909
01:26:01,499 --> 01:26:05,819
 various techniques that were like able

3910
01:26:04,069 --> 01:26:05,819
 

3911
01:26:04,079 --> 01:26:09,359
 to improve the performance by quite a

3912
01:26:05,809 --> 01:26:09,359
 

3913
01:26:05,819 --> 01:26:11,099
 lot so you're asking the first point if

3914
01:26:09,349 --> 01:26:11,099
 

3915
01:26:09,359 --> 01:26:14,189
 there's a risk of overfitting them over

3916
01:26:11,089 --> 01:26:14,189
 

3917
01:26:11,099 --> 01:26:16,319
 fitting in what sense so in terms of

3918
01:26:14,179 --> 01:26:16,319
 

3919
01:26:14,189 --> 01:26:19,949
 like predicting the algorithmic

3920
01:26:16,309 --> 01:26:19,949
 

3921
01:26:16,319 --> 01:26:21,989
 performance so every result that I

3922
01:26:19,939 --> 01:26:21,989
 

3923
01:26:19,949 --> 01:26:23,429
 showed you I didn't emphasize it but

3924
01:26:21,979 --> 01:26:23,429
 

3925
01:26:21,989 --> 01:26:25,379
 everything I showed you was on held-out

3926
01:26:23,419 --> 01:26:25,379
 

3927
01:26:23,429 --> 01:26:27,809
 tested both for configuration

3928
01:26:25,369 --> 01:26:27,809
 

3929
01:26:25,379 --> 01:26:30,539
 performance and for performance

3930
01:26:27,799 --> 01:26:30,539
 

3931
01:26:27,809 --> 01:26:31,499
 prediction so over overfitting is

3932
01:26:30,529 --> 01:26:31,499
 

3933
01:26:30,539 --> 01:26:34,409
 obviously something we're very concerned

3934
01:26:31,489 --> 01:26:34,409
 

3935
01:26:31,499 --> 01:26:37,139
 about and take steps to make sure we're

3936
01:26:34,399 --> 01:26:37,139
 

3937
01:26:34,409 --> 01:26:41,719
 measuring I think generally and that

3938
01:26:37,129 --> 01:26:41,719
 

3939
01:26:37,139 --> 01:26:41,719
 hasn't been a really major problem yeah

3940
01:26:43,059 --> 01:26:43,059
 

3941
01:26:43,069 --> 01:26:48,179
 so I have a question I was wondering if

3942
01:26:45,919 --> 01:26:48,179
 

3943
01:26:45,929 --> 01:26:51,780
 you develop a generative model to

3944
01:26:48,169 --> 01:26:51,780
 

3945
01:26:48,179 --> 01:26:55,979
 generate distributions with a particular

3946
01:26:51,770 --> 01:26:55,979
 

3947
01:26:51,780 --> 01:26:58,289
 runtime behavior instead of predicting

3948
01:26:55,969 --> 01:26:58,289
 

3949
01:26:55,979 --> 01:27:01,169
 just generating actually problem classes

3950
01:26:58,279 --> 01:27:01,169
 

3951
01:26:58,289 --> 01:27:04,079
 of like uniform kind of hard or like

3952
01:27:01,159 --> 01:27:04,079
 

3953
01:27:01,169 --> 01:27:07,819
 basically understanding why certain

3954
01:27:04,069 --> 01:27:07,819
 

3955
01:27:04,079 --> 01:27:07,819
 instances are harder than the other ones

3956
01:27:10,770 --> 01:27:10,770
 

3957
01:27:10,780 --> 01:27:18,110
 yeah this is a very good idea and and

3958
01:27:15,340 --> 01:27:18,110
 

3959
01:27:15,350 --> 01:27:20,300
 you can actually you see C's IRAs and

3960
01:27:18,100 --> 01:27:20,300
 

3961
01:27:18,110 --> 01:27:22,940
 runtime prediction methods in order to

3962
01:27:20,290 --> 01:27:22,940
 

3963
01:27:20,300 --> 01:27:25,880
 generate instances that are hard and in

3964
01:27:22,930 --> 01:27:25,880
 

3965
01:27:22,940 --> 01:27:27,770
 fact kevin has done some work on that do

3966
01:27:25,870 --> 01:27:27,770
 

3967
01:27:25,880 --> 01:27:28,550
 you want to comment on that yeah sure I

3968
01:27:27,760 --> 01:27:28,550
 

3969
01:27:27,770 --> 01:27:31,040
 just didn't want to take all the

3970
01:27:28,540 --> 01:27:31,040
 

3971
01:27:28,550 --> 01:27:34,400
 questions but but yeah so we've used

3972
01:27:31,030 --> 01:27:34,400
 

3973
01:27:31,040 --> 01:27:36,680
 kind of important sampling kinds of

3974
01:27:34,390 --> 01:27:36,680
 

3975
01:27:34,400 --> 01:27:38,240
 ideas combined with predictors so you

3976
01:27:36,670 --> 01:27:38,240
 

3977
01:27:36,680 --> 01:27:40,220
 can build a predictor in the parameter

3978
01:27:38,230 --> 01:27:40,220
 

3979
01:27:38,240 --> 01:27:44,060
 space of a generator for example and

3980
01:27:40,210 --> 01:27:44,060
 

3981
01:27:40,220 --> 01:27:46,610
 then you can draw samples from the

3982
01:27:44,050 --> 01:27:46,610
 

3983
01:27:44,060 --> 01:27:48,380
 generator predict very quickly how hard

3984
01:27:46,600 --> 01:27:48,380
 

3985
01:27:46,610 --> 01:27:49,820
 they look like they would be and then

3986
01:27:48,370 --> 01:27:49,820
 

3987
01:27:48,380 --> 01:27:51,050
 kind of drive towards parts of the

3988
01:27:49,810 --> 01:27:51,050
 

3989
01:27:49,820 --> 01:27:53,480
 generator that are predicted to be

3990
01:27:51,040 --> 01:27:53,480
 

3991
01:27:51,050 --> 01:27:56,840
 harder than had been seen before and

3992
01:27:53,470 --> 01:27:56,840
 

3993
01:27:53,480 --> 01:28:00,380
 yeah we've been able to make say tens to

3994
01:27:56,830 --> 01:28:00,380
 

3995
01:27:56,840 --> 01:28:02,000
 hundreds of times hardness increases in

3996
01:28:00,370 --> 01:28:02,000
 

3997
01:28:00,380 --> 01:28:05,110
 generators compared to what people had

3998
01:28:01,990 --> 01:28:05,110
 

3999
01:28:02,000 --> 01:28:08,120
 seen before it does give you an insight

4000
01:28:05,100 --> 01:28:08,120
 

4001
01:28:05,110 --> 01:28:11,710
 why they're harder like do you see any

4002
01:28:08,110 --> 01:28:11,710
 

4003
01:28:08,120 --> 01:28:13,640
 correlation among instances that

4004
01:28:11,700 --> 01:28:13,640
 

4005
01:28:11,710 --> 01:28:16,580
 computational complexity of these

4006
01:28:13,630 --> 01:28:16,580
 

4007
01:28:13,640 --> 01:28:19,160
 instances yeah so actually we thought

4008
01:28:16,570 --> 01:28:19,160
 

4009
01:28:16,580 --> 01:28:22,040
 quit sorry I'm getting so much feedback

4010
01:28:19,150 --> 01:28:22,040
 

4011
01:28:19,160 --> 01:28:24,380
 I wonder if this is better here we've

4012
01:28:22,030 --> 01:28:24,380
 

4013
01:28:22,040 --> 01:28:26,300
 actually done quite a lot of thinking

4014
01:28:24,370 --> 01:28:26,300
 

4015
01:28:24,380 --> 01:28:29,330
 about how to use this as a kind of

4016
01:28:26,290 --> 01:28:29,330
 

4017
01:28:26,300 --> 01:28:32,420
 empirical complexity analysis I actually

4018
01:28:29,320 --> 01:28:32,420
 

4019
01:28:29,330 --> 01:28:34,370
 have a C ACM paper I guess with Frank a

4020
01:28:32,410 --> 01:28:34,370
 

4021
01:28:32,420 --> 01:28:36,410
 couple of years ago called empirical

4022
01:28:34,360 --> 01:28:36,410
 

4023
01:28:34,370 --> 01:28:37,850
 hardness models that kind of argues that

4024
01:28:36,400 --> 01:28:37,850
 

4025
01:28:36,410 --> 01:28:39,650
 if you want to do average-case

4026
01:28:37,840 --> 01:28:39,650
 

4027
01:28:37,850 --> 01:28:41,180
 complexity analysis you can sort of do

4028
01:28:39,640 --> 01:28:41,180
 

4029
01:28:39,650 --> 01:28:42,980
 it statistically using these kinds of

4030
01:28:41,170 --> 01:28:42,980
 

4031
01:28:41,180 --> 01:28:44,900
 models rather than only doing it

4032
01:28:42,970 --> 01:28:44,900
 

4033
01:28:42,980 --> 01:28:46,250
 analytically particularly because

4034
01:28:44,890 --> 01:28:46,250
 

4035
01:28:44,900 --> 01:28:48,260
 thinking about the average case is so

4036
01:28:46,240 --> 01:28:48,260
 

4037
01:28:46,250 --> 01:28:50,150
 hard analytically and there are some

4038
01:28:48,250 --> 01:28:50,150
 

4039
01:28:48,260 --> 01:28:53,480
 cases where we're able to say quite a

4040
01:28:50,140 --> 01:28:53,480
 

4041
01:28:50,150 --> 01:28:55,940
 lot about what's really going on in the

4042
01:28:53,470 --> 01:28:55,940
 

4043
01:28:53,480 --> 01:28:57,710
 average case the problem is you know

4044
01:28:55,930 --> 01:28:57,710
 

4045
01:28:55,940 --> 01:28:59,120
 these features are pretty rich so if you

4046
01:28:57,700 --> 01:28:59,120
 

4047
01:28:57,710 --> 01:29:00,710
 get something that involves you know

4048
01:28:59,110 --> 01:29:00,710
 

4049
01:28:59,120 --> 01:29:02,960
 three or four or five features you know

4050
01:29:00,700 --> 01:29:02,960
 

4051
01:29:00,710 --> 01:29:04,370
 interacting with each other it's telling

4052
01:29:02,950 --> 01:29:04,370
 

4053
01:29:02,960 --> 01:29:06,170
 you what it's telling you but it can be

4054
01:29:04,360 --> 01:29:06,170
 

4055
01:29:04,370 --> 01:29:11,150
 sometimes hard to figure out what that

4056
01:29:06,160 --> 01:29:11,150
 

4057
01:29:06,170 --> 01:29:13,070
 means Thanks but yeah so things like the

4058
01:29:11,140 --> 01:29:13,070
 

4059
01:29:11,150 --> 01:29:14,480
 loss variable ratio that was the first

4060
01:29:13,060 --> 01:29:14,480
 

4061
01:29:13,070 --> 01:29:16,520
 thing that would actually fall out of

4062
01:29:14,470 --> 01:29:16,520
 

4063
01:29:14,480 --> 01:29:19,820
 these models for if you if you run this

4064
01:29:16,510 --> 01:29:19,820
 

4065
01:29:16,520 --> 01:29:22,430
 on uniform randoms reset data but

4066
01:29:19,810 --> 01:29:22,430
 

4067
01:29:19,820 --> 01:29:23,280
 there's also a lot more things that you

4068
01:29:22,420 --> 01:29:23,280
 

4069
01:29:22,430 --> 01:29:25,820
 can explain about

4070
01:29:23,270 --> 01:29:25,820
 

4071
01:29:23,280 --> 01:29:27,840
 Hartness than just based on the CP and

4072
01:29:25,810 --> 01:29:27,840
 

4073
01:29:25,820 --> 01:29:30,179
 we actually really hope that these

4074
01:29:27,830 --> 01:29:30,179
 

4075
01:29:27,840 --> 01:29:32,309
 runtime prediction models could be used

4076
01:29:30,169 --> 01:29:32,309
 

4077
01:29:30,179 --> 01:29:33,809
 as a tool by for example theoreticians

4078
01:29:32,299 --> 01:29:33,809
 

4079
01:29:32,309 --> 01:29:35,400
 or algorithm developers to really

4080
01:29:33,799 --> 01:29:35,400
 

4081
01:29:33,809 --> 01:29:38,340
 understand something about their data

4082
01:29:35,390 --> 01:29:38,340
 

4083
01:29:35,400 --> 01:29:39,690
 and I have a part later in the beyond

4084
01:29:38,330 --> 01:29:39,690
 

4085
01:29:38,340 --> 01:29:42,840
 static configuration where I talk about

4086
01:29:39,680 --> 01:29:42,840
 

4087
01:29:39,690 --> 01:29:44,610
 well importance of parameters I focus on

4088
01:29:42,830 --> 01:29:44,610
 

4089
01:29:42,840 --> 01:29:47,429
 parameters but you can use many of the

4090
01:29:44,600 --> 01:29:47,429
 

4091
01:29:44,610 --> 01:29:49,530
 same tools to focus on the importance of

4092
01:29:47,419 --> 01:29:49,530
 

4093
01:29:47,429 --> 01:29:51,150
 instance features and then really

4094
01:29:49,520 --> 01:29:51,150
 

4095
01:29:49,530 --> 01:29:54,079
 discover these are the instance features

4096
01:29:51,140 --> 01:29:54,079
 

4097
01:29:51,150 --> 01:29:58,699
 that are decisive about performance and

4098
01:29:54,069 --> 01:29:58,699
 

4099
01:29:54,079 --> 01:30:01,139
 I'd love to see more more closed-loop

4100
01:29:58,689 --> 01:30:01,139
 

4101
01:29:58,699 --> 01:30:03,960
 algorithm developers actually looking at

4102
01:30:01,129 --> 01:30:03,960
 

4103
01:30:01,139 --> 01:30:07,559
 the model and coming up with new methods

4104
01:30:03,950 --> 01:30:07,559
 

4105
01:30:03,960 --> 01:30:09,630
 and and looking into add this is a

4106
01:30:07,549 --> 01:30:09,630
 

4107
01:30:07,559 --> 01:30:11,639
 problem this is why these instances are

4108
01:30:09,620 --> 01:30:11,639
 

4109
01:30:09,630 --> 01:30:13,860
 hard let's make them easier or let's

4110
01:30:11,629 --> 01:30:13,860
 

4111
01:30:11,639 --> 01:30:19,760
 let's devise a strategy for particular

4112
01:30:13,850 --> 01:30:19,760
 

4113
01:30:13,860 --> 01:30:24,119
 these instances I think our

4114
01:30:19,750 --> 01:30:24,119
 

4115
01:30:19,760 --> 01:30:26,909
 configuration methods have many hyper

4116
01:30:24,109 --> 01:30:26,909
 

4117
01:30:24,119 --> 01:30:29,730
 parameters and my question is how to

4118
01:30:26,899 --> 01:30:29,730
 

4119
01:30:26,909 --> 01:30:32,460
 configure it our voice configuration our

4120
01:30:29,720 --> 01:30:32,460
 

4121
01:30:29,730 --> 01:30:36,480
 ways a very good question you're not the

4122
01:30:32,450 --> 01:30:36,480
 

4123
01:30:32,460 --> 01:30:38,610
 first one to ask this so in all of the

4124
01:30:36,470 --> 01:30:38,610
 

4125
01:30:36,480 --> 01:30:41,099
 case studies I showed we used always the

4126
01:30:38,600 --> 01:30:41,099
 

4127
01:30:38,610 --> 01:30:42,929
 default parameters of smack that that is

4128
01:30:41,089 --> 01:30:42,929
 

4129
01:30:41,099 --> 01:30:45,719
 the first thing to get out so we're not

4130
01:30:42,919 --> 01:30:45,719
 

4131
01:30:42,929 --> 01:30:47,670
 fiddling the the with the parameters of

4132
01:30:45,709 --> 01:30:47,670
 

4133
01:30:45,719 --> 01:30:50,639
 the configurator to do well on the

4134
01:30:47,660 --> 01:30:50,639
 

4135
01:30:47,670 --> 01:30:52,559
 particular distribution but nevertheless

4136
01:30:50,629 --> 01:30:52,559
 

4137
01:30:50,639 --> 01:30:54,389
 there's a lot of design decisions in

4138
01:30:52,549 --> 01:30:54,389
 

4139
01:30:52,559 --> 01:30:56,550
 errors and configuration methods and you

4140
01:30:54,379 --> 01:30:56,550
 

4141
01:30:54,389 --> 01:30:58,230
 can do this meta configuration and then

4142
01:30:56,540 --> 01:30:58,230
 

4143
01:30:56,550 --> 01:31:00,329
 at some point it's kind of turtles upon

4144
01:30:58,220 --> 01:31:00,329
 

4145
01:30:58,230 --> 01:31:04,650
 Turtles upon turtles and you would hope

4146
01:31:00,319 --> 01:31:04,650
 

4147
01:31:00,329 --> 01:31:06,989
 that the the variation of performance

4148
01:31:04,640 --> 01:31:06,989
 

4149
01:31:04,650 --> 01:31:09,020
 actually gets lower and lower as you go

4150
01:31:06,979 --> 01:31:09,020
 

4151
01:31:06,989 --> 01:31:11,699
 higher and higher on the meta level and

4152
01:31:09,010 --> 01:31:11,699
 

4153
01:31:09,020 --> 01:31:14,190
 we've kind of observed that you don't

4154
01:31:11,689 --> 01:31:14,190
 

4155
01:31:11,699 --> 01:31:15,840
 gain that much by optimizing on the

4156
01:31:14,180 --> 01:31:15,840
 

4157
01:31:14,190 --> 01:31:17,489
 parameters themselves having said that

4158
01:31:15,830 --> 01:31:17,489
 

4159
01:31:15,840 --> 01:31:19,110
 you know if you're in low dimensional

4160
01:31:17,479 --> 01:31:19,110
 

4161
01:31:17,489 --> 01:31:21,270
 continuous black boxes you want to use

4162
01:31:19,100 --> 01:31:21,270
 

4163
01:31:19,110 --> 01:31:22,739
 GPS if you're in discrete land you want

4164
01:31:21,260 --> 01:31:22,739
 

4165
01:31:21,270 --> 01:31:24,360
 to use random force if you make that a

4166
01:31:22,729 --> 01:31:24,360
 

4167
01:31:22,739 --> 01:31:27,869
 design choice and while you can optimize

4168
01:31:24,350 --> 01:31:27,869
 

4169
01:31:24,360 --> 01:31:29,219
 it yeah thank you thank you okay let's

4170
01:31:27,859 --> 01:31:29,219
 

4171
01:31:27,869 --> 01:31:32,219
 take one more question and then we'll

4172
01:31:29,209 --> 01:31:32,219
 

4173
01:31:29,219 --> 01:31:36,350
 resume it's sort of a two-part question

4174
01:31:32,209 --> 01:31:36,350
 

4175
01:31:32,219 --> 01:31:38,660
 I guess the first part is for Frank

4176
01:31:36,340 --> 01:31:38,660
 

4177
01:31:36,350 --> 01:31:41,750
 I think he talked about sort of

4178
01:31:38,650 --> 01:31:41,750
 

4179
01:31:38,660 --> 01:31:43,400
 measuring that certainty and for high

4180
01:31:41,740 --> 01:31:43,400
 

4181
01:31:41,750 --> 01:31:46,520
 dimensional problems where you have many

4182
01:31:43,390 --> 01:31:46,520
 

4183
01:31:43,400 --> 01:31:48,740
 parameters you mentioned like doing

4184
01:31:46,510 --> 01:31:48,740
 

4185
01:31:46,520 --> 01:31:50,780
 function evaluations how many function

4186
01:31:48,730 --> 01:31:50,780
 

4187
01:31:48,740 --> 01:31:52,280
 evaluations you need to like get a good

4188
01:31:50,770 --> 01:31:52,280
 

4189
01:31:50,780 --> 01:31:54,310
 measure of the uncertainty and how much

4190
01:31:52,270 --> 01:31:54,310
 

4191
01:31:52,280 --> 01:31:58,820
 you need to sample that portion of the

4192
01:31:54,300 --> 01:31:58,820
 

4193
01:31:54,310 --> 01:32:01,130
 parameter space right so so how many

4194
01:31:58,810 --> 01:32:01,130
 

4195
01:31:58,820 --> 01:32:04,280
 samples do you need in order to get a

4196
01:32:01,120 --> 01:32:04,280
 

4197
01:32:01,130 --> 01:32:06,710
 good measure of uncertainty that's

4198
01:32:04,270 --> 01:32:06,710
 

4199
01:32:04,280 --> 01:32:08,900
 that's a good question I mean the the

4200
01:32:06,700 --> 01:32:08,900
 

4201
01:32:06,710 --> 01:32:12,190
 more samples you have actually the less

4202
01:32:08,890 --> 01:32:12,190
 

4203
01:32:08,900 --> 01:32:14,750
 uncertainty you have the the main main

4204
01:32:12,180 --> 01:32:14,750
 

4205
01:32:12,190 --> 01:32:17,570
 part about this uncertainty and random

4206
01:32:14,740 --> 01:32:17,570
 

4207
01:32:14,750 --> 01:32:19,760
 forests is if each of the regression

4208
01:32:17,560 --> 01:32:19,760
 

4209
01:32:17,570 --> 01:32:21,770
 trees give you the same prediction then

4210
01:32:19,750 --> 01:32:21,770
 

4211
01:32:19,760 --> 01:32:23,420
 you're pretty confident if they give you

4212
01:32:21,760 --> 01:32:23,420
 

4213
01:32:21,770 --> 01:32:25,340
 vastly different predictions and you're

4214
01:32:23,410 --> 01:32:25,340
 

4215
01:32:23,420 --> 01:32:27,920
 not confident and then while you're

4216
01:32:25,330 --> 01:32:27,920
 

4217
01:32:25,340 --> 01:32:32,030
 really uncertain and well if you have

4218
01:32:27,910 --> 01:32:32,030
 

4219
01:32:27,920 --> 01:32:34,010
 enough data such that if you do random

4220
01:32:32,020 --> 01:32:34,010
 

4221
01:32:32,030 --> 01:32:35,270
 bootstrap sampling and so on and do some

4222
01:32:34,000 --> 01:32:35,270
 

4223
01:32:34,010 --> 01:32:36,860
 different splits you still end up with

4224
01:32:35,260 --> 01:32:36,860
 

4225
01:32:35,270 --> 01:32:38,570
 the same predictions then then your

4226
01:32:36,850 --> 01:32:38,570
 

4227
01:32:36,860 --> 01:32:42,230
 uncertainty is going to be low it's it's

4228
01:32:38,560 --> 01:32:42,230
 

4229
01:32:38,570 --> 01:32:46,190
 hard to give you a quantifiable number I

4230
01:32:42,220 --> 01:32:46,190
 

4231
01:32:42,230 --> 01:32:47,750
 mean we we do the sometimes based on you

4232
01:32:46,180 --> 01:32:47,750
 

4233
01:32:46,190 --> 01:32:49,310
 know we have a total of 100 function

4234
01:32:47,740 --> 01:32:49,310
 

4235
01:32:47,750 --> 01:32:53,090
 evaluations or so and we can still run

4236
01:32:49,300 --> 01:32:53,090
 

4237
01:32:49,310 --> 01:32:54,950
 smack but if you have tens of thousands

4238
01:32:53,080 --> 01:32:54,950
 

4239
01:32:53,090 --> 01:32:57,080
 of cases then yeah you get better

4240
01:32:54,940 --> 01:32:57,080
 

4241
01:32:54,950 --> 01:32:59,570
 predictions of course okay the second

4242
01:32:57,070 --> 01:32:59,570
 

4243
01:32:57,080 --> 01:33:02,090
 part maybe it's just to clarify a little

4244
01:32:59,560 --> 01:33:02,090
 

4245
01:32:59,570 --> 01:33:09,680
 bit it seems like you're interested in

4246
01:33:02,080 --> 01:33:09,680
 

4247
01:33:02,090 --> 01:33:11,450
 predicting the run time why is that the

4248
01:33:09,670 --> 01:33:11,450
 

4249
01:33:09,680 --> 01:33:12,980
 question is why are we interested in

4250
01:33:11,440 --> 01:33:12,980
 

4251
01:33:11,450 --> 01:33:14,840
 predicting run time yeah

4252
01:33:12,970 --> 01:33:14,840
 

4253
01:33:12,980 --> 01:33:17,750
 well I mean I think often we're

4254
01:33:14,830 --> 01:33:17,750
 

4255
01:33:14,840 --> 01:33:19,190
 interested in building algorithms so

4256
01:33:17,740 --> 01:33:19,190
 

4257
01:33:17,750 --> 01:33:20,990
 it's like just to question two reasons

4258
01:33:19,180 --> 01:33:20,990
 

4259
01:33:19,190 --> 01:33:22,460
 why we might I've partly I think we're

4260
01:33:20,980 --> 01:33:22,460
 

4261
01:33:20,990 --> 01:33:24,590
 interested in building algorithms with

4262
01:33:22,450 --> 01:33:24,590
 

4263
01:33:22,460 --> 01:33:26,240
 shorter runtimes and so being able to

4264
01:33:24,580 --> 01:33:26,240
 

4265
01:33:24,590 --> 01:33:28,790
 understand what drives their run time

4266
01:33:26,230 --> 01:33:28,790
 

4267
01:33:26,240 --> 01:33:30,350
 you know can be useful so each situation

4268
01:33:28,780 --> 01:33:30,350
 

4269
01:33:28,790 --> 01:33:34,610
 they'll all get the same like I don't

4270
01:33:30,340 --> 01:33:34,610
 

4271
01:33:30,350 --> 01:33:36,050
 know performance right so typically

4272
01:33:34,600 --> 01:33:36,050
 

4273
01:33:34,610 --> 01:33:37,250
 we're thinking about problems this is

4274
01:33:36,040 --> 01:33:37,250
 

4275
01:33:36,050 --> 01:33:38,060
 something we didn't stress but that's a

4276
01:33:37,240 --> 01:33:38,060
 

4277
01:33:37,250 --> 01:33:39,800
 really good point

4278
01:33:38,050 --> 01:33:39,800
 

4279
01:33:38,060 --> 01:33:42,470
 typically we're thinking about problems

4280
01:33:39,790 --> 01:33:42,470
 

4281
01:33:39,800 --> 01:33:44,240
 where exactly the same result is being

4282
01:33:42,460 --> 01:33:44,240
 

4283
01:33:42,470 --> 01:33:46,790
 returned and the only question is the

4284
01:33:44,230 --> 01:33:46,790
 

4285
01:33:44,240 --> 01:33:48,500
 amount of time so for example you know

4286
01:33:46,780 --> 01:33:48,500
 

4287
01:33:46,790 --> 01:33:48,960
 what I'm talking about a Sat solver you

4288
01:33:48,490 --> 01:33:48,960
 

4289
01:33:48,500 --> 01:33:51,570
 know

4290
01:33:48,950 --> 01:33:51,570
 

4291
01:33:48,960 --> 01:33:53,610
 it provably gives you the answer whether

4292
01:33:51,560 --> 01:33:53,610
 

4293
01:33:51,570 --> 01:33:55,590
 the formula is satisfiable or not it

4294
01:33:53,600 --> 01:33:55,590
 

4295
01:33:53,610 --> 01:33:57,390
 proves that it isn't satisfiable or it

4296
01:33:55,580 --> 01:33:57,390
 

4297
01:33:55,590 --> 01:33:59,160
 finds you a satisfying assignment the

4298
01:33:57,380 --> 01:33:59,160
 

4299
01:33:57,390 --> 01:34:01,590
 only question is how long it takes to do

4300
01:33:59,150 --> 01:34:01,590
 

4301
01:33:59,160 --> 01:34:03,450
 that so typically we're not thinking

4302
01:34:01,580 --> 01:34:03,450
 

4303
01:34:01,590 --> 01:34:05,070
 about varying solution quality at the

4304
01:34:03,440 --> 01:34:05,070
 

4305
01:34:03,450 --> 01:34:07,950
 same time as we're thinking about run

4306
01:34:05,060 --> 01:34:07,950
 

4307
01:34:05,070 --> 01:34:09,570
 time that's a really good point still if

4308
01:34:07,940 --> 01:34:09,570
 

4309
01:34:07,950 --> 01:34:11,910
 you're if you deep learner for example

4310
01:34:09,560 --> 01:34:11,910
 

4311
01:34:09,570 --> 01:34:14,580
 and you care more about performance then

4312
01:34:11,900 --> 01:34:14,580
 

4313
01:34:11,910 --> 01:34:16,590
 you could say well you still want to

4314
01:34:14,570 --> 01:34:16,590
 

4315
01:34:14,580 --> 01:34:18,750
 optimize a run time in order to get I

4316
01:34:16,580 --> 01:34:18,750
 

4317
01:34:16,590 --> 01:34:20,850
 don't know 96 percent on c4 or something

4318
01:34:18,740 --> 01:34:20,850
 

4319
01:34:18,750 --> 01:34:23,070
 like that so you could still use that in

4320
01:34:20,840 --> 01:34:23,070
 

4321
01:34:20,850 --> 01:34:24,180
 in that setting but well here we we

4322
01:34:23,060 --> 01:34:24,180
 

4323
01:34:23,070 --> 01:34:25,620
 talked mostly about comment early

4324
01:34:24,170 --> 01:34:25,620
 

4325
01:34:24,180 --> 01:34:27,990
 optimization solvers where that's kind

4326
01:34:25,610 --> 01:34:27,990
 

4327
01:34:25,620 --> 01:34:29,340
 of the only setting you care about you

4328
01:34:27,980 --> 01:34:29,340
 

4329
01:34:27,990 --> 01:34:30,870
 know exactly but it just has to be

4330
01:34:29,330 --> 01:34:30,870
 

4331
01:34:29,340 --> 01:34:32,310
 well-defined so it's an apples to apples

4332
01:34:30,860 --> 01:34:32,310
 

4333
01:34:30,870 --> 01:34:34,800
 comparison so it doesn't have to be

4334
01:34:32,300 --> 01:34:34,800
 

4335
01:34:32,310 --> 01:34:37,560
 optimality but it has to be the same

4336
01:34:34,790 --> 01:34:37,560
 

4337
01:34:34,800 --> 01:34:42,150
 thing across different solvers yeah cool

4338
01:34:37,550 --> 01:34:42,150
 

4339
01:34:37,560 --> 01:34:43,770
 okay so I'm gonna now go into algorithm

4340
01:34:42,140 --> 01:34:43,770
 

4341
01:34:42,150 --> 01:34:48,720
 configuration methods with theoretical

4342
01:34:43,760 --> 01:34:48,720
 

4343
01:34:43,770 --> 01:34:50,100
 guarantees so so far you know Nina's

4344
01:34:48,710 --> 01:34:50,100
 

4345
01:34:48,720 --> 01:34:52,800
 walking away because this is all about

4346
01:34:50,090 --> 01:34:52,800
 

4347
01:34:50,100 --> 01:34:54,830
 her work and so she's gonna be not only

4348
01:34:52,790 --> 01:34:54,830
 

4349
01:34:52,800 --> 01:34:57,720
 at the end oh you can leave it's fine

4350
01:34:54,820 --> 01:34:57,720
 

4351
01:34:54,830 --> 01:35:00,990
 it's all good I'm just I'm just making

4352
01:34:57,710 --> 01:35:00,990
 

4353
01:34:57,720 --> 01:35:05,130
 fun of you because it's easy to do so

4354
01:35:00,980 --> 01:35:05,130
 

4355
01:35:00,990 --> 01:35:06,870
 yeah it's as Frank mentioned before the

4356
01:35:05,120 --> 01:35:06,870
 

4357
01:35:05,130 --> 01:35:09,990
 only thing that we can really say about

4358
01:35:06,860 --> 01:35:09,990
 

4359
01:35:06,870 --> 01:35:11,520
 these practically oriented solvers is

4360
01:35:09,980 --> 01:35:11,520
 

4361
01:35:09,990 --> 01:35:13,170
 that they achieve optimality in the

4362
01:35:11,510 --> 01:35:13,170
 

4363
01:35:11,520 --> 01:35:15,300
 limit you know if indeed they even do

4364
01:35:13,160 --> 01:35:15,300
 

4365
01:35:13,170 --> 01:35:16,980
 and that's kind of a one-line proof

4366
01:35:15,290 --> 01:35:16,980
 

4367
01:35:15,300 --> 01:35:19,050
 right that just says if you sample

4368
01:35:16,970 --> 01:35:19,050
 

4369
01:35:16,980 --> 01:35:21,000
 something often enough and you do it

4370
01:35:19,040 --> 01:35:21,000
 

4371
01:35:19,050 --> 01:35:22,710
 infinitely and there's some chance of

4372
01:35:20,990 --> 01:35:22,710
 

4373
01:35:21,000 --> 01:35:24,810
 hitting every configuration and infinite

4374
01:35:22,700 --> 01:35:24,810
 

4375
01:35:22,710 --> 01:35:27,300
 amount of times you'll eventually find

4376
01:35:24,800 --> 01:35:27,300
 

4377
01:35:24,810 --> 01:35:29,010
 something good that's not very exciting

4378
01:35:27,290 --> 01:35:29,010
 

4379
01:35:27,300 --> 01:35:31,440
 if we want to do something theoretical

4380
01:35:29,000 --> 01:35:31,440
 

4381
01:35:29,010 --> 01:35:33,450
 we want to make sort of a convergence

4382
01:35:31,430 --> 01:35:33,450
 

4383
01:35:31,440 --> 01:35:35,910
 rate kind of argument so we want to say

4384
01:35:33,440 --> 01:35:35,910
 

4385
01:35:33,450 --> 01:35:38,220
 a good algorithm configurator is one

4386
01:35:35,900 --> 01:35:38,220
 

4387
01:35:35,910 --> 01:35:39,930
 that finds good configurations more

4388
01:35:38,210 --> 01:35:39,930
 

4389
01:35:38,220 --> 01:35:43,890
 quickly than another configurator would

4390
01:35:39,920 --> 01:35:43,890
 

4391
01:35:39,930 --> 01:35:46,170
 in the worst case so that that's what

4392
01:35:43,880 --> 01:35:46,170
 

4393
01:35:43,890 --> 01:35:48,510
 I'm going to try to talk about here and

4394
01:35:46,160 --> 01:35:48,510
 

4395
01:35:46,170 --> 01:35:51,140
 I'm going to follow some joint work with

4396
01:35:48,500 --> 01:35:51,140
 

4397
01:35:48,510 --> 01:35:53,610
 Bobby Kleinberg and Brendan Lucia

4398
01:35:51,130 --> 01:35:53,610
 

4399
01:35:51,140 --> 01:35:57,120
 through the first few sections of this

4400
01:35:53,600 --> 01:35:57,120
 

4401
01:35:53,610 --> 01:35:59,910
 part so I'm beginning with technical

4402
01:35:57,110 --> 01:35:59,910
 

4403
01:35:57,120 --> 01:36:01,260
 setup this is what you saw before back

4404
01:35:59,900 --> 01:36:01,260
 

4405
01:35:59,910 --> 01:36:02,519
 when I was speaking before but let me

4406
01:36:01,250 --> 01:36:02,519
 

4407
01:36:01,260 --> 01:36:04,409
 just remind you because

4408
01:36:02,509 --> 01:36:04,409
 

4409
01:36:02,519 --> 01:36:06,300
 I'm gonna be much more notation heavy in

4410
01:36:04,399 --> 01:36:06,300
 

4411
01:36:04,409 --> 01:36:08,550
 this part of the talk so this is your

4412
01:36:06,290 --> 01:36:08,550
 

4413
01:36:06,300 --> 01:36:11,340
 chance to remember what these variable

4414
01:36:08,540 --> 01:36:11,340
 

4415
01:36:08,550 --> 01:36:13,590
 names were so my algorithm is a my

4416
01:36:11,330 --> 01:36:13,590
 

4417
01:36:11,340 --> 01:36:15,510
 configuration space is Theta and I'll

4418
01:36:13,580 --> 01:36:15,510
 

4419
01:36:13,590 --> 01:36:17,670
 use a little theta when I'm iterating

4420
01:36:15,500 --> 01:36:17,670
 

4421
01:36:15,510 --> 01:36:20,400
 indexing a particular configuration I

4422
01:36:17,660 --> 01:36:20,400
 

4423
01:36:17,670 --> 01:36:24,630
 have a distribution D over in put

4424
01:36:20,390 --> 01:36:24,630
 

4425
01:36:20,400 --> 01:36:27,119
 instances and I'll use a lowercase PI to

4426
01:36:24,620 --> 01:36:27,119
 

4427
01:36:24,630 --> 01:36:29,340
 identify an input instance random seed

4428
01:36:27,109 --> 01:36:29,340
 

4429
01:36:27,119 --> 01:36:31,050
 pair which I'll call an instance of

4430
01:36:29,330 --> 01:36:31,050
 

4431
01:36:29,340 --> 01:36:32,550
 course the algorithm can be randomized

4432
01:36:31,040 --> 01:36:32,550
 

4433
01:36:31,050 --> 01:36:34,320
 so when I have a different random C to

4434
01:36:32,540 --> 01:36:34,320
 

4435
01:36:32,550 --> 01:36:36,119
 be an algorithm running on the same

4436
01:36:34,310 --> 01:36:36,119
 

4437
01:36:34,320 --> 01:36:38,340
 instance it'll have a different runtime

4438
01:36:36,109 --> 01:36:38,340
 

4439
01:36:36,119 --> 01:36:39,900
 so I'm gonna assume that the seed is

4440
01:36:38,330 --> 01:36:39,900
 

4441
01:36:38,340 --> 01:36:43,230
 fixed so I can talk about the algorithm

4442
01:36:39,890 --> 01:36:43,230
 

4443
01:36:39,900 --> 01:36:45,510
 being deterministic I have this cut off

4444
01:36:43,220 --> 01:36:45,510
 

4445
01:36:43,230 --> 01:36:47,099
 time cap a bar now before we talked

4446
01:36:45,500 --> 01:36:47,099
 

4447
01:36:45,510 --> 01:36:48,719
 about it as a cut off time but now I'm

4448
01:36:47,089 --> 01:36:48,719
 

4449
01:36:47,099 --> 01:36:50,909
 gonna say it's a max cut off time

4450
01:36:48,709 --> 01:36:50,909
 

4451
01:36:48,719 --> 01:36:52,530
 because a really critical thing in this

4452
01:36:50,899 --> 01:36:52,530
 

4453
01:36:50,909 --> 01:36:55,139
 part of the talk is going to be thinking

4454
01:36:52,520 --> 01:36:55,139
 

4455
01:36:52,530 --> 01:36:56,820
 about varying how long a cut off I give

4456
01:36:55,129 --> 01:36:56,820
 

4457
01:36:55,139 --> 01:36:58,710
 to my algorithm that that turns out to

4458
01:36:56,810 --> 01:36:58,710
 

4459
01:36:56,820 --> 01:37:02,249
 be really fundamental to getting good

4460
01:36:58,700 --> 01:37:02,249
 

4461
01:36:58,710 --> 01:37:03,989
 theoretical performance and therefore

4462
01:37:02,239 --> 01:37:03,989
 

4463
01:37:02,249 --> 01:37:07,650
 I'm going to need to somewhat elaborate

4464
01:37:03,979 --> 01:37:07,650
 

4465
01:37:03,989 --> 01:37:11,280
 my notation for run time so our sub

4466
01:37:07,640 --> 01:37:11,280
 

4467
01:37:07,650 --> 01:37:14,159
 kappa of theta pi is going to give the

4468
01:37:11,270 --> 01:37:14,159
 

4469
01:37:11,280 --> 01:37:16,820
 deterministic run time of configuration

4470
01:37:14,149 --> 01:37:16,820
 

4471
01:37:14,159 --> 01:37:22,409
 theta running on instance seed pair pi

4472
01:37:16,810 --> 01:37:22,409
 

4473
01:37:16,820 --> 01:37:24,360
 if I was to cap at at cap time Kappa if

4474
01:37:22,399 --> 01:37:24,360
 

4475
01:37:22,409 --> 01:37:26,550
 I drop the PI

4476
01:37:24,350 --> 01:37:26,550
 

4477
01:37:24,360 --> 01:37:31,260
 I'll just be talking about the expected

4478
01:37:26,540 --> 01:37:31,260
 

4479
01:37:26,550 --> 01:37:34,409
 runtime overall instance e pairs of my

4480
01:37:31,250 --> 01:37:34,409
 

4481
01:37:31,260 --> 01:37:36,929
 configuration theta and if I also drop

4482
01:37:34,399 --> 01:37:36,929
 

4483
01:37:34,409 --> 01:37:38,610
 the Kappa that means I'm talking about

4484
01:37:36,919 --> 01:37:38,610
 

4485
01:37:36,929 --> 01:37:40,320
 Kappa bar it means I'm talking about the

4486
01:37:38,600 --> 01:37:40,320
 

4487
01:37:38,610 --> 01:37:43,469
 biggest possible cap time that I would

4488
01:37:40,310 --> 01:37:43,469
 

4489
01:37:40,320 --> 01:37:47,519
 ever be willing to consider finally I'll

4490
01:37:43,459 --> 01:37:47,519
 

4491
01:37:43,469 --> 01:37:49,530
 introduce a new cap time Kappa not by

4492
01:37:47,509 --> 01:37:49,530
 

4493
01:37:47,519 --> 01:37:51,869
 which I'll refer to the shortest run

4494
01:37:49,520 --> 01:37:51,869
 

4495
01:37:49,530 --> 01:37:53,249
 time that I'm willing to think about the

4496
01:37:51,859 --> 01:37:53,249
 

4497
01:37:51,869 --> 01:37:55,409
 reason it makes sense to have a shortest

4498
01:37:53,239 --> 01:37:55,409
 

4499
01:37:53,249 --> 01:37:58,230
 run time is that I just can't reliably

4500
01:37:55,399 --> 01:37:58,230
 

4501
01:37:55,409 --> 01:37:59,969
 measure run times below some point on a

4502
01:37:58,220 --> 01:37:59,969
 

4503
01:37:58,230 --> 01:38:01,469
 computer so I'm just gonna have some

4504
01:37:59,959 --> 01:38:01,469
 

4505
01:37:59,969 --> 01:38:03,929
 minimum run time which is kind of the

4506
01:38:01,459 --> 01:38:03,929
 

4507
01:38:01,469 --> 01:38:08,190
 resolution of my CPU timer so some you

4508
01:38:03,919 --> 01:38:08,190
 

4509
01:38:03,929 --> 01:38:09,960
 know some number of milliseconds now my

4510
01:38:08,180 --> 01:38:09,960
 

4511
01:38:08,190 --> 01:38:12,719
 goal here is going to be talking about

4512
01:38:09,950 --> 01:38:12,719
 

4513
01:38:09,960 --> 01:38:15,470
 how quickly I can find an optimal

4514
01:38:12,709 --> 01:38:15,470
 

4515
01:38:12,719 --> 01:38:17,510
 configuration except as is

4516
01:38:15,460 --> 01:38:17,510
 

4517
01:38:15,470 --> 01:38:19,430
 typically the case in these kinds of

4518
01:38:17,500 --> 01:38:19,430
 

4519
01:38:17,510 --> 01:38:21,800
 theoretical analyses it's going to be

4520
01:38:19,420 --> 01:38:21,800
 

4521
01:38:19,430 --> 01:38:25,580
 too demanding a criterion to ask for

4522
01:38:21,790 --> 01:38:25,580
 

4523
01:38:21,800 --> 01:38:27,260
 perfect optimality so I want to relax my

4524
01:38:25,570 --> 01:38:27,260
 

4525
01:38:25,580 --> 01:38:29,840
 optimality definition to epsilon

4526
01:38:27,250 --> 01:38:29,840
 

4527
01:38:27,260 --> 01:38:32,150
 optimality so given some epsilon greater

4528
01:38:29,830 --> 01:38:32,150
 

4529
01:38:29,840 --> 01:38:34,280
 than zero my goal is going to be fine

4530
01:38:32,140 --> 01:38:34,280
 

4531
01:38:32,150 --> 01:38:36,200
 finding some configuration theta star

4532
01:38:34,270 --> 01:38:36,200
 

4533
01:38:34,280 --> 01:38:39,070
 which gets within a 1 plus epsilon

4534
01:38:36,190 --> 01:38:39,070
 

4535
01:38:36,200 --> 01:38:41,620
 fraction of the optimal configuration

4536
01:38:39,060 --> 01:38:41,620
 

4537
01:38:39,070 --> 01:38:44,810
 except that also turns out to be

4538
01:38:41,610 --> 01:38:44,810
 

4539
01:38:41,620 --> 01:38:47,660
 impractical II hard to achieve in the

4540
01:38:44,800 --> 01:38:47,660
 

4541
01:38:44,810 --> 01:38:49,910
 worst case because if Thetas average

4542
01:38:47,650 --> 01:38:49,910
 

4543
01:38:47,660 --> 01:38:53,720
 running time is driven by a very small

4544
01:38:49,900 --> 01:38:53,720
 

4545
01:38:49,910 --> 01:38:56,900
 set of very very bad runs then I would

4546
01:38:53,710 --> 01:38:56,900
 

4547
01:38:53,720 --> 01:38:59,990
 need to run on very very many inputs to

4548
01:38:56,890 --> 01:38:59,990
 

4549
01:38:56,900 --> 01:39:03,050
 find this low probability tail event

4550
01:38:59,980 --> 01:39:03,050
 

4551
01:38:59,990 --> 01:39:04,880
 that is driving my average and and this

4552
01:39:03,040 --> 01:39:04,880
 

4553
01:39:03,050 --> 01:39:06,950
 would imply worst case bounds that would

4554
01:39:04,870 --> 01:39:06,950
 

4555
01:39:04,880 --> 01:39:09,860
 scale linearly with my maximum possible

4556
01:39:06,940 --> 01:39:09,860
 

4557
01:39:06,950 --> 01:39:12,140
 run time Kappa bar even if opt is very

4558
01:39:09,850 --> 01:39:12,140
 

4559
01:39:09,860 --> 01:39:14,990
 very much better than Kappa bar and

4560
01:39:12,130 --> 01:39:14,990
 

4561
01:39:12,140 --> 01:39:17,330
 that's essentially that's because things

4562
01:39:14,980 --> 01:39:17,330
 

4563
01:39:14,990 --> 01:39:18,770
 you know that look good they might not

4564
01:39:17,320 --> 01:39:18,770
 

4565
01:39:17,330 --> 01:39:20,270
 actually be good if there's some very

4566
01:39:18,760 --> 01:39:20,270
 

4567
01:39:18,770 --> 01:39:22,490
 very small chance of them being bad

4568
01:39:20,260 --> 01:39:22,490
 

4569
01:39:20,270 --> 01:39:23,930
 which in fact never arises but to rule

4570
01:39:22,480 --> 01:39:23,930
 

4571
01:39:22,490 --> 01:39:25,880
 it out I would have to do gigantic

4572
01:39:23,920 --> 01:39:25,880
 

4573
01:39:23,930 --> 01:39:28,340
 amounts of runs and so that's not very

4574
01:39:25,870 --> 01:39:28,340
 

4575
01:39:25,880 --> 01:39:30,140
 interesting so we're again winter

4576
01:39:28,330 --> 01:39:30,140
 

4577
01:39:28,340 --> 01:39:31,940
 relaxed our objectives so that we can

4578
01:39:30,130 --> 01:39:31,940
 

4579
01:39:30,140 --> 01:39:34,040
 say more interesting things at the

4580
01:39:31,930 --> 01:39:34,040
 

4581
01:39:31,940 --> 01:39:37,220
 expense of having clunkier notation so

4582
01:39:34,030 --> 01:39:37,220
 

4583
01:39:34,040 --> 01:39:39,440
 what I'm gonna end up with is epsilon

4584
01:39:37,210 --> 01:39:39,440
 

4585
01:39:37,220 --> 01:39:42,080
 Delta optimality so I'll say a

4586
01:39:39,430 --> 01:39:42,080
 

4587
01:39:39,440 --> 01:39:45,200
 configuration is epsilon Delta optimal

4588
01:39:42,070 --> 01:39:45,200
 

4589
01:39:42,080 --> 01:39:48,590
 if there exists some cap time Kappa for

4590
01:39:45,190 --> 01:39:48,590
 

4591
01:39:45,200 --> 01:39:51,020
 which that configuration theta star is

4592
01:39:48,580 --> 01:39:51,020
 

4593
01:39:48,590 --> 01:39:54,110
 within a 1 plus epsilon fraction of opt

4594
01:39:51,010 --> 01:39:54,110
 

4595
01:39:51,020 --> 01:39:57,830
 and furthermore the probability that it

4596
01:39:54,100 --> 01:39:57,830
 

4597
01:39:54,110 --> 01:40:00,560
 caps and that the run completes within

4598
01:39:57,820 --> 01:40:00,560
 

4599
01:39:57,830 --> 01:40:02,660
 cap time Kappa is less than or equal to

4600
01:40:00,550 --> 01:40:02,660
 

4601
01:40:00,560 --> 01:40:04,520
 forget a cap set Kappa is less than or

4602
01:40:02,650 --> 01:40:04,520
 

4603
01:40:02,660 --> 01:40:06,650
 equal to Delta so in other words I'm

4604
01:40:04,510 --> 01:40:06,650
 

4605
01:40:04,520 --> 01:40:08,930
 willing to throw out a delta fraction of

4606
01:40:06,640 --> 01:40:08,930
 

4607
01:40:06,650 --> 01:40:11,480
 runs because they might be out in the

4608
01:40:08,920 --> 01:40:11,480
 

4609
01:40:08,930 --> 01:40:13,250
 tail and that doesn't actually mean I

4610
01:40:11,470 --> 01:40:13,250
 

4611
01:40:11,480 --> 01:40:15,020
 necessarily really do throw them out it

4612
01:40:13,240 --> 01:40:15,020
 

4613
01:40:13,250 --> 01:40:16,250
 means I'm willing to consider that there

4614
01:40:15,010 --> 01:40:16,250
 

4615
01:40:15,020 --> 01:40:17,870
 might be other runs with this

4616
01:40:16,240 --> 01:40:17,870
 

4617
01:40:16,250 --> 01:40:21,140
 probability that I haven't even seen yet

4618
01:40:17,860 --> 01:40:21,140
 

4619
01:40:17,870 --> 01:40:22,640
 which could be very very bad and so if I

4620
01:40:21,130 --> 01:40:22,640
 

4621
01:40:21,140 --> 01:40:24,560
 meet that criterion I'll be epsilon

4622
01:40:22,630 --> 01:40:24,560
 

4623
01:40:22,640 --> 01:40:27,680
 Delta optimal that's the thing I'm gonna

4624
01:40:24,550 --> 01:40:27,680
 

4625
01:40:24,560 --> 01:40:29,330
 be looking for in this section now I'll

4626
01:40:27,670 --> 01:40:29,330
 

4627
01:40:27,680 --> 01:40:32,540
 say an algorithm configure a

4628
01:40:29,320 --> 01:40:32,540
 

4629
01:40:29,330 --> 01:40:35,240
 procedure is incumbent driven if every

4630
01:40:32,530 --> 01:40:35,240
 

4631
01:40:32,540 --> 01:40:38,210
 time it runs an algorithm it either caps

4632
01:40:35,230 --> 01:40:38,210
 

4633
01:40:35,240 --> 01:40:40,340
 at cap time Kappa bar or it caps an

4634
01:40:38,200 --> 01:40:40,340
 

4635
01:40:38,210 --> 01:40:43,700
 amount proportional to the run time of a

4636
01:40:40,330 --> 01:40:43,700
 

4637
01:40:40,340 --> 01:40:45,590
 previously performed run and may take a

4638
01:40:43,690 --> 01:40:45,590
 

4639
01:40:43,700 --> 01:40:47,630
 second to digest that but you'll notice

4640
01:40:45,580 --> 01:40:47,630
 

4641
01:40:45,590 --> 01:40:49,370
 that the adaptive capping schemes that

4642
01:40:47,620 --> 01:40:49,370
 

4643
01:40:47,630 --> 01:40:51,770
 Frank just spoke about have this

4644
01:40:49,360 --> 01:40:51,770
 

4645
01:40:49,370 --> 01:40:54,110
 property that either you you just run

4646
01:40:51,760 --> 01:40:54,110
 

4647
01:40:51,770 --> 01:40:55,940
 something until it completes you know

4648
01:40:54,100 --> 01:40:55,940
 

4649
01:40:54,110 --> 01:40:57,350
 kappa time kappa bar or you run

4650
01:40:55,930 --> 01:40:57,350
 

4651
01:40:55,940 --> 01:41:00,950
 something in proportion to how long a

4652
01:40:57,340 --> 01:41:00,950
 

4653
01:40:57,350 --> 01:41:05,020
 previous run took and the first theorem

4654
01:41:00,940 --> 01:41:05,020
 

4655
01:41:00,950 --> 01:41:07,400
 that we can show here is that any

4656
01:41:05,010 --> 01:41:07,400
 

4657
01:41:05,020 --> 01:41:09,260
 incumbent driven search procedure has

4658
01:41:07,390 --> 01:41:09,260
 

4659
01:41:07,400 --> 01:41:11,450
 worst-case expected runtime that scales

4660
01:41:09,250 --> 01:41:11,450
 

4661
01:41:09,260 --> 01:41:13,940
 at least linearly with kappa bar so

4662
01:41:11,440 --> 01:41:13,940
 

4663
01:41:11,450 --> 01:41:15,950
 we're not going to be able to get really

4664
01:41:13,930 --> 01:41:15,950
 

4665
01:41:13,940 --> 01:41:17,900
 good worst-case convergence by any

4666
01:41:15,940 --> 01:41:17,900
 

4667
01:41:15,950 --> 01:41:19,100
 incumbent driven procedure so we're

4668
01:41:17,890 --> 01:41:19,100
 

4669
01:41:17,900 --> 01:41:21,440
 gonna need something that works

4670
01:41:19,090 --> 01:41:21,440
 

4671
01:41:19,100 --> 01:41:23,720
 differently to get good worst-case

4672
01:41:21,430 --> 01:41:23,720
 

4673
01:41:21,440 --> 01:41:25,100
 guarantees from it and the stuff that

4674
01:41:23,710 --> 01:41:25,100
 

4675
01:41:23,720 --> 01:41:26,140
 Frank has told you about there works so

4676
01:41:25,090 --> 01:41:26,140
 

4677
01:41:25,100 --> 01:41:29,690
 well in practice

4678
01:41:26,130 --> 01:41:29,690
 

4679
01:41:26,140 --> 01:41:30,710
 so I'll begin so in this section I'm

4680
01:41:29,680 --> 01:41:30,710
 

4681
01:41:29,690 --> 01:41:31,820
 going to tell you about several

4682
01:41:30,700 --> 01:41:31,820
 

4683
01:41:30,710 --> 01:41:33,620
 different methods that have been

4684
01:41:31,810 --> 01:41:33,620
 

4685
01:41:31,820 --> 01:41:37,520
 proposed this has become quite an active

4686
01:41:33,610 --> 01:41:37,520
 

4687
01:41:33,620 --> 01:41:40,520
 area I'll start with the first one which

4688
01:41:37,510 --> 01:41:40,520
 

4689
01:41:37,520 --> 01:41:42,530
 is called structured procrastination it

4690
01:41:40,510 --> 01:41:42,530
 

4691
01:41:40,520 --> 01:41:44,630
 gets its name by a time management

4692
01:41:42,520 --> 01:41:44,630
 

4693
01:41:42,530 --> 01:41:47,420
 scheme which i think is quite charming

4694
01:41:44,620 --> 01:41:47,420
 

4695
01:41:44,630 --> 01:41:49,340
 due to a stanford philosopher and his

4696
01:41:47,410 --> 01:41:49,340
 

4697
01:41:47,420 --> 01:41:51,310
 idea it actually got the egg nobel prize

4698
01:41:49,330 --> 01:41:51,310
 

4699
01:41:49,340 --> 01:41:54,320
 in literature if you know what that is

4700
01:41:51,300 --> 01:41:54,320
 

4701
01:41:51,310 --> 01:41:56,150
 his idea is you can actually get things

4702
01:41:54,310 --> 01:41:56,150
 

4703
01:41:54,320 --> 01:41:58,400
 done by procrastinating so you keep

4704
01:41:56,140 --> 01:41:58,400
 

4705
01:41:56,150 --> 01:42:01,550
 around a set of daunting tasks like

4706
01:41:58,390 --> 01:42:01,550
 

4707
01:41:58,400 --> 01:42:04,370
 preparing an ICML tutorial which you're

4708
01:42:01,540 --> 01:42:04,370
 

4709
01:42:01,550 --> 01:42:06,440
 really horrified by having to do and so

4710
01:42:04,360 --> 01:42:06,440
 

4711
01:42:04,370 --> 01:42:07,850
 you keep procrastinating from this task

4712
01:42:06,430 --> 01:42:07,850
 

4713
01:42:06,440 --> 01:42:09,410
 some of you are nodding because you've

4714
01:42:07,840 --> 01:42:09,410
 

4715
01:42:07,850 --> 01:42:10,070
 given ICML tutorials and you know what

4716
01:42:09,400 --> 01:42:10,070
 

4717
01:42:09,410 --> 01:42:12,380
 i'm talking about

4718
01:42:10,060 --> 01:42:12,380
 

4719
01:42:10,070 --> 01:42:14,270
 and but the fact that you're

4720
01:42:12,370 --> 01:42:14,270
 

4721
01:42:12,380 --> 01:42:15,950
 procrastinating from this causes you to

4722
01:42:14,260 --> 01:42:15,950
 

4723
01:42:14,270 --> 01:42:17,450
 do other things that you actually need

4724
01:42:15,940 --> 01:42:17,450
 

4725
01:42:15,950 --> 01:42:18,860
 to do like reviewing the paper or

4726
01:42:17,440 --> 01:42:18,860
 

4727
01:42:17,450 --> 01:42:20,750
 meeting with your students or answering

4728
01:42:18,850 --> 01:42:20,750
 

4729
01:42:18,860 --> 01:42:23,450
 your email and so you can get various

4730
01:42:20,740 --> 01:42:23,450
 

4731
01:42:20,750 --> 01:42:25,460
 stuff done and eventually you replace

4732
01:42:23,440 --> 01:42:25,460
 

4733
01:42:23,450 --> 01:42:27,560
 every daunting task but a new task that

4734
01:42:25,450 --> 01:42:27,560
 

4735
01:42:25,460 --> 01:42:28,820
 is even more daunting there by getting

4736
01:42:27,550 --> 01:42:28,820
 

4737
01:42:27,560 --> 01:42:31,370
 the first task done first

4738
01:42:28,810 --> 01:42:31,370
 

4739
01:42:28,820 --> 01:42:33,230
 that's Perry's idea the structure

4740
01:42:31,360 --> 01:42:33,230
 

4741
01:42:31,370 --> 01:42:36,500
 procrastination algorithm configuration

4742
01:42:33,220 --> 01:42:36,500
 

4743
01:42:33,230 --> 01:42:38,750
 procedure has the similar philosophy so

4744
01:42:36,490 --> 01:42:38,750
 

4745
01:42:36,500 --> 01:42:42,150
 it maintains a set of tasks which are

4746
01:42:38,740 --> 01:42:42,150
 

4747
01:42:38,750 --> 01:42:44,820
 for a configuration running a queue of

4748
01:42:42,140 --> 01:42:44,820
 

4749
01:42:42,150 --> 01:42:46,500
 runs to perform we start with the

4750
01:42:44,810 --> 01:42:46,500
 

4751
01:42:44,820 --> 01:42:48,929
 easiest tasks which are those with the

4752
01:42:46,490 --> 01:42:48,929
 

4753
01:42:46,500 --> 01:42:52,440
 shortest cap times and when these tasks

4754
01:42:48,919 --> 01:42:52,440
 

4755
01:42:48,929 --> 01:42:54,989
 prove daunting we procrastinate by which

4756
01:42:52,430 --> 01:42:54,989
 

4757
01:42:52,440 --> 01:42:57,300
 we mean we put them back on the queue so

4758
01:42:54,979 --> 01:42:57,300
 

4759
01:42:54,989 --> 01:42:59,040
 the key inside of this algorithm is that

4760
01:42:57,290 --> 01:42:59,040
 

4761
01:42:57,300 --> 01:43:00,840
 we only spend a lot of time running a

4762
01:42:59,030 --> 01:43:00,840
 

4763
01:42:59,040 --> 01:43:02,909
 given configuration on a given instance

4764
01:43:00,830 --> 01:43:02,909
 

4765
01:43:00,840 --> 01:43:04,290
 after we've really convinced ourselves

4766
01:43:02,899 --> 01:43:04,290
 

4767
01:43:02,909 --> 01:43:06,449
 that there isn't some other

4768
01:43:04,280 --> 01:43:06,449
 

4769
01:43:04,290 --> 01:43:09,870
 configuration instance pair that we

4770
01:43:06,439 --> 01:43:09,870
 

4771
01:43:06,449 --> 01:43:12,090
 could have solved more quickly so let me

4772
01:43:09,860 --> 01:43:12,090
 

4773
01:43:09,870 --> 01:43:14,250
 begin by thinking about a world in which

4774
01:43:12,080 --> 01:43:14,250
 

4775
01:43:12,090 --> 01:43:16,909
 I have pretty few configurations there's

4776
01:43:14,240 --> 01:43:16,909
 

4777
01:43:14,250 --> 01:43:19,080
 some small finite set of configurations

4778
01:43:16,899 --> 01:43:19,080
 

4779
01:43:16,909 --> 01:43:21,210
 the way the algorithm works is I

4780
01:43:19,070 --> 01:43:21,210
 

4781
01:43:19,080 --> 01:43:23,370
 initialize a bounded length Q of

4782
01:43:21,200 --> 01:43:23,370
 

4783
01:43:21,210 --> 01:43:26,040
 instance cap time pairs for each

4784
01:43:23,360 --> 01:43:26,040
 

4785
01:43:23,370 --> 01:43:28,350
 configuration and I'm just gonna sample

4786
01:43:26,030 --> 01:43:28,350
 

4787
01:43:26,040 --> 01:43:30,570
 these randomly from the instance

4788
01:43:28,340 --> 01:43:30,570
 

4789
01:43:28,350 --> 01:43:32,610
 distribute the distribution D that you

4790
01:43:30,560 --> 01:43:32,610
 

4791
01:43:30,570 --> 01:43:34,469
 heard about before and for every one of

4792
01:43:32,600 --> 01:43:34,469
 

4793
01:43:32,610 --> 01:43:37,890
 them I'm gonna set an initial cap time

4794
01:43:34,459 --> 01:43:37,890
 

4795
01:43:34,469 --> 01:43:40,739
 of kappa naught then I'm gonna compute

4796
01:43:37,880 --> 01:43:40,739
 

4797
01:43:37,890 --> 01:43:42,960
 an approximate expected runtime for each

4798
01:43:40,729 --> 01:43:42,960
 

4799
01:43:40,739 --> 01:43:44,489
 configuration which is going to be zero

4800
01:43:42,950 --> 01:43:44,489
 

4801
01:43:42,960 --> 01:43:46,590
 for those configurations that have done

4802
01:43:44,479 --> 01:43:46,590
 

4803
01:43:44,489 --> 01:43:48,780
 no runs yet and it's going to be the

4804
01:43:46,580 --> 01:43:48,780
 

4805
01:43:46,590 --> 01:43:51,120
 average run times for every

4806
01:43:48,770 --> 01:43:51,120
 

4807
01:43:48,780 --> 01:43:53,340
 configuration that has done runs where

4808
01:43:51,110 --> 01:43:53,340
 

4809
01:43:51,120 --> 01:43:54,989
 in those averages if something capped

4810
01:43:53,330 --> 01:43:54,989
 

4811
01:43:53,340 --> 01:43:56,640
 out I'm just gonna treat the cap drum as

4812
01:43:54,979 --> 01:43:56,640
 

4813
01:43:54,989 --> 01:43:58,590
 though it finished so it's gonna be a

4814
01:43:56,630 --> 01:43:58,590
 

4815
01:43:56,640 --> 01:44:00,929
 lower bound on the runs that I've

4816
01:43:58,580 --> 01:44:00,929
 

4817
01:43:58,590 --> 01:44:02,550
 actually finished it's going to be an

4818
01:44:00,919 --> 01:44:02,550
 

4819
01:44:00,929 --> 01:44:06,090
 approximate average because the samples

4820
01:44:02,540 --> 01:44:06,090
 

4821
01:44:02,550 --> 01:44:07,920
 themselves are gonna be noisy then I'm

4822
01:44:06,080 --> 01:44:07,920
 

4823
01:44:06,090 --> 01:44:10,170
 gonna choose each time and do another

4824
01:44:07,910 --> 01:44:10,170
 

4825
01:44:07,920 --> 01:44:11,880
 run the task that I optimistically

4826
01:44:10,160 --> 01:44:11,880
 

4827
01:44:10,170 --> 01:44:14,219
 predict will be easiest which is the

4828
01:44:11,870 --> 01:44:14,219
 

4829
01:44:11,880 --> 01:44:16,679
 instant cap time pair at the head of the

4830
01:44:14,209 --> 01:44:16,679
 

4831
01:44:14,219 --> 01:44:19,170
 queue that corresponds to the theta that

4832
01:44:16,669 --> 01:44:19,170
 

4833
01:44:16,679 --> 01:44:23,010
 has the the smallest approximate

4834
01:44:19,160 --> 01:44:23,010
 

4835
01:44:19,170 --> 01:44:25,710
 expected runtime if this task doesn't

4836
01:44:23,000 --> 01:44:25,710
 

4837
01:44:23,010 --> 01:44:26,820
 finish within its cap time I'm just

4838
01:44:25,700 --> 01:44:26,820
 

4839
01:44:25,710 --> 01:44:28,890
 going to procrastinate so I'm gonna

4840
01:44:26,810 --> 01:44:28,890
 

4841
01:44:26,820 --> 01:44:31,440
 double its cap time and I'm gonna stick

4842
01:44:28,880 --> 01:44:31,440
 

4843
01:44:28,890 --> 01:44:33,360
 it on the very end of its queue and that

4844
01:44:31,430 --> 01:44:33,360
 

4845
01:44:31,440 --> 01:44:36,000
 means I'll do a lot of other runs I'll

4846
01:44:33,350 --> 01:44:36,000
 

4847
01:44:33,360 --> 01:44:37,320
 do ones every other run in it's Q plus

4848
01:44:35,990 --> 01:44:37,320
 

4849
01:44:36,000 --> 01:44:39,210
 maybe all kinds of other stuff from

4850
01:44:37,310 --> 01:44:39,210
 

4851
01:44:37,320 --> 01:44:40,380
 other queues before I'm ever gonna get

4852
01:44:39,200 --> 01:44:40,380
 

4853
01:44:39,210 --> 01:44:43,860
 back to that task so I'm gonna

4854
01:44:40,370 --> 01:44:43,860
 

4855
01:44:40,380 --> 01:44:45,510
 procrastinate for a long time and this

4856
01:44:43,850 --> 01:44:45,510
 

4857
01:44:43,860 --> 01:44:47,850
 is in any time algorithm so it runs

4858
01:44:45,500 --> 01:44:47,850
 

4859
01:44:45,510 --> 01:44:49,980
 until it's interrupted if it hasn't yet

4860
01:44:47,840 --> 01:44:49,980
 

4861
01:44:47,850 --> 01:44:52,139
 been interrupted I just go back up to

4862
01:44:49,970 --> 01:44:52,139
 

4863
01:44:49,980 --> 01:44:54,540
 two so I recompute these approximate

4864
01:44:52,129 --> 01:44:54,540
 

4865
01:44:52,139 --> 01:44:55,339
 expected run times for everybody and I

4866
01:44:54,530 --> 01:44:55,339
 

4867
01:44:54,540 --> 01:44:57,109
 keep doing that

4868
01:44:55,329 --> 01:44:57,109
 

4869
01:44:55,339 --> 01:44:59,749
 that looks easiest and I keep grinding

4870
01:44:57,099 --> 01:44:59,749
 

4871
01:44:57,109 --> 01:45:02,239
 through this list and in the end when I

4872
01:44:59,739 --> 01:45:02,239
 

4873
01:44:59,749 --> 01:45:05,599
 stop I'm gonna return the configuration

4874
01:45:02,229 --> 01:45:05,599
 

4875
01:45:02,239 --> 01:45:07,729
 that I spent the most time overall

4876
01:45:05,589 --> 01:45:07,729
 

4877
01:45:05,599 --> 01:45:09,260
 running now you might expect that I

4878
01:45:07,719 --> 01:45:09,260
 

4879
01:45:07,729 --> 01:45:10,939
 would return the configuration that has

4880
01:45:09,250 --> 01:45:10,939
 

4881
01:45:09,260 --> 01:45:12,530
 the best approximate expected runtime

4882
01:45:10,929 --> 01:45:12,530
 

4883
01:45:10,939 --> 01:45:15,050
 but that turns out not to be

4884
01:45:12,520 --> 01:45:15,050
 

4885
01:45:12,530 --> 01:45:17,030
 statistically stable because if that

4886
01:45:15,040 --> 01:45:17,030
 

4887
01:45:15,050 --> 01:45:19,309
 answer might switch just at the last

4888
01:45:17,020 --> 01:45:19,309
 

4889
01:45:17,030 --> 01:45:21,739
 minute before I before I've asked to

4890
01:45:19,299 --> 01:45:21,739
 

4891
01:45:19,309 --> 01:45:23,839
 return something so I know that I'll

4892
01:45:21,729 --> 01:45:23,839
 

4893
01:45:21,739 --> 01:45:25,579
 have stability if I return the thing

4894
01:45:23,829 --> 01:45:25,579
 

4895
01:45:23,839 --> 01:45:27,709
 that I ran the most and intuitively

4896
01:45:25,569 --> 01:45:27,709
 

4897
01:45:25,579 --> 01:45:29,329
 every time I make a choice about what to

4898
01:45:27,699 --> 01:45:29,329
 

4899
01:45:27,709 --> 01:45:31,280
 run I'm always running the thing that

4900
01:45:29,319 --> 01:45:31,280
 

4901
01:45:29,329 --> 01:45:33,499
 looks the best so the thing that manages

4902
01:45:31,270 --> 01:45:33,499
 

4903
01:45:31,280 --> 01:45:34,999
 to accumulate the most runs will be the

4904
01:45:33,489 --> 01:45:34,999
 

4905
01:45:33,499 --> 01:45:38,629
 thing that has looked the best most of

4906
01:45:34,989 --> 01:45:38,629
 

4907
01:45:34,999 --> 01:45:40,699
 the time so running this algorithm a

4908
01:45:38,619 --> 01:45:40,699
 

4909
01:45:38,629 --> 01:45:42,530
 user has to specify an algorithm

4910
01:45:40,689 --> 01:45:42,530
 

4911
01:45:40,699 --> 01:45:46,099
 configuration problem as defined before

4912
01:45:42,520 --> 01:45:46,099
 

4913
01:45:42,530 --> 01:45:48,079
 a precision epsilon that says how big a

4914
01:45:46,089 --> 01:45:48,079
 

4915
01:45:46,099 --> 01:45:49,789
 difference in objective function value

4916
01:45:48,069 --> 01:45:49,789
 

4917
01:45:48,079 --> 01:45:52,129
 do I care about and a failure

4918
01:45:49,779 --> 01:45:52,129
 

4919
01:45:49,789 --> 01:45:53,749
 probability which is the probability I'm

4920
01:45:52,119 --> 01:45:53,749
 

4921
01:45:52,129 --> 01:45:56,119
 going to allow my guarantees to fail to

4922
01:45:53,739 --> 01:45:56,119
 

4923
01:45:53,749 --> 01:45:57,889
 hold and the user doesn't have to

4924
01:45:56,109 --> 01:45:57,889
 

4925
01:45:56,119 --> 01:45:59,389
 specify this Delta that I told you about

4926
01:45:57,879 --> 01:45:59,389
 

4927
01:45:57,889 --> 01:46:03,319
 before which is how much of the tail

4928
01:45:59,379 --> 01:46:03,319
 

4929
01:45:59,389 --> 01:46:04,999
 probability I can discount instead it's

4930
01:46:03,309 --> 01:46:04,999
 

4931
01:46:03,319 --> 01:46:07,189
 just gonna gradually get better as the

4932
01:46:04,989 --> 01:46:07,189
 

4933
01:46:04,999 --> 01:46:09,260
 algorithm runs so when the algorithm is

4934
01:46:07,179 --> 01:46:09,260
 

4935
01:46:07,189 --> 01:46:11,449
 stopped it's going to tell me the Delta

4936
01:46:09,250 --> 01:46:11,449
 

4937
01:46:09,260 --> 01:46:14,079
 for which it has guaranteed to find an

4938
01:46:11,439 --> 01:46:14,079
 

4939
01:46:11,449 --> 01:46:16,959
 epsilon Delta optimal configuration and

4940
01:46:14,069 --> 01:46:16,959
 

4941
01:46:14,079 --> 01:46:19,309
 here's the the key theorem of this work

4942
01:46:16,949 --> 01:46:19,309
 

4943
01:46:16,959 --> 01:46:21,409
 for any Delta greater than zero

4944
01:46:19,299 --> 01:46:21,409
 

4945
01:46:19,309 --> 01:46:23,449
 an execution of the structural

4946
01:46:21,399 --> 01:46:23,449
 

4947
01:46:21,409 --> 01:46:25,760
 procrastination algorithm identifies an

4948
01:46:23,439 --> 01:46:25,760
 

4949
01:46:23,449 --> 01:46:28,429
 epsilon Delta optimal configuration with

4950
01:46:25,750 --> 01:46:28,429
 

4951
01:46:25,760 --> 01:46:30,229
 probability at least 1 minus Zeta within

4952
01:46:28,419 --> 01:46:30,229
 

4953
01:46:28,429 --> 01:46:33,499
 worst case expected time that looks like

4954
01:46:30,219 --> 01:46:33,499
 

4955
01:46:30,229 --> 01:46:37,399
 this horrible thing here so so that's

4956
01:46:33,489 --> 01:46:37,399
 

4957
01:46:33,499 --> 01:46:39,739
 exciting and because it remembered

4958
01:46:37,389 --> 01:46:39,739
 

4959
01:46:37,399 --> 01:46:41,959
 before that I said when we looked at

4960
01:46:39,729 --> 01:46:41,959
 

4961
01:46:39,739 --> 01:46:45,429
 incumbent based procedures they were

4962
01:46:41,949 --> 01:46:45,429
 

4963
01:46:41,959 --> 01:46:48,289
 going to be linear in Kappa bar here

4964
01:46:45,419 --> 01:46:48,289
 

4965
01:46:45,429 --> 01:46:50,359
 instead you can see we're doubling

4966
01:46:48,279 --> 01:46:50,359
 

4967
01:46:48,289 --> 01:46:53,809
 logarithmic in Kappa bar so we get a

4968
01:46:50,349 --> 01:46:53,809
 

4969
01:46:50,359 --> 01:46:55,129
 separation from these incumbent driven

4970
01:46:53,799 --> 01:46:55,129
 

4971
01:46:53,809 --> 01:46:56,689
 procedures we can do really

4972
01:46:55,119 --> 01:46:56,689
 

4973
01:46:55,129 --> 01:46:59,569
 asymptotically much better than

4974
01:46:56,679 --> 01:46:59,569
 

4975
01:46:56,689 --> 01:47:02,030
 incumbent driven procedures furthermore

4976
01:46:59,559 --> 01:47:02,030
 

4977
01:46:59,569 --> 01:47:05,149
 we can get an information theoretic

4978
01:47:02,020 --> 01:47:05,149
 

4979
01:47:02,030 --> 01:47:07,180
 lower bound on how long any run would

4980
01:47:05,139 --> 01:47:07,180
 

4981
01:47:05,149 --> 01:47:10,540
 need to take if

4982
01:47:07,170 --> 01:47:10,540
 

4983
01:47:07,180 --> 01:47:12,160
 I wanted to find an epsilon Delta

4984
01:47:10,530 --> 01:47:12,160
 

4985
01:47:10,540 --> 01:47:15,400
 optimal configuration with probability

4986
01:47:12,150 --> 01:47:15,400
 

4987
01:47:12,160 --> 01:47:17,530
 at least 1/2 so that such a procedure

4988
01:47:15,390 --> 01:47:17,530
 

4989
01:47:15,400 --> 01:47:21,220
 would would need to take time at least n

4990
01:47:17,520 --> 01:47:21,220
 

4991
01:47:17,530 --> 01:47:23,500
 over delta epsilon squared opt so we

4992
01:47:21,210 --> 01:47:23,500
 

4993
01:47:21,220 --> 01:47:25,750
 only differ by this logarithmic term

4994
01:47:23,490 --> 01:47:25,750
 

4995
01:47:23,500 --> 01:47:27,940
 from this lower bound of what's possible

4996
01:47:25,740 --> 01:47:27,940
 

4997
01:47:25,750 --> 01:47:29,470
 so so that's the sense in which I say

4998
01:47:27,930 --> 01:47:29,470
 

4999
01:47:27,940 --> 01:47:32,500
 the structure procrastination is

5000
01:47:29,460 --> 01:47:32,500
 

5001
01:47:29,470 --> 01:47:36,190
 approximately as approximately the best

5002
01:47:32,490 --> 01:47:36,190
 

5003
01:47:32,500 --> 01:47:37,510
 running time we could want now if we

5004
01:47:36,180 --> 01:47:37,510
 

5005
01:47:36,190 --> 01:47:38,830
 want to think about the kinds of

5006
01:47:37,500 --> 01:47:38,830
 

5007
01:47:37,510 --> 01:47:40,810
 settings that Frank has been talking

5008
01:47:38,820 --> 01:47:40,810
 

5009
01:47:38,830 --> 01:47:42,940
 about or that I talked about in the

5010
01:47:40,800 --> 01:47:42,940
 

5011
01:47:40,810 --> 01:47:44,920
 first section where we have gigantic

5012
01:47:42,930 --> 01:47:44,920
 

5013
01:47:42,940 --> 01:47:47,260
 parameter spaces you know you might

5014
01:47:44,910 --> 01:47:47,260
 

5015
01:47:44,920 --> 01:47:50,590
 worry that the this design that I had

5016
01:47:47,250 --> 01:47:50,590
 

5017
01:47:47,260 --> 01:47:52,060
 before where we have I'm iterating over

5018
01:47:50,580 --> 01:47:52,060
 

5019
01:47:50,590 --> 01:47:55,840
 every configuration is going to be

5020
01:47:52,050 --> 01:47:55,840
 

5021
01:47:52,060 --> 01:47:58,300
 pretty limited and indeed it is so we

5022
01:47:55,830 --> 01:47:58,300
 

5023
01:47:55,840 --> 01:47:59,710
 can do something you know we can't

5024
01:47:58,290 --> 01:47:59,710
 

5025
01:47:58,300 --> 01:48:00,940
 completely break the back of that kind

5026
01:47:59,700 --> 01:48:00,940
 

5027
01:47:59,710 --> 01:48:02,620
 of problem because of course the very

5028
01:48:00,930 --> 01:48:02,620
 

5029
01:48:00,940 --> 01:48:04,210
 best thing can be arbitrarily hard to

5030
01:48:02,610 --> 01:48:04,210
 

5031
01:48:02,620 --> 01:48:05,980
 find in the space and there's there's

5032
01:48:04,200 --> 01:48:05,980
 

5033
01:48:04,210 --> 01:48:10,390
 kind of no way of sidestepping that

5034
01:48:05,970 --> 01:48:10,390
 

5035
01:48:05,980 --> 01:48:11,860
 problem but what we can do is relax the

5036
01:48:10,380 --> 01:48:11,860
 

5037
01:48:10,390 --> 01:48:13,750
 requirement that we find performance

5038
01:48:11,850 --> 01:48:13,750
 

5039
01:48:11,860 --> 01:48:15,220
 close to that of opt because opt might

5040
01:48:13,740 --> 01:48:15,220
 

5041
01:48:13,750 --> 01:48:18,190
 be a needle in the haystack that's too

5042
01:48:15,210 --> 01:48:18,190
 

5043
01:48:15,220 --> 01:48:19,660
 hard to find and instead say I want to

5044
01:48:18,180 --> 01:48:19,660
 

5045
01:48:18,190 --> 01:48:22,630
 find a configuration within the

5046
01:48:19,650 --> 01:48:22,630
 

5047
01:48:19,660 --> 01:48:24,870
 top-performing 1 over gamma quantile of

5048
01:48:22,620 --> 01:48:24,870
 

5049
01:48:22,630 --> 01:48:27,940
 solutions so I can have some parameter

5050
01:48:24,860 --> 01:48:27,940
 

5051
01:48:24,870 --> 01:48:29,530
 gamma that says you know how small a

5052
01:48:27,930 --> 01:48:29,530
 

5053
01:48:27,940 --> 01:48:31,360
 needle do I need to look for in my

5054
01:48:29,520 --> 01:48:31,360
 

5055
01:48:29,530 --> 01:48:33,760
 haystack and let me find something

5056
01:48:31,350 --> 01:48:33,760
 

5057
01:48:31,360 --> 01:48:36,610
 that's at least as good as something in

5058
01:48:33,750 --> 01:48:36,610
 

5059
01:48:33,760 --> 01:48:39,760
 the best 1 over gamma quantile I can

5060
01:48:36,600 --> 01:48:39,760
 

5061
01:48:36,610 --> 01:48:42,730
 appropriately define my epsilon Delta

5062
01:48:39,750 --> 01:48:42,730
 

5063
01:48:39,760 --> 01:48:44,620
 and gamma optimality to to refer to this

5064
01:48:42,720 --> 01:48:44,620
 

5065
01:48:42,730 --> 01:48:47,620
 kind of top quantile notion of

5066
01:48:44,610 --> 01:48:47,620
 

5067
01:48:44,620 --> 01:48:49,120
 optimality and then I can pretty

5068
01:48:47,610 --> 01:48:49,120
 

5069
01:48:47,620 --> 01:48:51,310
 straightforwardly extend structure

5070
01:48:49,110 --> 01:48:51,310
 

5071
01:48:49,120 --> 01:48:53,950
 procrastination to seek the best among a

5072
01:48:51,300 --> 01:48:53,950
 

5073
01:48:51,310 --> 01:48:56,410
 sample of one over gamma configurations

5074
01:48:53,940 --> 01:48:56,410
 

5075
01:48:53,950 --> 01:48:59,020
 now in a sense that's just a change of

5076
01:48:56,400 --> 01:48:59,020
 

5077
01:48:56,410 --> 01:49:00,490
 notation where I'm just now justifying

5078
01:48:59,010 --> 01:49:00,490
 

5079
01:48:59,020 --> 01:49:02,440
 for you why I took the set of random

5080
01:49:00,480 --> 01:49:02,440
 

5081
01:49:00,490 --> 01:49:03,880
 samples that I took but what's

5082
01:49:02,430 --> 01:49:03,880
 

5083
01:49:02,440 --> 01:49:06,040
 interesting about this is because the

5084
01:49:03,870 --> 01:49:06,040
 

5085
01:49:03,880 --> 01:49:08,620
 algorithm is any time I can gradually

5086
01:49:06,030 --> 01:49:08,620
 

5087
01:49:06,040 --> 01:49:11,410
 make my sieve tighter and tighter and be

5088
01:49:08,610 --> 01:49:11,410
 

5089
01:49:08,620 --> 01:49:13,840
 looking for finer and finer needles

5090
01:49:11,400 --> 01:49:13,840
 

5091
01:49:11,410 --> 01:49:17,350
 looking for more and more gammas as I go

5092
01:49:13,830 --> 01:49:17,350
 

5093
01:49:13,840 --> 01:49:25,150
 along and I can do this

5094
01:49:17,340 --> 01:49:25,150
 

5095
01:49:17,350 --> 01:49:28,470
 yes now I can't hear you so nobody else

5096
01:49:25,140 --> 01:49:28,470
 

5097
01:49:25,150 --> 01:49:31,480
 can hear you either okay

5098
01:49:28,460 --> 01:49:31,480
 

5099
01:49:28,470 --> 01:49:33,520
 and and so now I'm any time both in

5100
01:49:31,470 --> 01:49:33,520
 

5101
01:49:31,480 --> 01:49:35,440
 Delta and gamma and I have to have some

5102
01:49:33,510 --> 01:49:35,440
 

5103
01:49:33,520 --> 01:49:36,750
 kind of trade-off parameter that tells

5104
01:49:35,430 --> 01:49:36,750
 

5105
01:49:35,440 --> 01:49:39,220
 me how to trade these things off

5106
01:49:36,740 --> 01:49:39,220
 

5107
01:49:36,750 --> 01:49:41,290
 basically I get back the same theorem I

5108
01:49:39,210 --> 01:49:41,290
 

5109
01:49:39,220 --> 01:49:42,700
 can also get back a similar information

5110
01:49:41,280 --> 01:49:42,700
 

5111
01:49:41,290 --> 01:49:43,990
 theoretic lower bound so you know

5112
01:49:42,690 --> 01:49:43,990
 

5113
01:49:42,700 --> 01:49:46,750
 everything goes through pretty much as

5114
01:49:43,980 --> 01:49:46,750
 

5115
01:49:43,990 --> 01:49:47,980
 it did before two more kind of quick

5116
01:49:46,740 --> 01:49:47,980
 

5117
01:49:46,750 --> 01:49:50,620
 theorems that are worth pointing out

5118
01:49:47,970 --> 01:49:50,620
 

5119
01:49:47,980 --> 01:49:51,880
 about this algorithm one is let's say I

5120
01:49:50,610 --> 01:49:51,880
 

5121
01:49:50,620 --> 01:49:53,620
 wanted to marry structure

5122
01:49:51,870 --> 01:49:53,620
 

5123
01:49:51,880 --> 01:49:55,570
 procrastination with something like

5124
01:49:53,610 --> 01:49:55,570
 

5125
01:49:53,620 --> 01:49:57,970
 smack that uses Bayesian optimization

5126
01:49:55,560 --> 01:49:57,970
 

5127
01:49:55,570 --> 01:49:59,320
 that learns a model and tries to direct

5128
01:49:57,960 --> 01:49:59,320
 

5129
01:49:57,970 --> 01:50:02,350
 itself towards samples that work

5130
01:49:59,310 --> 01:50:02,350
 

5131
01:49:59,320 --> 01:50:03,940
 particularly well well if half the

5132
01:50:02,340 --> 01:50:03,940
 

5133
01:50:02,350 --> 01:50:06,130
 configuration sample the structural

5134
01:50:03,930 --> 01:50:06,130
 

5135
01:50:03,940 --> 01:50:07,960
 procrastination are generated in a way

5136
01:50:06,120 --> 01:50:07,960
 

5137
01:50:06,130 --> 01:50:10,000
 that depends arbitrarily on past

5138
01:50:07,950 --> 01:50:10,000
 

5139
01:50:07,960 --> 01:50:13,180
 observations such as a model like Frank

5140
01:50:09,990 --> 01:50:13,180
 

5141
01:50:10,000 --> 01:50:15,370
 used it's gonna hurt my worst case

5142
01:50:13,170 --> 01:50:15,370
 

5143
01:50:13,180 --> 01:50:16,960
 runtime only by a constant factor so it

5144
01:50:15,360 --> 01:50:16,960
 

5145
01:50:15,370 --> 01:50:20,230
 isn't gonna get me into trouble that I'm

5146
01:50:16,950 --> 01:50:20,230
 

5147
01:50:16,960 --> 01:50:22,030
 history dependent when Frank and finally

5148
01:50:20,220 --> 01:50:22,030
 

5149
01:50:20,230 --> 01:50:25,600
 I get linear speed ups when

5150
01:50:22,020 --> 01:50:25,600
 

5151
01:50:22,030 --> 01:50:27,760
 parallelizing okay so much for

5152
01:50:25,590 --> 01:50:27,760
 

5153
01:50:25,600 --> 01:50:29,800
 structured procrastination I made the

5154
01:50:27,750 --> 01:50:29,800
 

5155
01:50:27,760 --> 01:50:32,080
 mistake of giving a talk about structure

5156
01:50:29,790 --> 01:50:32,080
 

5157
01:50:29,800 --> 01:50:33,580
 procrastination a deep mind and any of

5158
01:50:32,070 --> 01:50:33,580
 

5159
01:50:32,080 --> 01:50:35,770
 you who work a deep mind or have

5160
01:50:33,570 --> 01:50:35,770
 

5161
01:50:33,580 --> 01:50:37,840
 interacted with such people know that

5162
01:50:35,760 --> 01:50:37,840
 

5163
01:50:35,770 --> 01:50:40,360
 six months later a paper improving on my

5164
01:50:37,830 --> 01:50:40,360
 

5165
01:50:37,840 --> 01:50:44,140
 method was posted on archive and so let

5166
01:50:40,350 --> 01:50:44,140
 

5167
01:50:40,360 --> 01:50:46,920
 me tell you about that paper so really

5168
01:50:44,130 --> 01:50:46,920
 

5169
01:50:44,140 --> 01:50:49,300
 quite nice work by whites at all

5170
01:50:46,910 --> 01:50:49,300
 

5171
01:50:46,920 --> 01:50:50,770
 improved on structured procrastinations

5172
01:50:49,290 --> 01:50:50,770
 

5173
01:50:49,300 --> 01:50:53,410
 worst case performance by a very

5174
01:50:50,760 --> 01:50:53,410
 

5175
01:50:50,770 --> 01:50:55,240
 different algorithm it removed

5176
01:50:53,400 --> 01:50:55,240
 

5177
01:50:53,410 --> 01:50:57,760
 dependence on Kappa bars so they're able

5178
01:50:55,230 --> 01:50:57,760
 

5179
01:50:55,240 --> 01:50:59,230
 to have dependence instead on opt which

5180
01:50:57,750 --> 01:50:59,230
 

5181
01:50:57,760 --> 01:51:01,750
 is very nice because capital bar is a

5182
01:50:59,220 --> 01:51:01,750
 

5183
01:50:59,230 --> 01:51:03,280
 very unnatural parameter and while they

5184
01:51:01,740 --> 01:51:03,280
 

5185
01:51:01,750 --> 01:51:04,900
 were at it they tightened our worst case

5186
01:51:03,270 --> 01:51:04,900
 

5187
01:51:03,280 --> 01:51:07,960
 performance by a log factor because

5188
01:51:04,890 --> 01:51:07,960
 

5189
01:51:04,900 --> 01:51:10,570
 that's just what they do and empirically

5190
01:51:07,950 --> 01:51:10,570
 

5191
01:51:07,960 --> 01:51:12,610
 their method they showed in very limited

5192
01:51:10,560 --> 01:51:12,610
 

5193
01:51:10,570 --> 01:51:14,440
 experiments that they empirically

5194
01:51:12,600 --> 01:51:14,440
 

5195
01:51:12,610 --> 01:51:15,940
 outperformed structure procrastination I

5196
01:51:14,430 --> 01:51:15,940
 

5197
01:51:14,440 --> 01:51:17,470
 have no reason to think that these

5198
01:51:15,930 --> 01:51:17,470
 

5199
01:51:15,940 --> 01:51:19,000
 experiments wouldn't generalize more

5200
01:51:17,460 --> 01:51:19,000
 

5201
01:51:17,470 --> 01:51:20,650
 broadly because structural

5202
01:51:18,990 --> 01:51:20,650
 

5203
01:51:19,000 --> 01:51:22,240
 procrastination was really meant to be a

5204
01:51:20,640 --> 01:51:22,240
 

5205
01:51:20,650 --> 01:51:24,760
 kind of thought experiment about how to

5206
01:51:22,230 --> 01:51:24,760
 

5207
01:51:22,240 --> 01:51:26,080
 be optimal in this space and for reasons

5208
01:51:24,750 --> 01:51:26,080
 

5209
01:51:24,760 --> 01:51:29,230
 I'll discuss a bit later it's just

5210
01:51:26,070 --> 01:51:29,230
 

5211
01:51:26,080 --> 01:51:30,730
 terrible in the average case but leaps

5212
01:51:29,220 --> 01:51:30,730
 

5213
01:51:29,230 --> 01:51:32,500
 and bounds is not anytime

5214
01:51:30,720 --> 01:51:32,500
 

5215
01:51:30,730 --> 01:51:35,110
 requires both epsilon and Delta as

5216
01:51:32,490 --> 01:51:35,110
 

5217
01:51:32,500 --> 01:51:36,100
 inputs and just terminates after it

5218
01:51:35,100 --> 01:51:36,100
 

5219
01:51:35,110 --> 01:51:39,190
 proves optimality

5220
01:51:36,090 --> 01:51:39,190
 

5221
01:51:36,100 --> 01:51:41,380
 so the algorithm at a glance tries to

5222
01:51:39,180 --> 01:51:41,380
 

5223
01:51:39,190 --> 01:51:44,110
 guess an initially low value of what opt

5224
01:51:41,370 --> 01:51:44,110
 

5225
01:51:41,380 --> 01:51:45,910
 might be then it looks across all the

5226
01:51:44,100 --> 01:51:45,910
 

5227
01:51:44,110 --> 01:51:47,530
 configurations to see if it can find one

5228
01:51:45,900 --> 01:51:47,530
 

5229
01:51:45,910 --> 01:51:50,080
 whose mean is smaller than this guess

5230
01:51:47,520 --> 01:51:50,080
 

5231
01:51:47,530 --> 01:51:51,700
 and if it can't find one it doubles the

5232
01:51:50,070 --> 01:51:51,700
 

5233
01:51:50,080 --> 01:51:53,800
 guess and repeats so it has the same

5234
01:51:51,690 --> 01:51:53,800
 

5235
01:51:51,700 --> 01:51:54,880
 flavor of doing really aggressive

5236
01:51:53,790 --> 01:51:54,880
 

5237
01:51:53,800 --> 01:51:58,420
 capping and working its way up

5238
01:51:54,870 --> 01:51:58,420
 

5239
01:51:54,880 --> 01:51:59,950
 exponentially but it has two ways when

5240
01:51:58,410 --> 01:51:59,950
 

5241
01:51:58,420 --> 01:52:01,270
 it's checking the configurations to see

5242
01:51:59,940 --> 01:52:01,270
 

5243
01:51:59,950 --> 01:52:03,460
 whether their means are smaller than the

5244
01:52:01,260 --> 01:52:03,460
 

5245
01:52:01,270 --> 01:52:05,200
 guess it does two clever things that we

5246
01:52:03,450 --> 01:52:05,200
 

5247
01:52:03,460 --> 01:52:06,700
 don't do that allow it to adapt to

5248
01:52:05,190 --> 01:52:06,700
 

5249
01:52:05,200 --> 01:52:09,340
 problems that are easier than the

5250
01:52:06,690 --> 01:52:09,340
 

5251
01:52:06,700 --> 01:52:11,830
 worst-case the first is they discard

5252
01:52:09,330 --> 01:52:11,830
 

5253
01:52:09,340 --> 01:52:13,420
 configurations whose mean is really big

5254
01:52:11,820 --> 01:52:13,420
 

5255
01:52:11,830 --> 01:52:15,070
 relative to the current gas so they

5256
01:52:13,410 --> 01:52:15,070
 

5257
01:52:13,420 --> 01:52:18,100
 don't do tons and tons of runs on bad

5258
01:52:15,060 --> 01:52:18,100
 

5259
01:52:15,070 --> 01:52:20,110
 configurations as we do and secondly

5260
01:52:18,090 --> 01:52:20,110
 

5261
01:52:18,100 --> 01:52:22,540
 they use fewer samples to estimate mean

5262
01:52:20,100 --> 01:52:22,540
 

5263
01:52:20,110 --> 01:52:24,070
 runtime on configurations that have low

5264
01:52:22,530 --> 01:52:24,070
 

5265
01:52:22,540 --> 01:52:25,900
 runtime variants across instances

5266
01:52:24,060 --> 01:52:25,900
 

5267
01:52:24,070 --> 01:52:30,370
 because they concentrate faster with low

5268
01:52:25,890 --> 01:52:30,370
 

5269
01:52:25,900 --> 01:52:32,410
 variance so the worst-case bounds that

5270
01:52:30,360 --> 01:52:32,410
 

5271
01:52:30,370 --> 01:52:35,410
 they get look like this so there they

5272
01:52:32,400 --> 01:52:35,410
 

5273
01:52:32,410 --> 01:52:38,380
 still have this logarithmic term but

5274
01:52:35,400 --> 01:52:38,380
 

5275
01:52:35,410 --> 01:52:40,080
 instead of being but it's better in a

5276
01:52:38,370 --> 01:52:40,080
 

5277
01:52:38,380 --> 01:52:42,880
 couple of ways so they get rid of the

5278
01:52:40,070 --> 01:52:42,880
 

5279
01:52:40,080 --> 01:52:44,830
 Delta epsilon squared in the denominator

5280
01:52:42,870 --> 01:52:44,830
 

5281
01:52:42,880 --> 01:52:47,500
 of the fraction and in the numerator

5282
01:52:44,820 --> 01:52:47,500
 

5283
01:52:44,830 --> 01:52:50,700
 they changed from our Kappa bar into opt

5284
01:52:47,490 --> 01:52:50,700
 

5285
01:52:47,500 --> 01:52:54,670
 which is much better so there we go and

5286
01:52:50,690 --> 01:52:54,670
 

5287
01:52:50,700 --> 01:52:57,430
 they did empirical experiments on once

5288
01:52:54,660 --> 01:52:57,430
 

5289
01:52:54,670 --> 01:53:00,040
 at domain and one randomized

5290
01:52:57,420 --> 01:53:00,040
 

5291
01:52:57,430 --> 01:53:02,710
 distribution of sat problems and so they

5292
01:53:00,030 --> 01:53:02,710
 

5293
01:53:00,040 --> 01:53:05,050
 tried to prove epsilon equals point two

5294
01:53:02,700 --> 01:53:05,050
 

5295
01:53:02,710 --> 01:53:07,060
 Delta equals point two optimality and

5296
01:53:05,040 --> 01:53:07,060
 

5297
01:53:05,050 --> 01:53:11,050
 they find on this particular problem

5298
01:53:07,050 --> 01:53:11,050
 

5299
01:53:07,060 --> 01:53:13,450
 that had 972 configurations 20,000 sat

5300
01:53:11,040 --> 01:53:13,450
 

5301
01:53:11,050 --> 01:53:19,060
 problems structured procrastination took

5302
01:53:13,440 --> 01:53:19,060
 

5303
01:53:13,450 --> 01:53:23,680
 a apalling 1170 CPU days to run and they

5304
01:53:19,050 --> 01:53:23,680
 

5305
01:53:19,060 --> 01:53:27,070
 took a much more manageable 369 CPU days

5306
01:53:23,670 --> 01:53:27,070
 

5307
01:53:23,680 --> 01:53:29,140
 just as just a hair over a CPU year to

5308
01:53:27,060 --> 01:53:29,140
 

5309
01:53:27,070 --> 01:53:31,450
 prove the same thing and if you look

5310
01:53:29,130 --> 01:53:31,450
 

5311
01:53:29,140 --> 01:53:32,680
 across configurations and how long how

5312
01:53:31,440 --> 01:53:32,680
 

5313
01:53:31,450 --> 01:53:35,530
 much time was spent on each

5314
01:53:32,670 --> 01:53:35,530
 

5315
01:53:32,680 --> 01:53:37,030
 configuration by the two methods they

5316
01:53:35,520 --> 01:53:37,030
 

5317
01:53:35,530 --> 01:53:40,150
 give this graph in their paper so you

5318
01:53:37,020 --> 01:53:40,150
 

5319
01:53:37,030 --> 01:53:43,280
 can see they're spending very much less

5320
01:53:40,140 --> 01:53:43,280
 

5321
01:53:40,150 --> 01:53:45,900
 time on the easiest configurations

5322
01:53:43,270 --> 01:53:45,900
 

5323
01:53:43,280 --> 01:53:47,690
 and then on some of them there they get

5324
01:53:45,890 --> 01:53:47,690
 

5325
01:53:45,900 --> 01:53:49,830
 closer to the amount they were spending

5326
01:53:47,680 --> 01:53:49,830
 

5327
01:53:47,690 --> 01:53:51,840
 but that wasn't enough for them they

5328
01:53:49,820 --> 01:53:51,840
 

5329
01:53:49,830 --> 01:53:53,340
 have another paper which as a matter of

5330
01:53:51,830 --> 01:53:53,340
 

5331
01:53:51,840 --> 01:53:58,230
 fact is going to be presented at this

5332
01:53:53,330 --> 01:53:58,230
 

5333
01:53:53,340 --> 01:54:00,810
 ICML to this Tuesday at 4:20 in room 103

5334
01:53:58,220 --> 01:54:00,810
 

5335
01:53:58,230 --> 01:54:02,160
 so I encourage you to go and and hear

5336
01:54:00,800 --> 01:54:02,160
 

5337
01:54:00,810 --> 01:54:04,950
 them talk about it for five minutes

5338
01:54:02,150 --> 01:54:04,950
 

5339
01:54:02,160 --> 01:54:06,900
 between 4:20 and 425 and maybe go to

5340
01:54:04,940 --> 01:54:06,900
 

5341
01:54:04,950 --> 01:54:08,460
 that poster afterwards so this is

5342
01:54:06,890 --> 01:54:08,460
 

5343
01:54:06,900 --> 01:54:11,070
 another algorithm called caps and runs

5344
01:54:08,450 --> 01:54:11,070
 

5345
01:54:08,460 --> 01:54:12,450
 and it adapts to easy problem instances

5346
01:54:11,060 --> 01:54:12,450
 

5347
01:54:11,070 --> 01:54:14,640
 which is something that leaps and bounds

5348
01:54:12,440 --> 01:54:14,640
 

5349
01:54:12,450 --> 01:54:16,680
 doesn't do so leaps and bounds is able

5350
01:54:14,630 --> 01:54:16,680
 

5351
01:54:14,640 --> 01:54:18,330
 to say that an algorithms runtime is

5352
01:54:16,670 --> 01:54:18,330
 

5353
01:54:16,680 --> 01:54:20,220
 much worse than than the guests that it

5354
01:54:18,320 --> 01:54:20,220
 

5355
01:54:18,330 --> 01:54:21,810
 was comparing to but it doesn't have a

5356
01:54:20,210 --> 01:54:21,810
 

5357
01:54:20,220 --> 01:54:23,370
 way of saying that I have two

5358
01:54:21,800 --> 01:54:23,370
 

5359
01:54:21,810 --> 01:54:24,810
 configurations and one of them is very

5360
01:54:23,360 --> 01:54:24,810
 

5361
01:54:23,370 --> 01:54:27,060
 much better than another which is what I

5362
01:54:24,800 --> 01:54:27,060
 

5363
01:54:24,810 --> 01:54:28,220
 would really want to do so they now have

5364
01:54:27,050 --> 01:54:28,220
 

5365
01:54:27,060 --> 01:54:31,200
 a way of doing that kind of adaptation

5366
01:54:28,210 --> 01:54:31,200
 

5367
01:54:28,220 --> 01:54:32,970
 they also have an improved bound for non

5368
01:54:31,190 --> 01:54:32,970
 

5369
01:54:31,200 --> 01:54:34,860
 worst case instances I'm not going to

5370
01:54:32,960 --> 01:54:34,860
 

5371
01:54:32,970 --> 01:54:37,140
 show you their complexity bound it's so

5372
01:54:34,850 --> 01:54:37,140
 

5373
01:54:34,860 --> 01:54:39,210
 long but they had to use a figure star

5374
01:54:37,130 --> 01:54:39,210
 

5375
01:54:37,140 --> 01:54:40,950
 to span two columns to give the equation

5376
01:54:39,200 --> 01:54:40,950
 

5377
01:54:39,210 --> 01:54:43,050
 because it's just it's so terrible so I

5378
01:54:40,940 --> 01:54:43,050
 

5379
01:54:40,950 --> 01:54:45,030
 didn't put it on my slides but it's much

5380
01:54:43,040 --> 01:54:45,030
 

5381
01:54:43,050 --> 01:54:47,580
 better it scales with the sub optimality

5382
01:54:45,020 --> 01:54:47,580
 

5383
01:54:45,030 --> 01:54:49,140
 gap it depends on epsilon and Delta

5384
01:54:47,570 --> 01:54:49,140
 

5385
01:54:47,580 --> 01:54:52,770
 individually rather than through their

5386
01:54:49,130 --> 01:54:52,770
 

5387
01:54:49,140 --> 01:54:54,540
 product they also compared to the cap

5388
01:54:52,760 --> 01:54:54,540
 

5389
01:54:52,770 --> 01:54:55,800
 top Timon rather than the uncapped

5390
01:54:54,530 --> 01:54:55,800
 

5391
01:54:54,540 --> 01:54:59,760
 optimum which is a little bit better

5392
01:54:55,790 --> 01:54:59,760
 

5393
01:54:55,800 --> 01:55:01,950
 it's still not anytime basically the way

5394
01:54:59,750 --> 01:55:01,950
 

5395
01:54:59,760 --> 01:55:04,230
 this algorithm works is they estimate

5396
01:55:01,940 --> 01:55:04,230
 

5397
01:55:01,950 --> 01:55:06,960
 the 1 minus Delta quantile of each

5398
01:55:04,220 --> 01:55:06,960
 

5399
01:55:04,230 --> 01:55:09,450
 configurations runtime over the

5400
01:55:06,950 --> 01:55:09,450
 

5401
01:55:06,960 --> 01:55:12,090
 distribution so they begin by estimating

5402
01:55:09,440 --> 01:55:12,090
 

5403
01:55:09,450 --> 01:55:15,270
 everybody's quantiles then they estimate

5404
01:55:12,080 --> 01:55:15,270
 

5405
01:55:12,090 --> 01:55:16,380
 the mean run of each algorithm using

5406
01:55:15,260 --> 01:55:16,380
 

5407
01:55:15,270 --> 01:55:21,620
 this quantile that they've previously

5408
01:55:16,370 --> 01:55:21,620
 

5409
01:55:16,380 --> 01:55:24,690
 estimated as a captain and they compare

5410
01:55:21,610 --> 01:55:24,690
 

5411
01:55:21,620 --> 01:55:27,240
 again on their same benchmark

5412
01:55:24,680 --> 01:55:27,240
 

5413
01:55:24,690 --> 01:55:29,000
 distribution that they used before so

5414
01:55:27,230 --> 01:55:29,000
 

5415
01:55:27,240 --> 01:55:31,140
 here's the same leaps and bounds and

5416
01:55:28,990 --> 01:55:31,140
 

5417
01:55:29,000 --> 01:55:33,300
 structure procrastination graphs you saw

5418
01:55:31,130 --> 01:55:33,300
 

5419
01:55:31,140 --> 01:55:35,310
 before and the blue line is their new

5420
01:55:33,290 --> 01:55:35,310
 

5421
01:55:33,300 --> 01:55:38,970
 algorithm caps and rods so you can see

5422
01:55:35,300 --> 01:55:38,970
 

5423
01:55:35,310 --> 01:55:41,640
 oh I have a late tide bleach there sorry

5424
01:55:38,960 --> 01:55:41,640
 

5425
01:55:38,970 --> 01:55:44,520
 that 586 at the bottom is meant to be at

5426
01:55:41,630 --> 01:55:44,520
 

5427
01:55:41,640 --> 01:55:46,200
 the top line saying how many CPU days it

5428
01:55:44,510 --> 01:55:46,200
 

5429
01:55:44,520 --> 01:55:48,120
 took them for reasons that I don't

5430
01:55:46,190 --> 01:55:48,120
 

5431
01:55:46,200 --> 01:55:50,760
 understand they switch to epsilon equals

5432
01:55:48,110 --> 01:55:50,760
 

5433
01:55:48,120 --> 01:55:52,050
 0.05 instead of epsilon 0.2 so this

5434
01:55:50,750 --> 01:55:52,050
 

5435
01:55:50,760 --> 01:55:54,180
 isn't directly comparable to the

5436
01:55:52,040 --> 01:55:54,180
 

5437
01:55:52,050 --> 01:55:54,930
 previous figure as all the numbers get

5438
01:55:54,170 --> 01:55:54,930
 

5439
01:55:54,180 --> 01:55:56,280
 bigger

5440
01:55:54,920 --> 01:55:56,280
 

5441
01:55:54,930 --> 01:55:58,490
 and making structural procrastination

5442
01:55:56,270 --> 01:55:58,490
 

5443
01:55:56,280 --> 01:56:02,970
 really really bite the bullet and take

5444
01:55:58,480 --> 01:56:02,970
 

5445
01:55:58,490 --> 01:56:04,110
 20,000 CPU days but but regardless you

5446
01:56:02,960 --> 01:56:04,110
 

5447
01:56:02,970 --> 01:56:07,800
 see they're getting better performance

5448
01:56:04,100 --> 01:56:07,800
 

5449
01:56:04,110 --> 01:56:09,570
 overall so finally this story wouldn't

5450
01:56:07,790 --> 01:56:09,570
 

5451
01:56:07,800 --> 01:56:11,220
 be complete if we of course didn't have

5452
01:56:09,560 --> 01:56:11,220
 

5453
01:56:09,570 --> 01:56:13,350
 our own thing that we were working on

5454
01:56:11,210 --> 01:56:13,350
 

5455
01:56:11,220 --> 01:56:16,260
 which we call structure procrastination

5456
01:56:13,340 --> 01:56:16,260
 

5457
01:56:13,350 --> 01:56:18,060
 with confidence ICML in its wisdom chose

5458
01:56:16,250 --> 01:56:18,060
 

5459
01:56:16,260 --> 01:56:22,620
 not to accept our paper but it's on

5460
01:56:18,050 --> 01:56:22,620
 

5461
01:56:18,060 --> 01:56:24,180
 archive anyway and it's an extension to

5462
01:56:22,610 --> 01:56:24,180
 

5463
01:56:22,620 --> 01:56:26,190
 the structure procrastination algorithm

5464
01:56:24,170 --> 01:56:26,190
 

5465
01:56:24,180 --> 01:56:27,570
 that I told you about before that has a

5466
01:56:26,180 --> 01:56:27,570
 

5467
01:56:26,190 --> 01:56:30,240
 different way of adapting to easy

5468
01:56:27,560 --> 01:56:30,240
 

5469
01:56:27,570 --> 01:56:31,620
 problem instances the the crucial

5470
01:56:30,230 --> 01:56:31,620
 

5471
01:56:30,240 --> 01:56:33,300
 difference between it and the two

5472
01:56:31,610 --> 01:56:33,300
 

5473
01:56:31,620 --> 01:56:35,700
 methods that I just told you about is

5474
01:56:33,290 --> 01:56:35,700
 

5475
01:56:33,300 --> 01:56:37,410
 that it's in any time algorithm so Delta

5476
01:56:35,690 --> 01:56:37,410
 

5477
01:56:35,700 --> 01:56:40,230
 is gradually refined during the search

5478
01:56:37,400 --> 01:56:40,230
 

5479
01:56:37,410 --> 01:56:42,120
 process this is helpful both because

5480
01:56:40,220 --> 01:56:42,120
 

5481
01:56:40,230 --> 01:56:43,620
 Delta is a very arbitrary quantity that

5482
01:56:42,110 --> 01:56:43,620
 

5483
01:56:42,120 --> 01:56:45,660
 it's hard for the user to think about

5484
01:56:43,610 --> 01:56:45,660
 

5485
01:56:43,620 --> 01:56:47,840
 and also because it actually turns out

5486
01:56:45,650 --> 01:56:47,840
 

5487
01:56:45,660 --> 01:56:50,040
 to help performance to a very Delta

5488
01:56:47,830 --> 01:56:50,040
 

5489
01:56:47,840 --> 01:56:51,870
 gradually because some of the really bad

5490
01:56:50,030 --> 01:56:51,870
 

5491
01:56:50,040 --> 01:56:55,500
 configurations can be thrown out based

5492
01:56:51,860 --> 01:56:55,500
 

5493
01:56:51,870 --> 01:56:57,270
 on very coarse deltas and are you know

5494
01:56:55,490 --> 01:56:57,270
 

5495
01:56:55,500 --> 01:57:00,690
 the paper of course is theoretical so

5496
01:56:57,260 --> 01:57:00,690
 

5497
01:56:57,270 --> 01:57:05,100
 most of the papers analysis and the the

5498
01:57:00,680 --> 01:57:05,100
 

5499
01:57:00,690 --> 01:57:06,360
 main result of the paper is that mikhyl

5500
01:57:05,090 --> 01:57:06,360
 

5501
01:57:05,100 --> 01:57:08,190
 eat aches as long for structure

5502
01:57:06,350 --> 01:57:08,190
 

5503
01:57:06,360 --> 01:57:11,190
 procrastination with confidence to

5504
01:57:08,180 --> 01:57:11,190
 

5505
01:57:08,190 --> 01:57:12,930
 identify the best configuration as it

5506
01:57:11,180 --> 01:57:12,930
 

5507
01:57:11,190 --> 01:57:14,700
 would have taken an Oracle to

5508
01:57:12,920 --> 01:57:14,700
 

5509
01:57:12,930 --> 01:57:16,890
 demonstrate to a skeptic that that was

5510
01:57:14,690 --> 01:57:16,890
 

5511
01:57:14,700 --> 01:57:20,280
 the best configuration so even if the

5512
01:57:16,880 --> 01:57:20,280
 

5513
01:57:16,890 --> 01:57:21,750
 Oracle knew everything about how you

5514
01:57:20,270 --> 01:57:21,750
 

5515
01:57:20,280 --> 01:57:24,120
 know the epsilon and Delta for which

5516
01:57:21,740 --> 01:57:24,120
 

5517
01:57:21,750 --> 01:57:25,620
 this is epsilon Delta optimal and some

5518
01:57:24,110 --> 01:57:25,620
 

5519
01:57:24,120 --> 01:57:27,660
 facts about all of the other algorithms

5520
01:57:25,610 --> 01:57:27,660
 

5521
01:57:25,620 --> 01:57:29,970
 that have to be compared against it this

5522
01:57:27,650 --> 01:57:29,970
 

5523
01:57:27,660 --> 01:57:32,330
 is the number of runs that the Oracle

5524
01:57:29,960 --> 01:57:32,330
 

5525
01:57:29,970 --> 01:57:36,060
 would have to sample to to demonstrate

5526
01:57:32,320 --> 01:57:36,060
 

5527
01:57:32,330 --> 01:57:38,220
 this fact and I'm going to tell you how

5528
01:57:36,050 --> 01:57:38,220
 

5529
01:57:36,060 --> 01:57:40,260
 it works because at least in its cartoon

5530
01:57:38,210 --> 01:57:40,260
 

5531
01:57:38,220 --> 01:57:42,150
 form it's very similar to what I told

5532
01:57:40,250 --> 01:57:42,150
 

5533
01:57:40,260 --> 01:57:43,890
 you before so here's the structure

5534
01:57:42,140 --> 01:57:43,890
 

5535
01:57:42,150 --> 01:57:45,870
 procrastination algorithm exactly as I

5536
01:57:43,880 --> 01:57:45,870
 

5537
01:57:43,890 --> 01:57:48,360
 showed it to you before and we make two

5538
01:57:45,860 --> 01:57:48,360
 

5539
01:57:45,870 --> 01:57:51,000
 changes so instead of calculating the

5540
01:57:48,350 --> 01:57:51,000
 

5541
01:57:48,360 --> 01:57:53,760
 approximate expected runtime for each

5542
01:57:50,990 --> 01:57:53,760
 

5543
01:57:51,000 --> 01:57:56,190
 theta we compute a lower confidence

5544
01:57:53,750 --> 01:57:56,190
 

5545
01:57:53,760 --> 01:57:57,930
 bound unexpected runtime and the details

5546
01:57:56,180 --> 01:57:57,930
 

5547
01:57:56,190 --> 01:57:59,910
 of where this lower confidence bound

5548
01:57:57,920 --> 01:57:59,910
 

5549
01:57:57,930 --> 01:58:01,890
 comes from are quite involved and I'll

5550
01:57:59,900 --> 01:58:01,890
 

5551
01:57:59,910 --> 01:58:04,380
 refer you to the paper but but we end up

5552
01:58:01,880 --> 01:58:04,380
 

5553
01:58:01,890 --> 01:58:06,000
 with this bound and then we have to

5554
01:58:04,370 --> 01:58:06,000
 

5555
01:58:04,380 --> 01:58:07,680
 change our termination conditions so

5556
01:58:05,990 --> 01:58:07,680
 

5557
01:58:06,000 --> 01:58:07,969
 instead of the configuration we spent

5558
01:58:07,670 --> 01:58:07,969
 

5559
01:58:07,680 --> 01:58:09,320
 the mo

5560
01:58:07,959 --> 01:58:09,320
 

5561
01:58:07,969 --> 01:58:10,849
 time running we returned the

5562
01:58:09,310 --> 01:58:10,849
 

5563
01:58:09,320 --> 01:58:14,599
 configuration that either solved or

5564
01:58:10,839 --> 01:58:14,599
 

5565
01:58:10,849 --> 01:58:17,479
 attempted the most instances and we're

5566
01:58:14,589 --> 01:58:17,479
 

5567
01:58:14,599 --> 01:58:19,639
 able to compare unfortunately

5568
01:58:17,469 --> 01:58:19,639
 

5569
01:58:17,479 --> 01:58:21,289
 for technical reasons we haven't yet got

5570
01:58:19,629 --> 01:58:21,289
 

5571
01:58:19,639 --> 01:58:23,539
 a comparison with caps and runs because

5572
01:58:21,279 --> 01:58:23,539
 

5573
01:58:21,289 --> 01:58:25,999
 their algorithm requires you to run

5574
01:58:23,529 --> 01:58:25,999
 

5575
01:58:23,539 --> 01:58:27,800
 about 20 million algorithms in parallel

5576
01:58:25,989 --> 01:58:27,800
 

5577
01:58:25,999 --> 01:58:30,139
 which researchers at Google are able to

5578
01:58:27,790 --> 01:58:30,139
 

5579
01:58:27,800 --> 01:58:31,639
 do but I'm not so we haven't yet gotten

5580
01:58:30,129 --> 01:58:31,639
 

5581
01:58:30,139 --> 01:58:33,499
 around that that little engineering

5582
01:58:31,629 --> 01:58:33,499
 

5583
01:58:31,639 --> 01:58:36,289
 detail but we're able to compare with

5584
01:58:33,489 --> 01:58:36,289
 

5585
01:58:33,499 --> 01:58:37,729
 leaps and bounds here I'm graphing this

5586
01:58:36,279 --> 01:58:37,729
 

5587
01:58:36,289 --> 01:58:39,559
 a little bit differently so it's at the

5588
01:58:37,719 --> 01:58:39,559
 

5589
01:58:37,729 --> 01:58:42,079
 top you can see this is the same data

5590
01:58:39,549 --> 01:58:42,079
 

5591
01:58:39,559 --> 01:58:44,090
 said they looked at at the top you can

5592
01:58:42,069 --> 01:58:44,090
 

5593
01:58:42,079 --> 01:58:48,409
 see the total amounts of time it took to

5594
01:58:44,080 --> 01:58:48,409
 

5595
01:58:44,090 --> 01:58:49,880
 prove Epsilon point 1 Delta point 2 but

5596
01:58:48,399 --> 01:58:49,880
 

5597
01:58:48,409 --> 01:58:52,099
 what I'm showing you because it's at any

5598
01:58:49,870 --> 01:58:52,099
 

5599
01:58:49,880 --> 01:58:54,679
 time algorithm on the x-axis is amount

5600
01:58:52,089 --> 01:58:54,679
 

5601
01:58:52,099 --> 01:58:57,650
 of time on the log axis sorry on a log

5602
01:58:54,669 --> 01:58:57,650
 

5603
01:58:54,679 --> 01:58:59,780
 scale and on the y-axis is the Delta for

5604
01:58:57,640 --> 01:58:59,780
 

5605
01:58:57,650 --> 01:59:05,360
 which we've proven something and so as

5606
01:58:59,770 --> 01:59:05,360
 

5607
01:58:59,780 --> 01:59:08,179
 we run along we very quickly start to

5608
01:59:05,350 --> 01:59:08,179
 

5609
01:59:05,360 --> 01:59:09,679
 prove stronger and stronger Delta's you

5610
01:59:08,169 --> 01:59:09,679
 

5611
01:59:08,179 --> 01:59:12,409
 can see structure procrastination takes

5612
01:59:09,669 --> 01:59:12,409
 

5613
01:59:09,679 --> 01:59:14,479
 forever to get anywhere and leaps and

5614
01:59:12,399 --> 01:59:14,479
 

5615
01:59:12,409 --> 01:59:15,979
 bounds because it's not anytime we just

5616
01:59:14,469 --> 01:59:15,979
 

5617
01:59:14,479 --> 01:59:18,320
 have points showing the different run

5618
01:59:15,969 --> 01:59:18,320
 

5619
01:59:15,979 --> 01:59:20,329
 times that it would have gotten if asked

5620
01:59:18,310 --> 01:59:20,329
 

5621
01:59:18,320 --> 01:59:24,559
 to run for different deltas so you can

5622
01:59:20,319 --> 01:59:24,559
 

5623
01:59:20,329 --> 01:59:26,960
 see that within your a very short amount

5624
01:59:24,549 --> 01:59:26,960
 

5625
01:59:24,559 --> 01:59:28,789
 of time we're almost an order of

5626
01:59:26,950 --> 01:59:28,789
 

5627
01:59:26,960 --> 01:59:31,460
 magnitude faster kyv consistently

5628
01:59:28,779 --> 01:59:31,460
 

5629
01:59:28,789 --> 01:59:34,880
 throughout and without requiring to know

5630
01:59:31,450 --> 01:59:34,880
 

5631
01:59:31,460 --> 01:59:36,800
 what what Delta you want to solve for ok

5632
01:59:34,870 --> 01:59:36,800
 

5633
01:59:34,880 --> 01:59:38,630
 so that's most of what I want to say let

5634
01:59:36,790 --> 01:59:38,630
 

5635
01:59:36,800 --> 01:59:40,690
 me just very quickly gesture at some

5636
01:59:38,620 --> 01:59:40,690
 

5637
01:59:38,630 --> 01:59:43,249
 related work because there is a lot of

5638
01:59:40,680 --> 01:59:43,249
 

5639
01:59:40,690 --> 01:59:45,079
 theoretically motivated Relater related

5640
01:59:43,239 --> 01:59:45,079
 

5641
01:59:43,249 --> 01:59:47,510
 work here that I don't have time to tell

5642
01:59:45,069 --> 01:59:47,510
 

5643
01:59:45,079 --> 01:59:49,550
 you about and first of all obviously

5644
01:59:47,500 --> 01:59:49,550
 

5645
01:59:47,510 --> 01:59:52,099
 everything that I've spoken about here

5646
01:59:49,540 --> 01:59:52,099
 

5647
01:59:49,550 --> 01:59:54,530
 you know leans very heavily on work in

5648
01:59:52,089 --> 01:59:54,530
 

5649
01:59:52,099 --> 01:59:56,179
 the Bandits literature so we're

5650
01:59:54,520 --> 01:59:56,179
 

5651
01:59:54,530 --> 01:59:58,070
 appealing to the optimism in the face of

5652
01:59:56,169 --> 01:59:58,070
 

5653
01:59:56,179 --> 01:59:59,389
 uncertainty paradigm that is you know

5654
01:59:58,060 --> 01:59:59,389
 

5655
01:59:58,070 --> 02:00:02,239
 really standard in the bandhas

5656
01:59:59,379 --> 02:00:02,239
 

5657
01:59:59,389 --> 02:00:03,860
 literature there's a lot of very related

5658
02:00:02,229 --> 02:00:03,860
 

5659
02:00:02,239 --> 02:00:05,599
 work on bandits with correlated arms

5660
02:00:03,850 --> 02:00:05,599
 

5661
02:00:03,860 --> 02:00:08,210
 that scale to large experimental design

5662
02:00:05,589 --> 02:00:08,210
 

5663
02:00:05,599 --> 02:00:10,729
 settings I've cited some relevant work

5664
02:00:08,200 --> 02:00:10,729
 

5665
02:00:08,210 --> 02:00:12,920
 here and let me remind you that you can

5666
02:00:10,719 --> 02:00:12,920
 

5667
02:00:10,729 --> 02:00:16,940
 download the tutorial and click on these

5668
02:00:12,910 --> 02:00:16,940
 

5669
02:00:12,920 --> 02:00:18,320
 links and get all of the papers it's

5670
02:00:16,930 --> 02:00:18,320
 

5671
02:00:16,940 --> 02:00:20,179
 worth saying though that this is a

5672
02:00:18,310 --> 02:00:20,179
 

5673
02:00:18,320 --> 02:00:21,269
 really interestingly different bandit

5674
02:00:20,169 --> 02:00:21,269
 

5675
02:00:20,179 --> 02:00:23,369
 problem than

5676
02:00:21,259 --> 02:00:23,369
 

5677
02:00:21,269 --> 02:00:25,679
 just about every bandit problem' studied

5678
02:00:23,359 --> 02:00:25,679
 

5679
02:00:23,369 --> 02:00:27,119
 in the literature and this kind of

5680
02:00:25,669 --> 02:00:27,119
 

5681
02:00:25,679 --> 02:00:28,679
 motivates why at the beginning of the

5682
02:00:27,109 --> 02:00:28,679
 

5683
02:00:27,119 --> 02:00:31,499
 talk I said it was interesting to focus

5684
02:00:28,669 --> 02:00:31,499
 

5685
02:00:28,679 --> 02:00:33,749
 on runtime so the cost of pulling an arm

5686
02:00:31,489 --> 02:00:33,749
 

5687
02:00:31,499 --> 02:00:35,249
 is usually considered to be constant and

5688
02:00:33,739 --> 02:00:35,249
 

5689
02:00:33,749 --> 02:00:37,590
 a bandit problem but for us it's

5690
02:00:35,239 --> 02:00:37,590
 

5691
02:00:35,249 --> 02:00:39,510
 variable and furthermore it's measured

5692
02:00:37,580 --> 02:00:39,510
 

5693
02:00:37,590 --> 02:00:42,659
 in the same units as our minimization

5694
02:00:39,500 --> 02:00:42,659
 

5695
02:00:39,510 --> 02:00:45,570
 objective function so we have this weird

5696
02:00:42,649 --> 02:00:45,570
 

5697
02:00:42,659 --> 02:00:48,360
 virtuous cycle where good arms are very

5698
02:00:45,560 --> 02:00:48,360
 

5699
02:00:45,570 --> 02:00:51,059
 inexpensive to pull and bad arms can be

5700
02:00:48,350 --> 02:00:51,059
 

5701
02:00:48,360 --> 02:00:52,920
 really really bad to pull and to

5702
02:00:51,049 --> 02:00:52,920
 

5703
02:00:51,059 --> 02:00:54,869
 mitigate this problem we also have this

5704
02:00:52,910 --> 02:00:54,869
 

5705
02:00:52,920 --> 02:00:57,599
 second wrinkle to the problem that says

5706
02:00:54,859 --> 02:00:57,599
 

5707
02:00:54,869 --> 02:00:59,519
 I can set a maximum amount Kappa that

5708
02:00:57,589 --> 02:00:59,519
 

5709
02:00:57,599 --> 02:01:01,889
 I'm willing to pay before I pull in arm

5710
02:00:59,509 --> 02:01:01,889
 

5711
02:00:59,519 --> 02:01:04,260
 and if the true cost of pulling that arm

5712
02:01:01,879 --> 02:01:04,260
 

5713
02:01:01,889 --> 02:01:06,480
 is less than this Kappa then I pay the

5714
02:01:04,250 --> 02:01:06,480
 

5715
02:01:04,260 --> 02:01:08,550
 real cost and if the true cost is

5716
02:01:06,470 --> 02:01:08,550
 

5717
02:01:06,480 --> 02:01:10,320
 greater I just pay Kappa but I don't

5718
02:01:08,540 --> 02:01:10,320
 

5719
02:01:08,550 --> 02:01:13,289
 learn the whole sample I only learned

5720
02:01:10,310 --> 02:01:13,289
 

5721
02:01:10,320 --> 02:01:16,440
 that the sample was worse than Kappa so

5722
02:01:13,279 --> 02:01:16,440
 

5723
02:01:13,289 --> 02:01:18,929
 we're not aware of any bandit analysis

5724
02:01:16,430 --> 02:01:18,929
 

5725
02:01:16,440 --> 02:01:20,789
 that that studies that bizarre kind of

5726
02:01:18,919 --> 02:01:20,789
 

5727
02:01:18,929 --> 02:01:22,320
 bandits sub problem and these are

5728
02:01:20,779 --> 02:01:22,320
 

5729
02:01:20,789 --> 02:01:23,670
 pointers to the closest things we do

5730
02:01:22,310 --> 02:01:23,670
 

5731
02:01:22,320 --> 02:01:26,219
 know about in the bandits literature if

5732
02:01:23,660 --> 02:01:26,219
 

5733
02:01:23,670 --> 02:01:29,670
 you're interested finally let me just

5734
02:01:26,209 --> 02:01:29,670
 

5735
02:01:26,219 --> 02:01:31,139
 point out two different sort of veins of

5736
02:01:29,660 --> 02:01:31,139
 

5737
02:01:29,670 --> 02:01:34,079
 related work that are particularly

5738
02:01:31,129 --> 02:01:34,079
 

5739
02:01:31,139 --> 02:01:36,630
 relevant one is work at hyper parameter

5740
02:01:34,069 --> 02:01:36,630
 

5741
02:01:34,079 --> 02:01:38,519
 optimization and in that work what's

5742
02:01:36,620 --> 02:01:38,519
 

5743
02:01:36,630 --> 02:01:43,440
 with the most important to note to you

5744
02:01:38,509 --> 02:01:43,440
 

5745
02:01:38,519 --> 02:01:45,179
 is the hyper band paper for hyper

5746
02:01:43,430 --> 02:01:45,179
 

5747
02:01:43,440 --> 02:01:47,369
 parameter optimization with provable

5748
02:01:45,169 --> 02:01:47,369
 

5749
02:01:45,179 --> 02:01:49,019
 theoretical guarantees it uses many of

5750
02:01:47,359 --> 02:01:49,019
 

5751
02:01:47,369 --> 02:01:50,249
 the same theoretical tools we have an

5752
02:01:49,009 --> 02:01:50,249
 

5753
02:01:49,019 --> 02:01:51,749
 extensive discussion in the first

5754
02:01:50,239 --> 02:01:51,749
 

5755
02:01:50,249 --> 02:01:54,719
 structure procrastination paper about

5756
02:01:51,739 --> 02:01:54,719
 

5757
02:01:51,749 --> 02:01:56,550
 how it differs finally there's starting

5758
02:01:54,709 --> 02:01:56,550
 

5759
02:01:54,719 --> 02:01:58,650
 to be a really interesting literature on

5760
02:01:56,540 --> 02:01:58,650
 

5761
02:01:56,550 --> 02:02:00,929
 learning theoretic foundations of

5762
02:01:58,640 --> 02:02:00,929
 

5763
02:01:58,650 --> 02:02:02,699
 algorithm configuration broadly and

5764
02:02:00,919 --> 02:02:02,699
 

5765
02:02:00,929 --> 02:02:05,460
 heuristic algorithm designed more

5766
02:02:02,689 --> 02:02:05,460
 

5767
02:02:02,699 --> 02:02:07,650
 narrowly Gupta and roughgarden

5768
02:02:05,450 --> 02:02:07,650
 

5769
02:02:05,460 --> 02:02:08,999
 is probably the the seminal paper that

5770
02:02:07,640 --> 02:02:08,999
 

5771
02:02:07,650 --> 02:02:10,860
 really started this off thinking about

5772
02:02:08,989 --> 02:02:10,860
 

5773
02:02:08,999 --> 02:02:13,130
 configuration and selection in terms of

5774
02:02:10,850 --> 02:02:13,130
 

5775
02:02:10,860 --> 02:02:15,690
 learning theory and then there's a

5776
02:02:13,120 --> 02:02:15,690
 

5777
02:02:13,130 --> 02:02:18,900
 particularly nice vein of work out of

5778
02:02:15,680 --> 02:02:18,900
 

5779
02:02:15,690 --> 02:02:20,400
 Nina Balkans group some of which is in

5780
02:02:18,890 --> 02:02:20,400
 

5781
02:02:18,900 --> 02:02:22,320
 collaboration with Thomas santim

5782
02:02:20,390 --> 02:02:22,320
 

5783
02:02:20,400 --> 02:02:24,480
 thinking about how to apply these

5784
02:02:22,310 --> 02:02:24,480
 

5785
02:02:22,320 --> 02:02:26,340
 learning theoretic ideas to particular

5786
02:02:24,470 --> 02:02:26,340
 

5787
02:02:24,480 --> 02:02:28,199
 combinatorial optimization problems so

5788
02:02:26,330 --> 02:02:28,199
 

5789
02:02:26,340 --> 02:02:30,239
 not building general tools the way we

5790
02:02:28,189 --> 02:02:30,239
 

5791
02:02:28,199 --> 02:02:32,760
 focused on here but digging a little bit

5792
02:02:30,229 --> 02:02:32,760
 

5793
02:02:30,239 --> 02:02:34,140
 more deeply into properties that hold

5794
02:02:32,750 --> 02:02:34,140
 

5795
02:02:32,760 --> 02:02:36,330
 about a certain subject

5796
02:02:34,130 --> 02:02:36,330
 

5797
02:02:34,140 --> 02:02:50,220
 problems so I'll leave it there and head

5798
02:02:36,320 --> 02:02:50,220
 

5799
02:02:36,330 --> 02:02:53,460
 over to Frank alright so in this last

5800
02:02:50,210 --> 02:02:53,460
 

5801
02:02:50,220 --> 02:02:56,430
 part of the tutorial I'd like to take a

5802
02:02:53,450 --> 02:02:56,430
 

5803
02:02:53,460 --> 02:02:58,860
 step back and actually look beyond the

5804
02:02:56,420 --> 02:02:58,860
 

5805
02:02:56,430 --> 02:03:00,540
 static algorithm configuration problem

5806
02:02:58,850 --> 02:03:00,540
 

5807
02:02:58,860 --> 02:03:01,140
 that we've looked at so far in the

5808
02:03:00,530 --> 02:03:01,140
 

5809
02:03:00,540 --> 02:03:03,570
 tutorial

5810
02:03:01,130 --> 02:03:03,570
 

5811
02:03:01,140 --> 02:03:05,850
 so Kevin defined algorithm configuration

5812
02:03:03,560 --> 02:03:05,850
 

5813
02:03:03,570 --> 02:03:07,440
 about one and a half hours hours ago but

5814
02:03:05,840 --> 02:03:07,440
 

5815
02:03:05,850 --> 02:03:09,570
 there's a lot of related problems and

5816
02:03:07,430 --> 02:03:09,570
 

5817
02:03:07,440 --> 02:03:13,110
 emerging directions that are actually

5818
02:03:09,560 --> 02:03:13,110
 

5819
02:03:09,570 --> 02:03:15,450
 also really interesting the first one I

5820
02:03:13,100 --> 02:03:15,450
 

5821
02:03:13,110 --> 02:03:18,360
 want to look at is parameter importance

5822
02:03:15,440 --> 02:03:18,360
 

5823
02:03:15,450 --> 02:03:20,600
 so algorithm configuration that the

5824
02:03:18,350 --> 02:03:20,600
 

5825
02:03:18,360 --> 02:03:23,190
 setting is you're looking for one good

5826
02:03:20,590 --> 02:03:23,190
 

5827
02:03:20,600 --> 02:03:25,320
 one would permit a setting that works

5828
02:03:23,180 --> 02:03:25,320
 

5829
02:03:23,190 --> 02:03:29,430
 well on average across all the different

5830
02:03:25,310 --> 02:03:29,430
 

5831
02:03:25,320 --> 02:03:31,920
 instances and that is all you run this

5832
02:03:29,420 --> 02:03:31,920
 

5833
02:03:29,430 --> 02:03:33,840
 algorithm configuration method and it

5834
02:03:31,910 --> 02:03:33,840
 

5835
02:03:31,920 --> 02:03:35,370
 gives you one configuration there is a

5836
02:03:33,830 --> 02:03:35,370
 

5837
02:03:33,840 --> 02:03:38,310
 space an optimization model you've

5838
02:03:35,360 --> 02:03:38,310
 

5839
02:03:35,370 --> 02:03:41,250
 modeled runtime but none of that is used

5840
02:03:38,300 --> 02:03:41,250
 

5841
02:03:38,310 --> 02:03:43,320
 none of that is returned to the Iverson

5842
02:03:41,240 --> 02:03:43,320
 

5843
02:03:41,250 --> 02:03:46,250
 designer who's actually interested in

5844
02:03:43,310 --> 02:03:46,250
 

5845
02:03:43,320 --> 02:03:49,470
 well what makes my algorithm tick and

5846
02:03:46,240 --> 02:03:49,470
 

5847
02:03:46,250 --> 02:03:51,450
 here we would like to actually use all

5848
02:03:49,460 --> 02:03:51,450
 

5849
02:03:49,470 --> 02:03:52,980
 this data in order to figure out which

5850
02:03:51,440 --> 02:03:52,980
 

5851
02:03:51,450 --> 02:03:56,750
 are the parameters that are most

5852
02:03:52,970 --> 02:03:56,750
 

5853
02:03:52,980 --> 02:04:01,560
 important and how are they're important

5854
02:03:56,740 --> 02:04:01,560
 

5855
02:03:56,750 --> 02:04:03,390
 one way you can use this model in order

5856
02:04:01,550 --> 02:04:03,390
 

5857
02:04:01,560 --> 02:04:04,770
 to give some information to the

5858
02:04:03,380 --> 02:04:04,770
 

5859
02:04:03,390 --> 02:04:07,560
 algorithm designer that a human can

5860
02:04:04,760 --> 02:04:07,560
 

5861
02:04:04,770 --> 02:04:10,920
 understand is to actually marginalize

5862
02:04:07,550 --> 02:04:10,920
 

5863
02:04:07,560 --> 02:04:14,430
 away all parameters except of one and

5864
02:04:10,910 --> 02:04:14,430
 

5865
02:04:10,920 --> 02:04:16,530
 then then make plot such as this one

5866
02:04:14,420 --> 02:04:16,530
 

5867
02:04:14,430 --> 02:04:19,230
 where you say well this this parameter

5868
02:04:16,520 --> 02:04:19,230
 

5869
02:04:16,530 --> 02:04:23,160
 here marginalized across all the other

5870
02:04:19,220 --> 02:04:23,160
 

5871
02:04:19,230 --> 02:04:24,750
 ones has this effect this parameter is

5872
02:04:23,150 --> 02:04:24,750
 

5873
02:04:23,160 --> 02:04:28,040
 this affect those parameters this effect

5874
02:04:24,740 --> 02:04:28,040
 

5875
02:04:24,750 --> 02:04:30,030
 so here performance varies the most

5876
02:04:28,030 --> 02:04:30,030
 

5877
02:04:28,040 --> 02:04:32,160
 depending on how you set this parameter

5878
02:04:30,020 --> 02:04:32,160
 

5879
02:04:30,030 --> 02:04:36,660
 and therefore this parameter is the most

5880
02:04:32,150 --> 02:04:36,660
 

5881
02:04:32,160 --> 02:04:39,630
 important to set right and and you can

5882
02:04:36,650 --> 02:04:39,630
 

5883
02:04:36,660 --> 02:04:43,650
 also do this for pairs of parameters or

5884
02:04:39,620 --> 02:04:43,650
 

5885
02:04:39,630 --> 02:04:45,360
 arbitrary subsets of parameters how do

5886
02:04:43,640 --> 02:04:45,360
 

5887
02:04:43,650 --> 02:04:48,490
 you do this technically well in

5888
02:04:45,350 --> 02:04:48,490
 

5889
02:04:45,360 --> 02:04:51,010
 regression trees we can actually do this

5890
02:04:48,480 --> 02:04:51,010
 

5891
02:04:48,490 --> 02:04:55,440
 so remember that we used regression

5892
02:04:51,000 --> 02:04:55,440
 

5893
02:04:51,010 --> 02:04:58,840
 trees and random forests in smack and

5894
02:04:55,430 --> 02:04:58,840
 

5895
02:04:55,440 --> 02:05:00,970
 when one way of doing looking at this is

5896
02:04:58,830 --> 02:05:00,970
 

5897
02:04:58,840 --> 02:05:02,800
 so you want the average performance for

5898
02:05:00,960 --> 02:05:02,800
 

5899
02:05:00,970 --> 02:05:05,560
 a particular value of in this case

5900
02:05:02,790 --> 02:05:05,560
 

5901
02:05:02,800 --> 02:05:07,300
 parameter 1 I'm assuming that all the

5902
02:05:05,550 --> 02:05:07,300
 

5903
02:05:05,560 --> 02:05:09,100
 other parameters here discretized for

5904
02:05:07,290 --> 02:05:09,100
 

5905
02:05:07,300 --> 02:05:10,780
 notational convenience so we have sums

5906
02:05:09,090 --> 02:05:10,780
 

5907
02:05:09,100 --> 02:05:12,730
 over all the different values that theta

5908
02:05:10,770 --> 02:05:12,730
 

5909
02:05:10,780 --> 02:05:17,110
 2 could take out of the domain of theta

5910
02:05:12,720 --> 02:05:17,110
 

5911
02:05:12,730 --> 02:05:19,540
 2 up to theta n and then you have here

5912
02:05:17,100 --> 02:05:19,540
 

5913
02:05:17,110 --> 02:05:21,490
 the true function so the performance of

5914
02:05:19,530 --> 02:05:21,490
 

5915
02:05:19,540 --> 02:05:24,820
 your algorithm with this parameter

5916
02:05:21,480 --> 02:05:24,820
 

5917
02:05:21,490 --> 02:05:27,580
 setting that's value V for parameter

5918
02:05:24,810 --> 02:05:27,580
 

5919
02:05:24,820 --> 02:05:29,950
 setting paramita1 and these values here

5920
02:05:27,570 --> 02:05:29,950
 

5921
02:05:27,580 --> 02:05:33,940
 for the other parameters so we

5922
02:05:29,940 --> 02:05:33,940
 

5923
02:05:29,950 --> 02:05:41,410
 approximate that with a model so here we

5924
02:05:33,930 --> 02:05:41,410
 

5925
02:05:33,940 --> 02:05:44,500
 have f hat instead of F good point yeah

5926
02:05:41,400 --> 02:05:44,500
 

5927
02:05:41,410 --> 02:05:46,570
 so here we have f hat instead of F so

5928
02:05:44,490 --> 02:05:46,570
 

5929
02:05:44,500 --> 02:05:50,010
 that's the approximation we do and then

5930
02:05:46,560 --> 02:05:50,010
 

5931
02:05:46,570 --> 02:05:52,210
 we just look at the how we can

5932
02:05:50,000 --> 02:05:52,210
 

5933
02:05:50,010 --> 02:05:55,150
 reformulate this regression tree

5934
02:05:52,200 --> 02:05:55,150
 

5935
02:05:52,210 --> 02:05:57,520
 prediction here and other than this

5936
02:05:55,140 --> 02:05:57,520
 

5937
02:05:55,150 --> 02:05:59,980
 approximation of your approximating the

5938
02:05:57,510 --> 02:05:59,980
 

5939
02:05:57,520 --> 02:06:03,250
 true performance everything else here is

5940
02:05:59,970 --> 02:06:03,250
 

5941
02:05:59,980 --> 02:06:06,940
 inequality so we exploit the particular

5942
02:06:03,240 --> 02:06:06,940
 

5943
02:06:03,250 --> 02:06:10,150
 structure of regression trees to look at

5944
02:06:06,930 --> 02:06:10,150
 

5945
02:06:06,940 --> 02:06:12,550
 the the prediction being a sum over the

5946
02:06:10,140 --> 02:06:12,550
 

5947
02:06:10,150 --> 02:06:14,470
 leaf of an indicator function that a

5948
02:06:12,540 --> 02:06:14,470
 

5949
02:06:12,550 --> 02:06:16,600
 particular data point falls into a

5950
02:06:14,460 --> 02:06:16,600
 

5951
02:06:14,470 --> 02:06:19,780
 particular leave and then rewrite that a

5952
02:06:16,590 --> 02:06:19,780
 

5953
02:06:16,600 --> 02:06:23,650
 little bit to end up with a computation

5954
02:06:19,770 --> 02:06:23,650
 

5955
02:06:19,780 --> 02:06:29,130
 that's linear time across Elise and so

5956
02:06:23,640 --> 02:06:29,130
 

5957
02:06:23,650 --> 02:06:31,270
 then given some arbitrary runtime

5958
02:06:29,120 --> 02:06:31,270
 

5959
02:06:29,130 --> 02:06:33,010
 measurements we can actually build these

5960
02:06:31,260 --> 02:06:33,010
 

5961
02:06:31,270 --> 02:06:35,620
 regression trees and then get these

5962
02:06:33,000 --> 02:06:35,620
 

5963
02:06:33,010 --> 02:06:38,070
 marginal predictions out really easily

5964
02:06:35,610 --> 02:06:38,070
 

5965
02:06:35,620 --> 02:06:40,720
 because we can do this in linear time

5966
02:06:38,060 --> 02:06:40,720
 

5967
02:06:38,070 --> 02:06:43,080
 when we have these marginal predictions

5968
02:06:40,710 --> 02:06:43,080
 

5969
02:06:40,720 --> 02:06:46,120
 what we can do is actually look at the

5970
02:06:43,070 --> 02:06:46,120
 

5971
02:06:43,080 --> 02:06:48,640
 variation of performance across the

5972
02:06:46,110 --> 02:06:48,640
 

5973
02:06:46,120 --> 02:06:51,790
 whole domain of our parameter space and

5974
02:06:48,630 --> 02:06:51,790
 

5975
02:06:48,640 --> 02:06:54,820
 call that the variance and we can

5976
02:06:51,780 --> 02:06:54,820
 

5977
02:06:51,790 --> 02:06:58,120
 decompose this variance into components

5978
02:06:54,810 --> 02:06:58,120
 

5979
02:06:54,820 --> 02:07:01,330
 due to each subset of the parameters so

5980
02:06:58,110 --> 02:07:01,330
 

5981
02:06:58,120 --> 02:07:04,330
 our variance e composes

5982
02:07:01,320 --> 02:07:04,330
 

5983
02:07:01,330 --> 02:07:06,130
 two variants due to a subset view of

5984
02:07:04,320 --> 02:07:06,130
 

5985
02:07:04,330 --> 02:07:08,890
 parameters and we sum that over all the

5986
02:07:06,120 --> 02:07:08,890
 

5987
02:07:06,130 --> 02:07:12,280
 different criminally large number of

5988
02:07:08,880 --> 02:07:12,280
 

5989
02:07:08,890 --> 02:07:13,930
 subsets of parameters and each of those

5990
02:07:12,270 --> 02:07:13,930
 

5991
02:07:12,280 --> 02:07:17,500
 we can actually compute based on these

5992
02:07:13,920 --> 02:07:17,500
 

5993
02:07:13,930 --> 02:07:19,960
 marginal predictions here and what then

5994
02:07:17,490 --> 02:07:19,960
 

5995
02:07:17,500 --> 02:07:24,040
 falls out of this is we can compute the

5996
02:07:19,950 --> 02:07:24,040
 

5997
02:07:19,960 --> 02:07:26,200
 main effect that's the contribution of

5998
02:07:24,030 --> 02:07:26,200
 

5999
02:07:24,040 --> 02:07:28,360
 this particular variable to this

6000
02:07:26,190 --> 02:07:28,360
 

6001
02:07:26,200 --> 02:07:31,420
 variance so that that's this parameter

6002
02:07:28,350 --> 02:07:31,420
 

6003
02:07:28,360 --> 02:07:34,360
 here this s that already explained 65%

6004
02:07:31,410 --> 02:07:34,360
 

6005
02:07:31,420 --> 02:07:37,140
 of the entire variation of performance

6006
02:07:34,350 --> 02:07:37,140
 

6007
02:07:34,360 --> 02:07:41,410
 across the entire domain and this

6008
02:07:37,130 --> 02:07:41,410
 

6009
02:07:37,140 --> 02:07:43,390
 combination of s and Kappa here that is

6010
02:07:41,400 --> 02:07:43,390
 

6011
02:07:41,410 --> 02:07:45,940
 responsible for another 18% of the

6012
02:07:43,380 --> 02:07:45,940
 

6013
02:07:43,390 --> 02:07:47,440
 variation so that means these two taken

6014
02:07:45,930 --> 02:07:47,440
 

6015
02:07:45,940 --> 02:07:49,960
 together already cover eighty eighty

6016
02:07:47,430 --> 02:07:49,960
 

6017
02:07:47,440 --> 02:07:51,580
 three percent of the variance and since

6018
02:07:49,950 --> 02:07:51,580
 

6019
02:07:49,960 --> 02:07:53,530
 none of these variance contributions can

6020
02:07:51,570 --> 02:07:53,530
 

6021
02:07:51,580 --> 02:07:55,360
 be negative it means that no other

6022
02:07:53,520 --> 02:07:55,360
 

6023
02:07:53,530 --> 02:07:58,510
 variance contribution can be actually

6024
02:07:55,350 --> 02:07:58,510
 

6025
02:07:55,360 --> 02:08:00,970
 larger than 17 percent so I'm just by

6026
02:07:58,500 --> 02:08:00,970
 

6027
02:07:58,510 --> 02:08:02,350
 looking at a couple of key parameters we

6028
02:08:00,960 --> 02:08:02,350
 

6029
02:08:00,970 --> 02:08:04,270
 can actually capture most of the

6030
02:08:02,340 --> 02:08:04,270
 

6031
02:08:02,350 --> 02:08:08,340
 variation and prove that the other

6032
02:08:04,260 --> 02:08:08,340
 

6033
02:08:04,270 --> 02:08:10,420
 parameters can't be that important and

6034
02:08:08,330 --> 02:08:10,420
 

6035
02:08:08,340 --> 02:08:13,060
 nicely we can actually do the main

6036
02:08:10,410 --> 02:08:13,060
 

6037
02:08:10,420 --> 02:08:14,590
 effects in linear time and the low order

6038
02:08:13,050 --> 02:08:14,590
 

6039
02:08:13,060 --> 02:08:17,890
 interaction effects in low order

6040
02:08:14,580 --> 02:08:17,890
 

6041
02:08:14,590 --> 02:08:20,590
 polynomial time so what can we do with

6042
02:08:17,880 --> 02:08:20,590
 

6043
02:08:17,890 --> 02:08:22,510
 this I talked earlier about the Sat

6044
02:08:20,580 --> 02:08:22,510
 

6045
02:08:20,590 --> 02:08:25,150
 solver spare that that we optimized we

6046
02:08:22,500 --> 02:08:25,150
 

6047
02:08:22,510 --> 02:08:28,360
 looked at 26 parameters and we optimized

6048
02:08:25,140 --> 02:08:28,360
 

6049
02:08:25,150 --> 02:08:30,220
 the source Mac what you can do is take

6050
02:08:28,350 --> 02:08:30,220
 

6051
02:08:28,360 --> 02:08:32,290
 this data that you gathered by running

6052
02:08:30,210 --> 02:08:32,290
 

6053
02:08:30,220 --> 02:08:34,870
 smack smack ransom algorithm runs on

6054
02:08:32,280 --> 02:08:34,870
 

6055
02:08:32,290 --> 02:08:36,640
 some instances and with different

6056
02:08:34,860 --> 02:08:36,640
 

6057
02:08:34,870 --> 02:08:38,850
 configurations and you can fit a model

6058
02:08:36,630 --> 02:08:38,850
 

6059
02:08:36,640 --> 02:08:41,410
 and then run this function ANOVA and

6060
02:08:38,840 --> 02:08:41,410
 

6061
02:08:38,850 --> 02:08:43,810
 what what fell out of that is that

6062
02:08:41,400 --> 02:08:43,810
 

6063
02:08:41,410 --> 02:08:45,970
 actually 93 percent of the variation and

6064
02:08:43,800 --> 02:08:45,970
 

6065
02:08:43,810 --> 02:08:47,920
 run time was due to a single parameter

6066
02:08:45,960 --> 02:08:47,920
 

6067
02:08:45,970 --> 02:08:49,600
 and that was the variable selection

6068
02:08:47,910 --> 02:08:49,600
 

6069
02:08:47,920 --> 02:08:52,480
 heuristic which is well known and said

6070
02:08:49,590 --> 02:08:52,480
 

6071
02:08:49,600 --> 02:08:53,950
 to be important but 93 percent that

6072
02:08:52,470 --> 02:08:53,950
 

6073
02:08:52,480 --> 02:08:56,760
 that's actually more important than than

6074
02:08:53,940 --> 02:08:56,760
 

6075
02:08:53,950 --> 02:08:59,260
 one would have expected and here is a

6076
02:08:56,750 --> 02:08:59,260
 

6077
02:08:56,760 --> 02:09:02,170
 two different instance distributions we

6078
02:08:59,250 --> 02:09:02,170
 

6079
02:08:59,260 --> 02:09:03,580
 used in that case study here was bounded

6080
02:09:02,160 --> 02:09:03,580
 

6081
02:09:02,170 --> 02:09:07,540
 model checking and here's software

6082
02:09:03,570 --> 02:09:07,540
 

6083
02:09:03,580 --> 02:09:10,840
 verification and note how that how this

6084
02:09:07,530 --> 02:09:10,840
 

6085
02:09:07,540 --> 02:09:13,120
 one variable how this one value here

6086
02:09:10,830 --> 02:09:13,120
 

6087
02:09:10,840 --> 02:09:15,100
 this one heuristic actually works

6088
02:09:13,110 --> 02:09:15,100
 

6089
02:09:13,120 --> 02:09:17,740
 extremely well for software

6090
02:09:15,090 --> 02:09:17,740
 

6091
02:09:15,100 --> 02:09:21,490
 and not very well for bounded model

6092
02:09:17,730 --> 02:09:21,490
 

6093
02:09:17,740 --> 02:09:24,400
 checking and actually the the neat thing

6094
02:09:21,480 --> 02:09:24,400
 

6095
02:09:21,490 --> 02:09:25,960
 is that the algorithm designer had no

6096
02:09:24,390 --> 02:09:25,960
 

6097
02:09:24,400 --> 02:09:28,240
 idea that this would actually work well

6098
02:09:25,950 --> 02:09:28,240
 

6099
02:09:25,960 --> 02:09:31,750
 this particular variable selection

6100
02:09:28,230 --> 02:09:31,750
 

6101
02:09:28,240 --> 02:09:34,780
 heuristic says well select the variables

6102
02:09:31,740 --> 02:09:34,780
 

6103
02:09:31,750 --> 02:09:36,760
 in the order X 1 X 2 X 3 X 4 X 5 it's a

6104
02:09:34,770 --> 02:09:36,760
 

6105
02:09:34,780 --> 02:09:38,580
 simplest heuristic ever but that

6106
02:09:36,750 --> 02:09:38,580
 

6107
02:09:36,760 --> 02:09:41,080
 actually works extremely well because

6108
02:09:38,570 --> 02:09:41,080
 

6109
02:09:38,580 --> 02:09:43,660
 the the software verification instances

6110
02:09:41,070 --> 02:09:43,660
 

6111
02:09:41,080 --> 02:09:48,810
 have been encoded such that null pointer

6112
02:09:43,650 --> 02:09:48,810
 

6113
02:09:43,660 --> 02:09:52,540
 exceptions are actually in these lower

6114
02:09:48,800 --> 02:09:52,540
 

6115
02:09:48,810 --> 02:09:54,190
 parameters and so in hindsight this

6116
02:09:52,530 --> 02:09:54,190
 

6117
02:09:52,540 --> 02:09:55,540
 makes perfect sense that this variable

6118
02:09:54,180 --> 02:09:55,540
 

6119
02:09:54,190 --> 02:09:58,720
 selection heuristic here works really

6120
02:09:55,530 --> 02:09:58,720
 

6121
02:09:55,540 --> 02:10:00,970
 well and did the opposite heuristic X n

6122
02:09:58,710 --> 02:10:00,970
 

6123
02:09:58,720 --> 02:10:02,770
 X n minus 1 xn minus 2 actually works

6124
02:10:00,960 --> 02:10:02,770
 

6125
02:10:00,970 --> 02:10:04,990
 the worst but the algorithm designer I

6126
02:10:02,760 --> 02:10:04,990
 

6127
02:10:02,770 --> 02:10:06,160
 had no idea ahead of time so this is

6128
02:10:04,980 --> 02:10:06,160
 

6129
02:10:04,990 --> 02:10:08,500
 something that actually fell out of

6130
02:10:06,150 --> 02:10:08,500
 

6131
02:10:06,160 --> 02:10:11,050
 those automated analysis which took

6132
02:10:08,490 --> 02:10:11,050
 

6133
02:10:08,500 --> 02:10:13,630
 seconds after you have all the runtime

6134
02:10:11,040 --> 02:10:13,630
 

6135
02:10:11,050 --> 02:10:17,020
 data so I would really encourage people

6136
02:10:13,620 --> 02:10:17,020
 

6137
02:10:13,630 --> 02:10:18,780
 to to use these tools a lot more there's

6138
02:10:17,010 --> 02:10:18,780
 

6139
02:10:17,020 --> 02:10:22,450
 there's a lot of people working on

6140
02:10:18,770 --> 02:10:22,450
 

6141
02:10:18,780 --> 02:10:24,040
 actually getting you better parameter

6142
02:10:22,440 --> 02:10:24,040
 

6143
02:10:22,450 --> 02:10:26,830
 settings but there's not a lot of people

6144
02:10:24,030 --> 02:10:26,830
 

6145
02:10:24,040 --> 02:10:29,380
 working on actually gaining insights

6146
02:10:26,820 --> 02:10:29,380
 

6147
02:10:26,830 --> 02:10:32,080
 with all the data that you have some

6148
02:10:29,370 --> 02:10:32,080
 

6149
02:10:29,380 --> 02:10:33,670
 other things you can do so far we talked

6150
02:10:32,070 --> 02:10:33,670
 

6151
02:10:32,080 --> 02:10:36,790
 about this global effect you can also

6152
02:10:33,660 --> 02:10:36,790
 

6153
02:10:33,670 --> 02:10:39,010
 look at this locally what is the effect

6154
02:10:36,780 --> 02:10:39,010
 

6155
02:10:36,790 --> 02:10:41,230
 of changing one variable around the

6156
02:10:39,000 --> 02:10:41,230
 

6157
02:10:39,010 --> 02:10:43,180
 incumbent so you take your incumbent and

6158
02:10:41,220 --> 02:10:43,180
 

6159
02:10:41,230 --> 02:10:44,380
 change one parameter at a time and then

6160
02:10:43,170 --> 02:10:44,380
 

6161
02:10:43,180 --> 02:10:47,080
 you can also look at what's the most

6162
02:10:44,370 --> 02:10:47,080
 

6163
02:10:44,380 --> 02:10:51,280
 important parameter here's the same data

6164
02:10:47,070 --> 02:10:51,280
 

6165
02:10:47,080 --> 02:10:53,440
 and here's a the value you get for for

6166
02:10:51,270 --> 02:10:53,440
 

6167
02:10:51,280 --> 02:10:55,600
 this variable selection heuristic again

6168
02:10:53,430 --> 02:10:55,600
 

6169
02:10:53,440 --> 02:10:57,430
 16 as a lowest one and you don't even

6170
02:10:55,590 --> 02:10:57,430
 

6171
02:10:55,600 --> 02:10:59,730
 see it here that's why I plotted it on a

6172
02:10:57,420 --> 02:10:59,730
 

6173
02:10:57,430 --> 02:11:03,040
 log scale here so here you see that

6174
02:10:59,720 --> 02:11:03,040
 

6175
02:10:59,730 --> 02:11:05,860
 performance with this parameter set to

6176
02:11:03,030 --> 02:11:05,860
 

6177
02:11:03,040 --> 02:11:07,810
 16 is well one second about on average

6178
02:11:05,850 --> 02:11:07,810
 

6179
02:11:05,860 --> 02:11:10,450
 for for these instances and if you

6180
02:11:07,800 --> 02:11:10,450
 

6181
02:11:07,810 --> 02:11:12,670
 change that anywhere from 16 well you go

6182
02:11:10,440 --> 02:11:12,670
 

6183
02:11:10,450 --> 02:11:14,290
 up to a hundred seconds so this is by

6184
02:11:12,660 --> 02:11:14,290
 

6185
02:11:12,670 --> 02:11:18,760
 far the most important parameter and

6186
02:11:14,280 --> 02:11:18,760
 

6187
02:11:14,290 --> 02:11:20,350
 again this analysis take seconds you can

6188
02:11:18,750 --> 02:11:20,350
 

6189
02:11:18,760 --> 02:11:23,800
 go one step further and then look at

6190
02:11:20,340 --> 02:11:23,800
 

6191
02:11:20,350 --> 02:11:25,690
 well how do you change all the

6192
02:11:23,790 --> 02:11:25,690
 

6193
02:11:23,800 --> 02:11:27,370
 parameters from the default one to the

6194
02:11:25,680 --> 02:11:27,370
 

6195
02:11:25,690 --> 02:11:28,330
 Ink configured one maybe it's not only

6196
02:11:27,360 --> 02:11:28,330
 

6197
02:11:27,370 --> 02:11:29,560
 one parameter that's

6198
02:11:28,320 --> 02:11:29,560
 

6199
02:11:28,330 --> 02:11:31,630
 important but maybe there's there's

6200
02:11:29,550 --> 02:11:31,630
 

6201
02:11:29,560 --> 02:11:35,470
 several ones in this case it was mostly

6202
02:11:31,620 --> 02:11:35,470
 

6203
02:11:31,630 --> 02:11:39,760
 this one but that that way you can also

6204
02:11:35,460 --> 02:11:39,760
 

6205
02:11:35,470 --> 02:11:41,770
 look at non-locally effect and you can

6206
02:11:39,750 --> 02:11:41,770
 

6207
02:11:39,760 --> 02:11:43,540
 do this on based on the model so again

6208
02:11:41,760 --> 02:11:43,540
 

6209
02:11:41,770 --> 02:11:47,320
 that this doesn't cost you new Ivor's

6210
02:11:43,530 --> 02:11:47,320
 

6211
02:11:43,540 --> 02:11:48,700
 and brands necessarily all right that's

6212
02:11:47,310 --> 02:11:48,700
 

6213
02:11:47,320 --> 02:11:51,040
 all i wanted to say about Parmenter

6214
02:11:48,690 --> 02:11:51,040
 

6215
02:11:48,700 --> 02:11:52,450
 importance the the second related

6216
02:11:51,030 --> 02:11:52,450
 

6217
02:11:51,040 --> 02:11:54,610
 problem to our algorithm configuration

6218
02:11:52,440 --> 02:11:54,610
 

6219
02:11:52,450 --> 02:11:57,790
 that Kevin actually already briefly

6220
02:11:54,600 --> 02:11:57,790
 

6221
02:11:54,610 --> 02:11:59,470
 mentioned is algorithm selection so in

6222
02:11:57,780 --> 02:11:59,470
 

6223
02:11:57,790 --> 02:12:01,540
 this tutorial we'll be focused on

6224
02:11:59,460 --> 02:12:01,540
 

6225
02:11:59,470 --> 02:12:03,970
 finding a single configuration we looked

6226
02:12:01,530 --> 02:12:03,970
 

6227
02:12:01,540 --> 02:12:05,440
 at finding the minimum configuration out

6228
02:12:03,960 --> 02:12:05,440
 

6229
02:12:03,970 --> 02:12:08,620
 of this configuration space

6230
02:12:05,430 --> 02:12:08,620
 

6231
02:12:05,440 --> 02:12:11,920
 well that minimizes this expected metric

6232
02:12:08,610 --> 02:12:11,920
 

6233
02:12:08,620 --> 02:12:13,750
 across instances but instead of that you

6234
02:12:11,910 --> 02:12:13,750
 

6235
02:12:11,920 --> 02:12:15,460
 could also say well how about I use a

6236
02:12:13,740 --> 02:12:15,460
 

6237
02:12:13,750 --> 02:12:16,840
 different configuration for every

6238
02:12:15,450 --> 02:12:16,840
 

6239
02:12:15,460 --> 02:12:19,360
 instance or I use a different algorithm

6240
02:12:16,830 --> 02:12:19,360
 

6241
02:12:16,840 --> 02:12:22,390
 for each instance and then the problem

6242
02:12:19,350 --> 02:12:22,390
 

6243
02:12:19,360 --> 02:12:24,670
 turns into one of function approximation

6244
02:12:22,380 --> 02:12:24,670
 

6245
02:12:22,390 --> 02:12:26,320
 so you try to find the function that

6246
02:12:24,660 --> 02:12:26,320
 

6247
02:12:24,670 --> 02:12:28,750
 map's the instance to a particular

6248
02:12:26,310 --> 02:12:28,750
 

6249
02:12:26,320 --> 02:12:31,630
 configuration or to a particular

6250
02:12:28,740 --> 02:12:31,630
 

6251
02:12:28,750 --> 02:12:33,820
 algorithm that that's kind of a special

6252
02:12:31,620 --> 02:12:33,820
 

6253
02:12:31,630 --> 02:12:35,350
 case and so algorithm selection then

6254
02:12:33,810 --> 02:12:35,350
 

6255
02:12:33,820 --> 02:12:37,360
 then says well you have an instance you

6256
02:12:35,340 --> 02:12:37,360
 

6257
02:12:35,350 --> 02:12:39,160
 compute some features you select some

6258
02:12:37,350 --> 02:12:39,160
 

6259
02:12:37,360 --> 02:12:42,010
 algorithm based on these features and

6260
02:12:39,150 --> 02:12:42,010
 

6261
02:12:39,160 --> 02:12:43,600
 you run that algorithm and that is then

6262
02:12:42,000 --> 02:12:43,600
 

6263
02:12:42,010 --> 02:12:45,670
 a supervised machine learning problem

6264
02:12:43,590 --> 02:12:45,670
 

6265
02:12:43,600 --> 02:12:47,560
 it's a classification problem you can

6266
02:12:45,660 --> 02:12:47,560
 

6267
02:12:45,670 --> 02:12:48,970
 address this by well predicting the

6268
02:12:47,550 --> 02:12:48,970
 

6269
02:12:47,560 --> 02:12:50,860
 performance of each of the algorithms

6270
02:12:48,960 --> 02:12:50,860
 

6271
02:12:48,970 --> 02:12:53,320
 and picking the one predicted to be best

6272
02:12:50,850 --> 02:12:53,320
 

6273
02:12:50,860 --> 02:12:55,420
 or you can cast this as a classification

6274
02:12:53,310 --> 02:12:55,420
 

6275
02:12:53,320 --> 02:12:57,850
 problem or is it cost-sensitive

6276
02:12:55,410 --> 02:12:57,850
 

6277
02:12:55,420 --> 02:12:59,800
 classification problem and all of this

6278
02:12:57,840 --> 02:12:59,800
 

6279
02:12:57,850 --> 02:13:01,750
 has been done in the literature and in

6280
02:12:59,790 --> 02:13:01,750
 

6281
02:12:59,800 --> 02:13:03,520
 fact you can even use algorithm

6282
02:13:01,740 --> 02:13:03,520
 

6283
02:13:01,750 --> 02:13:04,780
 configuration in order to search over

6284
02:13:03,510 --> 02:13:04,780
 

6285
02:13:03,520 --> 02:13:11,140
 the space of different algorithm

6286
02:13:04,770 --> 02:13:11,140
 

6287
02:13:04,780 --> 02:13:12,820
 selectors and the reason I tell you

6288
02:13:11,130 --> 02:13:12,820
 

6289
02:13:11,140 --> 02:13:14,410
 about this is that algorithm selection

6290
02:13:12,810 --> 02:13:14,410
 

6291
02:13:12,820 --> 02:13:16,420
 is actually next to address and

6292
02:13:14,400 --> 02:13:16,420
 

6293
02:13:14,410 --> 02:13:19,570
 configuration really a key component in

6294
02:13:16,410 --> 02:13:19,570
 

6295
02:13:16,420 --> 02:13:22,030
 having an approach that works well on

6296
02:13:19,560 --> 02:13:22,030
 

6297
02:13:19,570 --> 02:13:23,560
 heterogeneous instances so if you want

6298
02:13:22,020 --> 02:13:23,560
 

6299
02:13:22,030 --> 02:13:25,540
 to win a set competition there's a lot

6300
02:13:23,550 --> 02:13:25,540
 

6301
02:13:23,560 --> 02:13:27,520
 of different instances there it's not

6302
02:13:25,530 --> 02:13:27,520
 

6303
02:13:25,540 --> 02:13:29,260
 very homogeneous you don't just want to

6304
02:13:27,510 --> 02:13:29,260
 

6305
02:13:27,520 --> 02:13:31,060
 have a single configuration you don't

6306
02:13:29,250 --> 02:13:31,060
 

6307
02:13:29,260 --> 02:13:32,620
 want to just have a single solver but

6308
02:13:31,050 --> 02:13:32,620
 

6309
02:13:31,060 --> 02:13:35,290
 there's different solvers that work well

6310
02:13:32,610 --> 02:13:35,290
 

6311
02:13:32,620 --> 02:13:37,270
 on different instances and this here's

6312
02:13:35,280 --> 02:13:37,270
 

6313
02:13:35,290 --> 02:13:40,680
 an example from the Sat 2012 challenge

6314
02:13:37,260 --> 02:13:40,680
 

6315
02:13:37,270 --> 02:13:43,980
 which was won by Zed Zilla that that I'm

6316
02:13:40,670 --> 02:13:43,980
 

6317
02:13:40,680 --> 02:13:45,990
 mentioned earlier and this basically

6318
02:13:43,970 --> 02:13:45,990
 

6319
02:13:43,980 --> 02:13:47,730
 just said while I'd take all the all the

6320
02:13:45,980 --> 02:13:47,730
 

6321
02:13:45,990 --> 02:13:49,470
 algorithms from the last challenge and

6322
02:13:47,720 --> 02:13:49,470
 

6323
02:13:47,730 --> 02:13:50,670
 predict based on the features which one

6324
02:13:49,460 --> 02:13:50,670
 

6325
02:13:49,470 --> 02:13:53,010
 is going to be best and I'm going to run

6326
02:13:50,660 --> 02:13:53,010
 

6327
02:13:50,670 --> 02:13:54,840
 that that's what it's doing at the core

6328
02:13:53,000 --> 02:13:54,840
 

6329
02:13:53,010 --> 02:13:56,400
 there's some bells and whistles but but

6330
02:13:54,830 --> 02:13:56,400
 

6331
02:13:54,840 --> 02:13:59,850
 this is really the most important part

6332
02:13:56,390 --> 02:13:59,850
 

6333
02:13:56,400 --> 02:14:02,730
 behind it and notice how all the single

6334
02:13:59,840 --> 02:14:02,730
 

6335
02:13:59,850 --> 02:14:04,740
 solvers they're down here and the the

6336
02:14:02,720 --> 02:14:04,740
 

6337
02:14:02,730 --> 02:14:06,360
 best single solver and the second single

6338
02:14:04,730 --> 02:14:06,360
 

6339
02:14:04,740 --> 02:14:09,480
 solver differ by like three instances

6340
02:14:06,350 --> 02:14:09,480
 

6341
02:14:06,360 --> 02:14:11,610
 soft and algorithm selection on top of

6342
02:14:09,470 --> 02:14:11,610
 

6343
02:14:09,480 --> 02:14:13,290
 that has another fifty to sixty

6344
02:14:11,600 --> 02:14:13,290
 

6345
02:14:11,610 --> 02:14:15,990
 instances that are solved so this is

6346
02:14:13,280 --> 02:14:15,990
 

6347
02:14:13,290 --> 02:14:17,610
 really a very substantial advance on the

6348
02:14:15,980 --> 02:14:17,610
 

6349
02:14:15,990 --> 02:14:20,220
 state-of-the-art that you can get by

6350
02:14:17,600 --> 02:14:20,220
 

6351
02:14:17,610 --> 02:14:24,020
 picking the right algorithm based on the

6352
02:14:20,210 --> 02:14:24,020
 

6353
02:14:20,220 --> 02:14:24,020
 instance features using machine learning

6354
02:14:24,280 --> 02:14:24,280
 

6355
02:14:24,290 --> 02:14:27,870
 so I talked about algorithm

6356
02:14:26,450 --> 02:14:27,870
 

6357
02:14:26,460 --> 02:14:29,850
 configuration in the whole tutorial

6358
02:14:27,860 --> 02:14:29,850
 

6359
02:14:27,870 --> 02:14:31,950
 algorithm selection now briefly both of

6360
02:14:29,840 --> 02:14:31,950
 

6361
02:14:29,850 --> 02:14:34,320
 them have advantages and disadvantages

6362
02:14:31,940 --> 02:14:34,320
 

6363
02:14:31,950 --> 02:14:36,540
 so algorithm configuration finds great

6364
02:14:34,310 --> 02:14:36,540
 

6365
02:14:34,320 --> 02:14:38,730
 configurations but they only work well

6366
02:14:36,530 --> 02:14:38,730
 

6367
02:14:36,540 --> 02:14:39,810
 on average across some instances and not

6368
02:14:38,720 --> 02:14:39,810
 

6369
02:14:38,730 --> 02:14:42,120
 not very well for heterogeneous

6370
02:14:39,800 --> 02:14:42,120
 

6371
02:14:39,810 --> 02:14:45,450
 instances whereas iverson selection

6372
02:14:42,110 --> 02:14:45,450
 

6373
02:14:42,120 --> 02:14:47,880
 usually only uses a fixed set of conf

6374
02:14:45,440 --> 02:14:47,880
 

6375
02:14:45,450 --> 02:14:50,820
 algorithms and then picks the one from

6376
02:14:47,870 --> 02:14:50,820
 

6377
02:14:47,880 --> 02:14:52,830
 from that set that is best and you can

6378
02:14:50,810 --> 02:14:52,830
 

6379
02:14:50,820 --> 02:14:56,300
 put the two together by well actually

6380
02:14:52,820 --> 02:14:56,300
 

6381
02:14:52,830 --> 02:14:58,590
 using configuration in order to create

6382
02:14:56,290 --> 02:14:58,590
 

6383
02:14:56,300 --> 02:15:00,390
 solvers that you put into outers in

6384
02:14:58,580 --> 02:15:00,390
 

6385
02:14:58,590 --> 02:15:03,090
 selection and Kevin already alluded to

6386
02:15:00,380 --> 02:15:03,090
 

6387
02:15:00,390 --> 02:15:06,300
 Hydra in the beginning which does is

6388
02:15:03,080 --> 02:15:06,300
 

6389
02:15:03,090 --> 02:15:09,470
 using submodule arity adding one

6390
02:15:06,290 --> 02:15:09,470
 

6391
02:15:06,300 --> 02:15:13,530
 algorithm at a time that improves on the

6392
02:15:09,460 --> 02:15:13,530
 

6393
02:15:09,470 --> 02:15:16,590
 not-so-well instances most not not so

6394
02:15:13,520 --> 02:15:16,590
 

6395
02:15:13,530 --> 02:15:18,630
 well solved instances most and you can

6396
02:15:16,580 --> 02:15:18,630
 

6397
02:15:16,590 --> 02:15:20,340
 also do this differently you could also

6398
02:15:18,620 --> 02:15:20,340
 

6399
02:15:18,630 --> 02:15:23,070
 just cluster your instances and run

6400
02:15:20,330 --> 02:15:23,070
 

6401
02:15:20,340 --> 02:15:26,460
 configuration for each cluster or there

6402
02:15:23,060 --> 02:15:26,460
 

6403
02:15:23,070 --> 02:15:27,020
 there's other methods for doing this all

6404
02:15:26,450 --> 02:15:27,020
 

6405
02:15:26,460 --> 02:15:30,120
 right

6406
02:15:27,010 --> 02:15:30,120
 

6407
02:15:27,020 --> 02:15:31,770
 one problem setting that that's somewhat

6408
02:15:30,110 --> 02:15:31,770
 

6409
02:15:30,120 --> 02:15:34,500
 related to our original selection in the

6410
02:15:31,760 --> 02:15:34,500
 

6411
02:15:31,770 --> 02:15:37,380
 sense that well different configurations

6412
02:15:34,490 --> 02:15:37,380
 

6413
02:15:34,500 --> 02:15:42,600
 work better for different instance

6414
02:15:37,370 --> 02:15:42,600
 

6415
02:15:37,380 --> 02:15:45,000
 distributions is that if you have

6416
02:15:42,590 --> 02:15:45,000
 

6417
02:15:42,600 --> 02:15:46,950
 actually run configuration on different

6418
02:15:44,990 --> 02:15:46,950
 

6419
02:15:45,000 --> 02:15:49,740
 instance distributions in the past then

6420
02:15:46,940 --> 02:15:49,740
 

6421
02:15:46,950 --> 02:15:51,780
 you would want to use that knowledge in

6422
02:15:49,730 --> 02:15:51,780
 

6423
02:15:49,740 --> 02:15:53,760
 order to do well on the next instance

6424
02:15:51,770 --> 02:15:53,760
 

6425
02:15:51,780 --> 02:15:54,469
 distribution if you've configured cplex

6426
02:15:53,750 --> 02:15:54,469
 

6427
02:15:53,760 --> 02:15:56,989
 100

6428
02:15:54,459 --> 02:15:56,989
 

6429
02:15:54,469 --> 02:15:58,369
 for different companies then you

6430
02:15:56,979 --> 02:15:58,369
 

6431
02:15:56,989 --> 02:16:00,499
 actually learn something about which

6432
02:15:58,359 --> 02:16:00,499
 

6433
02:15:58,369 --> 02:16:02,090
 parameters are important and and and

6434
02:16:00,489 --> 02:16:02,090
 

6435
02:16:00,499 --> 02:16:03,860
 that's what humans do and we would

6436
02:16:02,080 --> 02:16:03,860
 

6437
02:16:02,090 --> 02:16:06,170
 actually like to also do this in our

6438
02:16:03,850 --> 02:16:06,170
 

6439
02:16:03,860 --> 02:16:08,329
 algorithms so there's two options you

6440
02:16:06,160 --> 02:16:08,329
 

6441
02:16:06,170 --> 02:16:09,979
 could use for that you could either just

6442
02:16:08,319 --> 02:16:09,979
 

6443
02:16:08,329 --> 02:16:12,349
 start from the strong previous

6444
02:16:09,969 --> 02:16:12,349
 

6445
02:16:09,979 --> 02:16:14,380
 configurations or you could reuse some

6446
02:16:12,339 --> 02:16:14,380
 

6447
02:16:12,349 --> 02:16:16,760
 of your previous models and weight them

6448
02:16:14,370 --> 02:16:16,760
 

6449
02:16:14,380 --> 02:16:18,829
 according to how useful they are to your

6450
02:16:16,750 --> 02:16:18,829
 

6451
02:16:16,760 --> 02:16:20,269
 new instance distribution and it turns

6452
02:16:18,819 --> 02:16:20,269
 

6453
02:16:18,829 --> 02:16:23,479
 out that the combination of these two

6454
02:16:20,259 --> 02:16:23,479
 

6455
02:16:20,269 --> 02:16:25,849
 actually works best and can yield really

6456
02:16:23,469 --> 02:16:25,849
 

6457
02:16:23,479 --> 02:16:29,809
 large speed ups over I'm smack a hundred

6458
02:16:25,839 --> 02:16:29,809
 

6459
02:16:25,849 --> 02:16:31,670
 folder so if the the same similar

6460
02:16:29,799 --> 02:16:31,670
 

6461
02:16:29,809 --> 02:16:34,429
 configuration worked well as in your

6462
02:16:31,660 --> 02:16:34,429
 

6463
02:16:31,670 --> 02:16:36,800
 previous instance distributions and if

6464
02:16:34,419 --> 02:16:36,800
 

6465
02:16:34,429 --> 02:16:38,870
 they don't then it doesn't actually slow

6466
02:16:36,790 --> 02:16:38,870
 

6467
02:16:36,800 --> 02:16:40,429
 you down a lot and then you can learn to

6468
02:16:38,860 --> 02:16:40,429
 

6469
02:16:38,870 --> 02:16:43,130
 kind of ignore these previous models

6470
02:16:40,419 --> 02:16:43,130
 

6471
02:16:40,429 --> 02:16:44,510
 because they're not helpful so in in

6472
02:16:43,120 --> 02:16:44,510
 

6473
02:16:43,130 --> 02:16:46,609
 this case study on average we got

6474
02:16:44,500 --> 02:16:46,609
 

6475
02:16:44,510 --> 02:16:48,410
 something like fourfold speed ups by by

6476
02:16:46,599 --> 02:16:48,410
 

6477
02:16:46,609 --> 02:16:53,330
 using past experience from algorithm

6478
02:16:48,400 --> 02:16:53,330
 

6479
02:16:48,410 --> 02:16:55,609
 configuration all right next up is

6480
02:16:53,320 --> 02:16:55,609
 

6481
02:16:53,330 --> 02:16:57,529
 learning entrant learning of community

6482
02:16:55,599 --> 02:16:57,529
 

6483
02:16:55,609 --> 02:16:59,809
 all solvers and at this point I'd like

6484
02:16:57,519 --> 02:16:59,809
 

6485
02:16:57,529 --> 02:17:02,420
 to give a shout out to to this very nice

6486
02:16:59,799 --> 02:17:02,420
 

6487
02:16:59,809 --> 02:17:05,809
 recent survey article by yoshua bengio

6488
02:17:02,410 --> 02:17:05,809
 

6489
02:17:02,420 --> 02:17:08,059
 and Rhea Lodi and Antron Provost they

6490
02:17:05,799 --> 02:17:08,059
 

6491
02:17:05,809 --> 02:17:10,599
 define three different categories of how

6492
02:17:08,049 --> 02:17:10,599
 

6493
02:17:08,059 --> 02:17:13,939
 you can combine machine learning and

6494
02:17:10,589 --> 02:17:13,939
 

6495
02:17:10,599 --> 02:17:15,469
 operation research which we would just

6496
02:17:13,929 --> 02:17:15,469
 

6497
02:17:13,939 --> 02:17:16,130
 hear call coming at rural optimization

6498
02:17:15,459 --> 02:17:16,130
 

6499
02:17:15,469 --> 02:17:20,660
 algorithms

6500
02:17:16,120 --> 02:17:20,660
 

6501
02:17:16,130 --> 02:17:22,639
 the two are quite similar and what what

6502
02:17:20,650 --> 02:17:22,639
 

6503
02:17:20,660 --> 02:17:26,420
 this tutorial focused on is what they

6504
02:17:22,629 --> 02:17:26,420
 

6505
02:17:22,639 --> 02:17:27,800
 call machine learning or men's community

6506
02:17:26,410 --> 02:17:27,800
 

6507
02:17:26,420 --> 02:17:32,719
 optimization with valuable information

6508
02:17:27,790 --> 02:17:32,719
 

6509
02:17:27,800 --> 02:17:36,410
 so we find parameter settings of this

6510
02:17:32,709 --> 02:17:36,410
 

6511
02:17:32,719 --> 02:17:38,750
 well our solver we find we look at

6512
02:17:36,400 --> 02:17:38,750
 

6513
02:17:36,410 --> 02:17:41,809
 instances and pick the right or solver

6514
02:17:38,740 --> 02:17:41,809
 

6515
02:17:38,750 --> 02:17:44,510
 etc that that's really what the focus of

6516
02:17:41,799 --> 02:17:44,510
 

6517
02:17:41,809 --> 02:17:46,760
 this tutorial was and there's two other

6518
02:17:44,500 --> 02:17:46,760
 

6519
02:17:44,510 --> 02:17:48,559
 parts um that they talk about namely

6520
02:17:46,750 --> 02:17:48,559
 

6521
02:17:46,760 --> 02:17:49,040
 machine learning ax alone to solve the

6522
02:17:48,549 --> 02:17:49,040
 

6523
02:17:48,559 --> 02:17:51,349
 problem

6524
02:17:49,030 --> 02:17:51,349
 

6525
02:17:49,040 --> 02:17:54,380
 so that's entrant learning and then a

6526
02:17:51,339 --> 02:17:54,380
 

6527
02:17:51,349 --> 02:17:56,870
 more integrated approach where the or

6528
02:17:54,370 --> 02:17:56,870
 

6529
02:17:54,380 --> 02:17:58,729
 our solver iteratively iteratively calls

6530
02:17:56,860 --> 02:17:58,729
 

6531
02:17:56,870 --> 02:18:00,830
 a machine learning model in order to

6532
02:17:58,719 --> 02:18:00,830
 

6533
02:17:58,729 --> 02:18:02,330
 make decisions so so this is more than

6534
02:18:00,820 --> 02:18:02,330
 

6535
02:18:00,830 --> 02:18:06,139
 trend learning and this is more the

6536
02:18:02,320 --> 02:18:06,139
 

6537
02:18:02,330 --> 02:18:08,390
 deeper enforcement learning so we'll

6538
02:18:06,129 --> 02:18:08,390
 

6539
02:18:06,139 --> 02:18:11,510
 start with and trent learning

6540
02:18:08,380 --> 02:18:11,510
 

6541
02:18:08,390 --> 02:18:14,440
 now it's a point where where if you're

6542
02:18:11,500 --> 02:18:14,440
 

6543
02:18:11,510 --> 02:18:18,411
 deep learner finally I'm talking to you

6544
02:18:14,430 --> 02:18:18,411
 

6545
02:18:14,440 --> 02:18:20,541
 so here you want to the end-to-end

6546
02:18:18,401 --> 02:18:20,541
 

6547
02:18:18,411 --> 02:18:22,730
 learning of algorithms in general is

6548
02:18:20,531 --> 02:18:22,730
 

6549
02:18:20,541 --> 02:18:25,551
 about well you learn a neural network

6550
02:18:22,720 --> 02:18:25,551
 

6551
02:18:22,730 --> 02:18:27,260
 with some parameters Phi that define an

6552
02:18:25,541 --> 02:18:27,260
 

6553
02:18:25,551 --> 02:18:28,940
 algorithm so that Network defines your

6554
02:18:27,250 --> 02:18:28,940
 

6555
02:18:27,260 --> 02:18:30,650
 algorithm and the network parameters are

6556
02:18:28,930 --> 02:18:30,650
 

6557
02:18:28,940 --> 02:18:32,480
 trained to optimize your true objective

6558
02:18:30,640 --> 02:18:32,480
 

6559
02:18:30,650 --> 02:18:34,400
 and your query that algorithm that

6560
02:18:32,470 --> 02:18:34,400
 

6561
02:18:32,480 --> 02:18:37,100
 network every time that you want to take

6562
02:18:34,390 --> 02:18:37,100
 

6563
02:18:34,400 --> 02:18:38,751
 an action one example here is learning

6564
02:18:37,090 --> 02:18:38,751
 

6565
02:18:37,100 --> 02:18:40,820
 to learn with gradient descent or

6566
02:18:38,741 --> 02:18:40,820
 

6567
02:18:38,751 --> 02:18:43,161
 learning to optimize so in both of these

6568
02:18:40,810 --> 02:18:43,161
 

6569
02:18:40,820 --> 02:18:45,171
 you parameterize an update rule for your

6570
02:18:43,151 --> 02:18:45,171
 

6571
02:18:43,161 --> 02:18:49,251
 base level neural network parameters W

6572
02:18:45,161 --> 02:18:49,251
 

6573
02:18:45,171 --> 02:18:52,280
 so something like SGD or atom etc so you

6574
02:18:49,241 --> 02:18:52,280
 

6575
02:18:49,251 --> 02:18:54,411
 have your parameters you add some

6576
02:18:52,270 --> 02:18:54,411
 

6577
02:18:52,280 --> 02:18:56,450
 function of your gradient and this

6578
02:18:54,401 --> 02:18:56,450
 

6579
02:18:54,411 --> 02:18:59,150
 function is parameterized by fire and

6580
02:18:56,440 --> 02:18:59,150
 

6581
02:18:56,450 --> 02:19:03,051
 you just optimize these files in order

6582
02:18:59,140 --> 02:19:03,051
 

6583
02:18:59,150 --> 02:19:04,911
 to learn a gradient update rule and

6584
02:19:03,041 --> 02:19:04,911
 

6585
02:19:03,051 --> 02:19:07,341
 there's a lot of other examples like

6586
02:19:04,901 --> 02:19:07,341
 

6587
02:19:04,911 --> 02:19:08,600
 learning rate in free optimizers update

6588
02:19:07,331 --> 02:19:08,600
 

6589
02:19:07,341 --> 02:19:11,121
 rule learning unsupervised learning

6590
02:19:08,590 --> 02:19:11,121
 

6591
02:19:08,600 --> 02:19:13,581
 rules something like alpha zero actually

6592
02:19:11,111 --> 02:19:13,581
 

6593
02:19:11,121 --> 02:19:15,260
 falls into this category because well

6594
02:19:13,571 --> 02:19:15,260
 

6595
02:19:13,581 --> 02:19:19,161
 the deep network actually defines an

6596
02:19:15,250 --> 02:19:19,161
 

6597
02:19:15,260 --> 02:19:22,760
 algorithm and so this this spirit of

6598
02:19:19,151 --> 02:19:22,760
 

6599
02:19:19,161 --> 02:19:25,280
 coming up with algorithms encoded by

6600
02:19:22,750 --> 02:19:25,280
 

6601
02:19:22,760 --> 02:19:27,621
 neural networks can be used for also

6602
02:19:25,270 --> 02:19:27,621
 

6603
02:19:25,280 --> 02:19:30,081
 learning community optimization solvers

6604
02:19:27,611 --> 02:19:30,081
 

6605
02:19:27,621 --> 02:19:31,881
 in particular so there's there's been

6606
02:19:30,071 --> 02:19:31,881
 

6607
02:19:30,081 --> 02:19:34,900
 work on learning to solve Euclidean TSP

6608
02:19:31,871 --> 02:19:34,900
 

6609
02:19:31,881 --> 02:19:38,421
 s there's been this very nice paper by

6610
02:19:34,890 --> 02:19:38,421
 

6611
02:19:34,900 --> 02:19:41,360
 albinius colleagues on pointer networks

6612
02:19:38,411 --> 02:19:41,360
 

6613
02:19:38,421 --> 02:19:43,841
 they use an RNN to encode your TSP and

6614
02:19:41,350 --> 02:19:43,841
 

6615
02:19:41,360 --> 02:19:46,671
 then another RN n was an attention like

6616
02:19:43,831 --> 02:19:46,671
 

6617
02:19:43,841 --> 02:19:49,490
 mechanism that predicts a probability

6618
02:19:46,661 --> 02:19:49,490
 

6619
02:19:46,671 --> 02:19:50,990
 distribution for which know to take next

6620
02:19:49,480 --> 02:19:50,990
 

6621
02:19:49,490 --> 02:19:53,721
 and the whole thing is trained with

6622
02:19:50,980 --> 02:19:53,721
 

6623
02:19:50,990 --> 02:19:55,190
 supervised learning so you have some TSP

6624
02:19:53,711 --> 02:19:55,190
 

6625
02:19:53,721 --> 02:19:56,990
 instances actually a lot of TSP

6626
02:19:55,180 --> 02:19:56,990
 

6627
02:19:55,190 --> 02:20:00,291
 instances that you solve optimally and

6628
02:19:56,980 --> 02:20:00,291
 

6629
02:19:56,990 --> 02:20:03,190
 then you train your your whole model and

6630
02:20:00,281 --> 02:20:03,190
 

6631
02:20:00,291 --> 02:20:08,030
 to end in order to mimic what what these

6632
02:20:03,180 --> 02:20:08,030
 

6633
02:20:03,190 --> 02:20:09,860
 optimal solvers do follow-up work has

6634
02:20:08,020 --> 02:20:09,860
 

6635
02:20:08,030 --> 02:20:11,391
 looked at a reinforcement learning to

6636
02:20:09,850 --> 02:20:11,391
 

6637
02:20:09,860 --> 02:20:14,121
 actually avoid the need for having

6638
02:20:11,381 --> 02:20:14,121
 

6639
02:20:11,391 --> 02:20:15,650
 optimal solutions to train with because

6640
02:20:14,111 --> 02:20:15,650
 

6641
02:20:14,121 --> 02:20:19,041
 if you already have an optimal solver

6642
02:20:15,640 --> 02:20:19,041
 

6643
02:20:15,650 --> 02:20:20,631
 well it's kind of not as needed to come

6644
02:20:19,031 --> 02:20:20,631
 

6645
02:20:19,041 --> 02:20:22,370
 up with with a solver for this so you

6646
02:20:20,621 --> 02:20:22,370
 

6647
02:20:20,631 --> 02:20:23,930
 you don't need to have an optimal

6648
02:20:22,360 --> 02:20:23,930
 

6649
02:20:22,370 --> 02:20:27,290
 solver to start with here anymore and

6650
02:20:23,920 --> 02:20:27,290
 

6651
02:20:23,930 --> 02:20:28,851
 actually call it al you look at some

6652
02:20:27,280 --> 02:20:28,851
 

6653
02:20:27,290 --> 02:20:32,210
 problem formulations for which there is

6654
02:20:28,841 --> 02:20:32,210
 

6655
02:20:28,851 --> 02:20:34,101
 no optimal solver and you can also

6656
02:20:32,200 --> 02:20:34,101
 

6657
02:20:32,210 --> 02:20:35,780
 directly predict the permutation or

6658
02:20:34,091 --> 02:20:35,780
 

6659
02:20:34,101 --> 02:20:38,540
 learning greedy heuristic to choose the

6660
02:20:35,770 --> 02:20:38,540
 

6661
02:20:35,780 --> 02:20:41,061
 next node there's also been work on

6662
02:20:38,530 --> 02:20:41,061
 

6663
02:20:38,540 --> 02:20:42,920
 learning to solve sat this neuro set

6664
02:20:41,051 --> 02:20:42,920
 

6665
02:20:41,061 --> 02:20:46,250
 approach is actually also at this

6666
02:20:42,910 --> 02:20:46,250
 

6667
02:20:42,920 --> 02:20:48,650
 conference there Oh No there was a I CLE

6668
02:20:46,240 --> 02:20:48,650
 

6669
02:20:46,250 --> 02:20:51,200
 us at night I said this conference neuro

6670
02:20:48,640 --> 02:20:51,200
 

6671
02:20:48,650 --> 02:20:52,880
 said uses a permutation invariant graph

6672
02:20:51,190 --> 02:20:52,880
 

6673
02:20:51,200 --> 02:20:55,610
 neural network and then learns a message

6674
02:20:52,870 --> 02:20:55,610
 

6675
02:20:52,880 --> 02:20:58,240
 passing algorithm to solve new instances

6676
02:20:55,600 --> 02:20:58,240
 

6677
02:20:55,610 --> 02:21:00,170
 and so it's an entry and network that

6678
02:20:58,230 --> 02:21:00,170
 

6679
02:20:58,240 --> 02:21:02,811
 solves new instances it's not

6680
02:21:00,160 --> 02:21:02,811
 

6681
02:21:00,170 --> 02:21:06,170
 necessarily faster than a traditional

6682
02:21:02,801 --> 02:21:06,170
 

6683
02:21:02,811 --> 02:21:10,460
 solver it's actually fairly slow but it

6684
02:21:06,160 --> 02:21:10,460
 

6685
02:21:06,170 --> 02:21:12,920
 learned end to end then sat net at this

6686
02:21:10,450 --> 02:21:12,920
 

6687
02:21:10,460 --> 02:21:15,380
 ICML is actually differentiable

6688
02:21:12,910 --> 02:21:15,380
 

6689
02:21:12,920 --> 02:21:17,390
 approximate max at solver that you can

6690
02:21:15,370 --> 02:21:17,390
 

6691
02:21:15,380 --> 02:21:20,061
 combine with Sigma basically as a layer

6692
02:21:17,380 --> 02:21:20,061
 

6693
02:21:17,390 --> 02:21:21,710
 in a neural network and combine it was a

6694
02:21:20,051 --> 02:21:21,710
 

6695
02:21:20,061 --> 02:21:24,021
 standard deep learning pipeline to for

6696
02:21:21,700 --> 02:21:24,021
 

6697
02:21:21,710 --> 02:21:25,790
 example solve visual pseudocode tasks so

6698
02:21:24,011 --> 02:21:25,790
 

6699
02:21:24,021 --> 02:21:28,490
 you get a picture of a pseudo current

6700
02:21:25,780 --> 02:21:28,490
 

6701
02:21:25,790 --> 02:21:31,521
 and need the logic behind filling it out

6702
02:21:28,480 --> 02:21:31,521
 

6703
02:21:28,490 --> 02:21:35,660
 so that that's very nice and modular and

6704
02:21:31,511 --> 02:21:35,660
 

6705
02:21:31,521 --> 02:21:36,860
 then there's work by Kevin I'm Kevin's

6706
02:21:35,650 --> 02:21:36,860
 

6707
02:21:35,660 --> 02:21:39,710
 group on learning to predict

6708
02:21:36,850 --> 02:21:39,710
 

6709
02:21:36,860 --> 02:21:41,990
 satisfiability from the raw instances so

6710
02:21:39,700 --> 02:21:41,990
 

6711
02:21:39,710 --> 02:21:44,090
 they also use some exchangeable deep

6712
02:21:41,980 --> 02:21:44,090
 

6713
02:21:41,990 --> 02:21:46,790
 neural network to take care of the

6714
02:21:44,080 --> 02:21:46,790
 

6715
02:21:44,090 --> 02:21:48,980
 permutation invariance and even at the

6716
02:21:46,780 --> 02:21:48,980
 

6717
02:21:46,790 --> 02:21:50,630
 face transition region they can predict

6718
02:21:48,970 --> 02:21:50,630
 

6719
02:21:48,980 --> 02:21:52,910
 was eighty percent accuracy where

6720
02:21:50,620 --> 02:21:52,910
 

6721
02:21:50,630 --> 02:21:54,860
 previously this this worth was sought to

6722
02:21:52,900 --> 02:21:54,860
 

6723
02:21:52,910 --> 02:21:59,540
 be actually just very hard to predict

6724
02:21:54,850 --> 02:21:59,540
 

6725
02:21:54,860 --> 02:22:01,101
 this very accurately right so that

6726
02:21:59,530 --> 02:22:01,101
 

6727
02:21:59,540 --> 02:22:02,690
 that's it for the entrant learning and

6728
02:22:01,091 --> 02:22:02,690
 

6729
02:22:01,101 --> 02:22:06,430
 the last part is integrating machine

6730
02:22:02,680 --> 02:22:06,430
 

6731
02:22:02,690 --> 02:22:09,760
 learning and criminal optimization again

6732
02:22:06,420 --> 02:22:09,760
 

6733
02:22:06,430 --> 02:22:13,580
 alluding to this picture we're here now

6734
02:22:09,750 --> 02:22:13,580
 

6735
02:22:09,760 --> 02:22:16,000
 so now we want to integrate the machine

6736
02:22:13,570 --> 02:22:16,000
 

6737
02:22:13,580 --> 02:22:18,830
 learning into or algorithm more closely

6738
02:22:15,990 --> 02:22:18,830
 

6739
02:22:16,000 --> 02:22:20,570
 one approach that that's been done

6740
02:22:18,820 --> 02:22:20,570
 

6741
02:22:18,830 --> 02:22:23,061
 almost twenty years ago already is to

6742
02:22:20,560 --> 02:22:23,061
 

6743
02:22:20,570 --> 02:22:25,190
 learn dynamic restart policy policies so

6744
02:22:23,051 --> 02:22:25,190
 

6745
02:22:23,061 --> 02:22:27,080
 for some randomized algorithm you could

6746
02:22:25,180 --> 02:22:27,080
 

6747
02:22:25,190 --> 02:22:28,880
 run it for an initial observation period

6748
02:22:27,070 --> 02:22:28,880
 

6749
02:22:27,080 --> 02:22:30,920
 and then predict whether this run is

6750
02:22:28,870 --> 02:22:30,920
 

6751
02:22:28,880 --> 02:22:33,170
 actually a good run or bad run and if

6752
02:22:30,910 --> 02:22:33,170
 

6753
02:22:30,920 --> 02:22:35,000
 it's a good run then you want to keep it

6754
02:22:33,160 --> 02:22:35,000
 

6755
02:22:33,170 --> 02:22:36,470
 running and if it's bad meaning it's

6756
02:22:34,990 --> 02:22:36,470
 

6757
02:22:35,000 --> 02:22:38,720
 probably going to take four

6758
02:22:36,460 --> 02:22:38,720
 

6759
02:22:36,470 --> 02:22:43,521
 then you want to cut it off and restart

6760
02:22:38,710 --> 02:22:43,521
 

6761
02:22:38,720 --> 02:22:47,120
 and yeah so so this this falls into this

6762
02:22:43,511 --> 02:22:47,120
 

6763
02:22:43,521 --> 02:22:50,271
 augmentation period because you you do

6764
02:22:47,110 --> 02:22:50,271
 

6765
02:22:47,120 --> 02:22:53,811
 some decisions online while the

6766
02:22:50,261 --> 02:22:53,811
 

6767
02:22:50,271 --> 02:22:55,610
 algorithm is running you can also build

6768
02:22:53,801 --> 02:22:55,610
 

6769
02:22:53,811 --> 02:22:57,350
 dynamic algorithm portfolios where you

6770
02:22:55,600 --> 02:22:57,350
 

6771
02:22:55,610 --> 02:23:00,170
 have several algorithms that are running

6772
02:22:57,340 --> 02:23:00,170
 

6773
02:22:57,350 --> 02:23:02,180
 in parallel and online you decide about

6774
02:23:00,160 --> 02:23:02,180
 

6775
02:23:00,170 --> 02:23:04,010
 time shares that that you give to each

6776
02:23:02,170 --> 02:23:04,010
 

6777
02:23:02,180 --> 02:23:06,830
 of these algorithms depending on how

6778
02:23:04,000 --> 02:23:06,830
 

6779
02:23:04,010 --> 02:23:10,070
 successful they are in optimizing your

6780
02:23:06,820 --> 02:23:10,070
 

6781
02:23:06,830 --> 02:23:12,530
 your objective function and you could

6782
02:23:10,060 --> 02:23:12,530
 

6783
02:23:10,070 --> 02:23:14,920
 also learn in which search nodes to

6784
02:23:12,520 --> 02:23:14,920
 

6785
02:23:12,530 --> 02:23:17,390
 apply heuristics so so in

6786
02:23:14,910 --> 02:23:17,390
 

6787
02:23:14,920 --> 02:23:20,150
 branch-and-bound primal heuristics can

6788
02:23:17,380 --> 02:23:20,150
 

6789
02:23:17,390 --> 02:23:21,830
 find feasible solutions but they're too

6790
02:23:20,140 --> 02:23:21,830
 

6791
02:23:20,150 --> 02:23:23,540
 expensive to apply everywhere and

6792
02:23:21,820 --> 02:23:23,540
 

6793
02:23:21,830 --> 02:23:25,280
 there's there's lots of different

6794
02:23:23,530 --> 02:23:25,280
 

6795
02:23:23,540 --> 02:23:27,980
 heuristics and it's very unclear when

6796
02:23:25,270 --> 02:23:27,980
 

6797
02:23:25,280 --> 02:23:31,100
 one should be applied and and it's just

6798
02:23:27,970 --> 02:23:31,100
 

6799
02:23:27,980 --> 02:23:36,260
 all all hand designed so far and you can

6800
02:23:31,090 --> 02:23:36,260
 

6801
02:23:31,100 --> 02:23:38,600
 also learn to apply learn when to apply

6802
02:23:36,250 --> 02:23:38,600
 

6803
02:23:36,260 --> 02:23:43,780
 the heuristic in order to optimize your

6804
02:23:38,590 --> 02:23:43,780
 

6805
02:23:38,600 --> 02:23:43,780
 solution as efficiently as possible

6806
02:23:44,200 --> 02:23:44,200
 

6807
02:23:44,210 --> 02:23:48,650
 finally now we're moving on to some

6808
02:23:46,180 --> 02:23:48,650
 

6809
02:23:46,190 --> 02:23:51,830
 reinforcement learning um formulations

6810
02:23:48,640 --> 02:23:51,830
 

6811
02:23:48,650 --> 02:23:53,960
 so you can keep track of a state for

6812
02:23:51,820 --> 02:23:53,960
 

6813
02:23:51,830 --> 02:23:55,311
 example in just sorting algorithms your

6814
02:23:53,950 --> 02:23:55,311
 

6815
02:23:53,960 --> 02:23:57,860
 state would be the length of the

6816
02:23:55,301 --> 02:23:57,860
 

6817
02:23:55,311 --> 02:24:00,830
 sequence to be left that that's left to

6818
02:23:57,850 --> 02:24:00,830
 

6819
02:23:57,860 --> 02:24:03,140
 be sorted in a recursive manner and you

6820
02:24:00,820 --> 02:24:03,140
 

6821
02:24:00,830 --> 02:24:05,690
 could choose the algorithm on each node

6822
02:24:03,130 --> 02:24:05,690
 

6823
02:24:03,140 --> 02:24:07,490
 of the search tree to you to use for

6824
02:24:05,680 --> 02:24:07,490
 

6825
02:24:05,690 --> 02:24:09,290
 example you want to use quicksort if you

6826
02:24:07,480 --> 02:24:09,290
 

6827
02:24:07,490 --> 02:24:11,300
 have long sequences but if you only have

6828
02:24:09,280 --> 02:24:11,300
 

6829
02:24:09,290 --> 02:24:13,070
 I don't know four numbers left to be

6830
02:24:11,290 --> 02:24:13,070
 

6831
02:24:11,300 --> 02:24:14,720
 sorted then quicksort is probably quite

6832
02:24:13,060 --> 02:24:14,720
 

6833
02:24:13,070 --> 02:24:17,750
 inefficient and insertion sort might be

6834
02:24:14,710 --> 02:24:17,750
 

6835
02:24:14,720 --> 02:24:20,271
 faster so depending on the statistics or

6836
02:24:17,740 --> 02:24:20,271
 

6837
02:24:17,750 --> 02:24:23,480
 the state of your current node you want

6838
02:24:20,261 --> 02:24:23,480
 

6839
02:24:20,271 --> 02:24:25,070
 to use different strategies and lagu

6840
02:24:23,470 --> 02:24:25,070
 

6841
02:24:23,480 --> 02:24:27,620
 DocuSign Littman already almost 20 years

6842
02:24:25,060 --> 02:24:27,620
 

6843
02:24:25,070 --> 02:24:29,600
 ago did this reinforcement learning and

6844
02:24:27,610 --> 02:24:29,600
 

6845
02:24:27,620 --> 02:24:31,630
 then a follow-up paper they also did

6846
02:24:29,590 --> 02:24:31,630
 

6847
02:24:29,600 --> 02:24:35,300
 something it's quite similar for

6848
02:24:31,620 --> 02:24:35,300
 

6849
02:24:31,630 --> 02:24:40,271
 learning to select branching rules in 4d

6850
02:24:35,290 --> 02:24:40,271
 

6851
02:24:35,300 --> 02:24:42,500
 PLL INSAT solving and then one

6852
02:24:40,261 --> 02:24:42,500
 

6853
02:24:40,271 --> 02:24:44,540
 generalization of that so so this

6854
02:24:42,490 --> 02:24:44,540
 

6855
02:24:42,500 --> 02:24:46,100
 basically was online algorithm selection

6856
02:24:44,530 --> 02:24:46,100
 

6857
02:24:44,540 --> 02:24:49,551
 selecting between a small number of

6858
02:24:46,090 --> 02:24:49,551
 

6859
02:24:46,100 --> 02:24:50,781
 components and now you could also do

6860
02:24:49,541 --> 02:24:50,781
 

6861
02:24:49,551 --> 02:24:51,980
 something like that for all of your

6862
02:24:50,771 --> 02:24:51,980
 

6863
02:24:50,781 --> 02:24:53,511
 different parameters for a high

6864
02:24:51,970 --> 02:24:53,511
 

6865
02:24:51,980 --> 02:24:56,121
 dimensional space of parameters and

6866
02:24:53,501 --> 02:24:56,121
 

6867
02:24:53,511 --> 02:24:58,940
 learn to adapt your algorithm parameters

6868
02:24:56,111 --> 02:24:58,940
 

6869
02:24:56,121 --> 02:25:00,110
 online and this is really a strict

6870
02:24:58,930 --> 02:25:00,110
 

6871
02:24:58,940 --> 02:25:02,061
 generalization of the algorithm

6872
02:25:00,100 --> 02:25:02,061
 

6873
02:25:00,110 --> 02:25:03,741
 configuration problem algorithm

6874
02:25:02,051 --> 02:25:03,741
 

6875
02:25:02,061 --> 02:25:06,771
 configuration just picks a fixed setting

6876
02:25:03,731 --> 02:25:06,771
 

6877
02:25:03,741 --> 02:25:08,001
 and never changes it it's also a strict

6878
02:25:06,761 --> 02:25:08,001
 

6879
02:25:06,771 --> 02:25:09,860
 generalization of the per instance

6880
02:25:07,991 --> 02:25:09,860
 

6881
02:25:08,001 --> 02:25:11,391
 algorithm configuration problem which

6882
02:25:09,850 --> 02:25:11,391
 

6883
02:25:09,860 --> 02:25:14,331
 selects the configuration once in the

6884
02:25:11,381 --> 02:25:14,331
 

6885
02:25:11,391 --> 02:25:16,551
 beginning but then never changes it so

6886
02:25:14,321 --> 02:25:16,551
 

6887
02:25:14,331 --> 02:25:18,320
 at least it picks it for each instance

6888
02:25:16,541 --> 02:25:18,320
 

6889
02:25:16,551 --> 02:25:19,671
 and it's also well a strict

6890
02:25:18,310 --> 02:25:19,671
 

6891
02:25:18,320 --> 02:25:22,211
 generalization of algorithm selection

6892
02:25:19,661 --> 02:25:22,211
 

6893
02:25:19,671 --> 02:25:25,851
 which is just a special case of of piak

6894
02:25:22,201 --> 02:25:25,851
 

6895
02:25:22,211 --> 02:25:30,051
 so it's a very very generic formulation

6896
02:25:25,841 --> 02:25:30,051
 

6897
02:25:25,851 --> 02:25:33,471
 and I think very powerful and you can

6898
02:25:30,041 --> 02:25:33,471
 

6899
02:25:30,051 --> 02:25:34,971
 actually attack this with RL so you can

6900
02:25:33,461 --> 02:25:34,971
 

6901
02:25:33,471 --> 02:25:37,190
 formulate the the single instance

6902
02:25:34,961 --> 02:25:37,190
 

6903
02:25:34,971 --> 02:25:38,650
 problem as an MVP but a strong policy

6904
02:25:37,180 --> 02:25:38,650
 

6905
02:25:37,190 --> 02:25:41,991
 that doesn't really necessarily

6906
02:25:38,640 --> 02:25:41,991
 

6907
02:25:38,650 --> 02:25:44,961
 generalize across instances unless you

6908
02:25:41,981 --> 02:25:44,961
 

6909
02:25:41,991 --> 02:25:47,360
 formulate this as a contextual MVP to

6910
02:25:44,951 --> 02:25:47,360
 

6911
02:25:44,961 --> 02:25:49,431
 learn across the instances and that is

6912
02:25:47,350 --> 02:25:49,431
 

6913
02:25:47,360 --> 02:25:52,131
 very new work it's a virtual paper we

6914
02:25:49,421 --> 02:25:52,131
 

6915
02:25:49,431 --> 02:25:54,400
 submitted last week but we have some

6916
02:25:52,121 --> 02:25:54,400
 

6917
02:25:52,131 --> 02:25:57,771
 some first promising results on on

6918
02:25:54,390 --> 02:25:57,771
 

6919
02:25:54,400 --> 02:25:59,751
 actually generalizing to two new

6920
02:25:57,761 --> 02:25:59,751
 

6921
02:25:57,771 --> 02:26:02,091
 problems where you can do dramatically

6922
02:25:59,741 --> 02:26:02,091
 

6923
02:25:59,751 --> 02:26:05,031
 better than then for example on static

6924
02:26:02,081 --> 02:26:05,031
 

6925
02:26:02,091 --> 02:26:07,820
 algorithm configuration and I think this

6926
02:26:05,021 --> 02:26:07,820
 

6927
02:26:05,031 --> 02:26:11,181
 is really one of the key areas where

6928
02:26:07,810 --> 02:26:11,181
 

6929
02:26:07,820 --> 02:26:12,711
 where this work is going when I started

6930
02:26:11,171 --> 02:26:12,711
 

6931
02:26:11,181 --> 02:26:16,610
 my PhD on outdoors and configuration

6932
02:26:12,701 --> 02:26:16,610
 

6933
02:26:12,711 --> 02:26:18,291
 about 15 years ago I saw this literature

6934
02:26:16,600 --> 02:26:18,291
 

6935
02:26:16,610 --> 02:26:20,271
 bylaw go darkus enrichment for example

6936
02:26:18,281 --> 02:26:20,271
 

6937
02:26:18,291 --> 02:26:22,371
 and I thought this is really cool but I

6938
02:26:20,261 --> 02:26:22,371
 

6939
02:26:20,271 --> 02:26:25,041
 shied away from it because RL wasn't

6940
02:26:22,361 --> 02:26:25,041
 

6941
02:26:22,371 --> 02:26:26,751
 quite ready and I just looked at the

6942
02:26:25,031 --> 02:26:26,751
 

6943
02:26:25,041 --> 02:26:30,110
 simple case black box optimization

6944
02:26:26,741 --> 02:26:30,110
 

6945
02:26:26,751 --> 02:26:32,541
 supervised learning but now I think the

6946
02:26:30,100 --> 02:26:32,541
 

6947
02:26:30,110 --> 02:26:35,841
 state of RL is really at the point where

6948
02:26:32,531 --> 02:26:35,841
 

6949
02:26:32,541 --> 02:26:38,031
 we can address these much more powerful

6950
02:26:35,831 --> 02:26:38,031
 

6951
02:26:35,841 --> 02:26:40,041
 formulations of the problem and adapt

6952
02:26:38,021 --> 02:26:40,041
 

6953
02:26:38,031 --> 02:26:41,271
 our parameters online and just have

6954
02:26:40,031 --> 02:26:41,271
 

6955
02:26:40,041 --> 02:26:44,241
 algorithm configuration algorithm

6956
02:26:41,261 --> 02:26:44,241
 

6957
02:26:41,271 --> 02:26:47,631
 selection there's special cases where's

6958
02:26:44,231 --> 02:26:47,631
 

6959
02:26:44,241 --> 02:26:48,771
 that let me wrap up so we hope to have

6960
02:26:47,621 --> 02:26:48,771
 

6961
02:26:47,631 --> 02:26:51,051
 convinced you that algorithm

6962
02:26:48,761 --> 02:26:51,051
 

6963
02:26:48,771 --> 02:26:53,511
 configuration allows us to learn in the

6964
02:26:51,041 --> 02:26:53,511
 

6965
02:26:51,051 --> 02:26:55,400
 space of different algorithms practical

6966
02:26:53,501 --> 02:26:55,400
 

6967
02:26:53,511 --> 02:26:59,031
 algorithm configuration methods are very

6968
02:26:55,390 --> 02:26:59,031
 

6969
02:26:55,400 --> 02:27:00,891
 mature and and yield large speed ups for

6970
02:26:59,021 --> 02:27:00,891
 

6971
02:26:59,031 --> 02:27:02,840
 a variety of different problems there's

6972
02:27:00,881 --> 02:27:02,840
 

6973
02:27:00,891 --> 02:27:04,340
 a lot of progress on algorithm

6974
02:27:02,830 --> 02:27:04,340
 

6975
02:27:02,840 --> 02:27:06,890
 figuration with worst-case runtime

6976
02:27:04,330 --> 02:27:06,890
 

6977
02:27:04,340 --> 02:27:09,590
 guarantees we haven't shown you any data

6978
02:27:06,880 --> 02:27:09,590
 

6979
02:27:06,890 --> 02:27:10,850
 on how to apply this in practice and put

6980
02:27:09,580 --> 02:27:10,850
 

6981
02:27:09,590 --> 02:27:13,149
 it into smack and that is something

6982
02:27:10,840 --> 02:27:13,149
 

6983
02:27:10,850 --> 02:27:15,500
 that's under under development and I

6984
02:27:13,139 --> 02:27:15,500
 

6985
02:27:13,149 --> 02:27:18,649
 expect that this will actually work

6986
02:27:15,490 --> 02:27:18,649
 

6987
02:27:15,500 --> 02:27:20,720
 extremely well because well the adaptive

6988
02:27:18,639 --> 02:27:20,720
 

6989
02:27:18,649 --> 02:27:23,510
 capping and aggressive racing and smack

6990
02:27:20,710 --> 02:27:23,510
 

6991
02:27:20,720 --> 02:27:26,120
 is very heuristic and the the worst-case

6992
02:27:23,500 --> 02:27:26,120
 

6993
02:27:23,510 --> 02:27:27,920
 guarantees ought to really lead to

6994
02:27:26,110 --> 02:27:27,920
 

6995
02:27:26,120 --> 02:27:29,600
 better performance and we looked at

6996
02:27:27,910 --> 02:27:29,600
 

6997
02:27:27,920 --> 02:27:31,760
 these related problems permit importance

6998
02:27:29,590 --> 02:27:31,760
 

6999
02:27:29,600 --> 02:27:33,560
 algorithm selection and trend learning

7000
02:27:31,750 --> 02:27:33,560
 

7001
02:27:31,760 --> 02:27:35,350
 and other ways of integrating machine

7002
02:27:33,550 --> 02:27:35,350
 

7003
02:27:33,560 --> 02:27:39,200
 learning with combinatorial optimization

7004
02:27:35,340 --> 02:27:39,200
 

7005
02:27:35,350 --> 02:27:43,100
 we've code available for smack for k4

7006
02:27:39,190 --> 02:27:43,100
 

7007
02:27:39,200 --> 02:27:46,010
 parameter importance for Mozilla Hydra

7008
02:27:43,090 --> 02:27:46,010
 

7009
02:27:43,100 --> 02:27:48,380
 etc and yet there's more material on

7010
02:27:46,000 --> 02:27:48,380
 

7011
02:27:46,010 --> 02:27:50,810
 this web page and the tutorials also

7012
02:27:48,370 --> 02:27:50,810
 

7013
02:27:48,380 --> 02:27:53,390
 linked on this webpage and you can find

7014
02:27:50,800 --> 02:27:53,390
 

7015
02:27:50,810 --> 02:27:55,520
 the slides let me remind you at this

7016
02:27:53,380 --> 02:27:55,520
 

7017
02:27:53,390 --> 02:27:57,500
 link here if you want to look at them

7018
02:27:55,510 --> 02:27:57,500
 

7019
02:27:55,520 --> 02:28:00,500
 for future reference and have clipped

7020
02:27:57,490 --> 02:28:00,500
 

7021
02:27:57,500 --> 02:28:04,850
 clickable links yeah

7022
02:28:00,490 --> 02:28:04,850
 

7023
02:28:00,500 --> 02:28:06,560
 and if you're excited in of this to work

7024
02:28:04,840 --> 02:28:06,560
 

7025
02:28:04,850 --> 02:28:08,330
 in the space of machine learning and

7026
02:28:06,550 --> 02:28:08,330
 

7027
02:28:06,560 --> 02:28:09,740
 community optimization then well of

7028
02:28:08,320 --> 02:28:09,740
 

7029
02:28:08,330 --> 02:28:13,689
 course like everyone we are also hiring

7030
02:28:09,730 --> 02:28:13,689
 

7031
02:28:09,740 --> 02:28:13,689
 so thanks a lot

7032
02:28:17,030 --> 02:28:17,030
 

7033
02:28:17,040 --> 02:28:23,370
 and I guess we'll take a few more

7034
02:28:19,219 --> 02:28:23,370
 

7035
02:28:19,229 --> 02:28:24,960
 questions yes we'll take a couple

7036
02:28:23,360 --> 02:28:24,960
 

7037
02:28:23,370 --> 02:28:27,770
 questions from people who are interested

7038
02:28:24,950 --> 02:28:27,770
 

7039
02:28:24,960 --> 02:28:29,970
 if you have to leave don't be shy and

7040
02:28:27,760 --> 02:28:29,970
 

7041
02:28:27,770 --> 02:28:32,069
 after two or three questions we'll wrap

7042
02:28:29,960 --> 02:28:32,069
 

7043
02:28:29,970 --> 02:28:33,810
 it up and discuss at the front with

7044
02:28:32,059 --> 02:28:33,810
 

7045
02:28:32,069 --> 02:28:37,890
 anyone else who sticks around thanks

7046
02:28:33,800 --> 02:28:37,890
 

7047
02:28:33,810 --> 02:28:40,680
 again I have a question was functional

7048
02:28:37,880 --> 02:28:40,680
 

7049
02:28:37,890 --> 02:28:43,200
 noble if you want to use functional

7050
02:28:40,670 --> 02:28:43,200
 

7051
02:28:40,680 --> 02:28:45,120
 onobu in the machine learning then the

7052
02:28:43,190 --> 02:28:45,120
 

7053
02:28:43,200 --> 02:28:48,840
 machine learning has a lot of parameters

7054
02:28:45,110 --> 02:28:48,840
 

7055
02:28:45,120 --> 02:28:53,580
 and it takes time to every 8h of each

7056
02:28:48,830 --> 02:28:53,580
 

7057
02:28:48,840 --> 02:28:56,310
 time under you define the distribution

7058
02:28:53,570 --> 02:28:56,310
 

7059
02:28:53,580 --> 02:28:59,670
 of the parameter as uniform so that's

7060
02:28:56,300 --> 02:28:59,670
 

7061
02:28:56,310 --> 02:29:05,370
 why you have to run them searching the

7062
02:28:59,660 --> 02:29:05,370
 

7063
02:28:59,670 --> 02:29:07,620
 hyper parameter I think if the

7064
02:29:05,360 --> 02:29:07,620
 

7065
02:29:05,370 --> 02:29:10,560
 parameters number is so big then you

7066
02:29:07,610 --> 02:29:10,560
 

7067
02:29:07,620 --> 02:29:15,149
 have to a very so much time how many

7068
02:29:10,550 --> 02:29:15,149
 

7069
02:29:10,560 --> 02:29:17,220
 times yeah so the question is you have a

7070
02:29:15,139 --> 02:29:17,220
 

7071
02:29:15,149 --> 02:29:18,960
 large configuration space don't you need

7072
02:29:17,210 --> 02:29:18,960
 

7073
02:29:17,220 --> 02:29:21,840
 a ton of samples in order to then apply

7074
02:29:18,950 --> 02:29:21,840
 

7075
02:29:18,960 --> 02:29:24,960
 these methods and well the answer is

7076
02:29:21,830 --> 02:29:24,960
 

7077
02:29:21,840 --> 02:29:27,240
 really it's the same problem as phasing

7078
02:29:24,950 --> 02:29:27,240
 

7079
02:29:24,960 --> 02:29:28,920
 optimization there you would also think

7080
02:29:27,230 --> 02:29:28,920
 

7081
02:29:27,240 --> 02:29:32,160
 it's a huge space and you need all these

7082
02:29:28,910 --> 02:29:32,160
 

7083
02:29:28,920 --> 02:29:33,930
 different configurations but really if

7084
02:29:32,150 --> 02:29:33,930
 

7085
02:29:32,160 --> 02:29:35,850
 we optimize in a hundred dimensional

7086
02:29:33,920 --> 02:29:35,850
 

7087
02:29:33,930 --> 02:29:37,770
 space we have a regression problem with

7088
02:29:35,840 --> 02:29:37,770
 

7089
02:29:35,850 --> 02:29:39,300
 a hundred dimensions if we have a

7090
02:29:37,760 --> 02:29:39,300
 

7091
02:29:37,770 --> 02:29:41,220
 thousand data points or something like

7092
02:29:39,290 --> 02:29:41,220
 

7093
02:29:39,300 --> 02:29:42,660
 that but it's no problem to try to

7094
02:29:41,210 --> 02:29:42,660
 

7095
02:29:41,220 --> 02:29:46,080
 generalize in a space of a hundred

7096
02:29:42,650 --> 02:29:46,080
 

7097
02:29:42,660 --> 02:29:47,819
 dimensions so we should not think oh

7098
02:29:46,070 --> 02:29:47,819
 

7099
02:29:46,080 --> 02:29:49,350
 it's a hundred dimensions I need to do

7100
02:29:47,809 --> 02:29:49,350
 

7101
02:29:47,819 --> 02:29:50,640
 100 samples or something like that to

7102
02:29:49,340 --> 02:29:50,640
 

7103
02:29:49,350 --> 02:29:52,350
 cover that it's definitely not

7104
02:29:50,630 --> 02:29:52,350
 

7105
02:29:50,640 --> 02:29:53,729
 exponential it's it's quite linear in

7106
02:29:52,340 --> 02:29:53,729
 

7107
02:29:52,350 --> 02:29:57,479
 the number of dimensions of the number

7108
02:29:53,719 --> 02:29:57,479
 

7109
02:29:53,729 --> 02:30:03,720
 of data points you need thank you thank

7110
02:29:57,469 --> 02:30:03,720
 

7111
02:29:57,479 --> 02:30:06,600
 you hello hey thanks for the talk I just

7112
02:30:03,710 --> 02:30:06,600
 

7113
02:30:03,720 --> 02:30:08,760
 wanted to us about the uncertainty

7114
02:30:06,590 --> 02:30:08,760
 

7115
02:30:06,600 --> 02:30:11,370
 estimates I've never heard of people

7116
02:30:08,750 --> 02:30:11,370
 

7117
02:30:08,760 --> 02:30:13,439
 doing into regression with random

7118
02:30:11,360 --> 02:30:13,439
 

7119
02:30:11,370 --> 02:30:15,990
 forests and regression trees I think is

7120
02:30:13,429 --> 02:30:15,990
 

7121
02:30:13,439 --> 02:30:17,430
 very nice but I was wondering why didn't

7122
02:30:15,980 --> 02:30:17,430
 

7123
02:30:15,990 --> 02:30:20,700
 you use Gaussian processes and I think

7124
02:30:17,420 --> 02:30:20,700
 

7125
02:30:17,430 --> 02:30:25,260
 you gave three reasons so one of them

7126
02:30:20,690 --> 02:30:25,260
 

7127
02:30:20,700 --> 02:30:26,430
 was heteroscedastic variance the other

7128
02:30:25,250 --> 02:30:26,430
 

7129
02:30:25,260 --> 02:30:30,149
 one was that there were too many

7130
02:30:26,420 --> 02:30:30,149
 

7131
02:30:26,430 --> 02:30:32,880
 features right yeah

7132
02:30:30,139 --> 02:30:32,880
 

7133
02:30:30,149 --> 02:30:36,070
 yeah

7134
02:30:32,870 --> 02:30:36,070
 

7135
02:30:32,880 --> 02:30:38,620
 the short answer is I really like GPS

7136
02:30:36,060 --> 02:30:38,620
 

7137
02:30:36,070 --> 02:30:39,939
 I've worked with GPS a lot but for

7138
02:30:38,610 --> 02:30:39,939
 

7139
02:30:38,620 --> 02:30:42,540
 others in configuration what you would

7140
02:30:39,929 --> 02:30:42,540
 

7141
02:30:39,939 --> 02:30:45,550
 need is the combination of all of these

7142
02:30:42,530 --> 02:30:45,550
 

7143
02:30:42,540 --> 02:30:48,850
 10 different papers here and nobody has

7144
02:30:45,540 --> 02:30:48,850
 

7145
02:30:45,550 --> 02:30:52,120
 done that right right but I was thinking

7146
02:30:48,840 --> 02:30:52,120
 

7147
02:30:48,850 --> 02:30:53,580
 of some GP models like there is one by

7148
02:30:52,110 --> 02:30:53,580
 

7149
02:30:52,120 --> 02:30:56,439
 teaches for instance that is

7150
02:30:53,570 --> 02:30:56,439
 

7151
02:30:53,580 --> 02:30:59,140
 heteroskedastic and his spars so it

7152
02:30:56,429 --> 02:30:59,140
 

7153
02:30:56,439 --> 02:31:00,670
 would and I was thinking that for them

7154
02:30:59,130 --> 02:31:00,670
 

7155
02:30:59,140 --> 02:31:03,340
 for the high dimensionality there are

7156
02:31:00,660 --> 02:31:03,340
 

7157
02:31:00,670 --> 02:31:05,620
 many kernels so I was wondering if you

7158
02:31:03,330 --> 02:31:05,620
 

7159
02:31:03,340 --> 02:31:07,030
 if you had tried some of that because

7160
02:31:05,610 --> 02:31:07,030
 

7161
02:31:05,620 --> 02:31:10,360
 I'm interesting also into in Bayesian

7162
02:31:07,020 --> 02:31:10,360
 

7163
02:31:07,030 --> 02:31:13,540
 optimization with and I was thinking

7164
02:31:10,350 --> 02:31:13,540
 

7165
02:31:10,360 --> 02:31:15,610
 like the obvious ways like with GPS so

7166
02:31:13,530 --> 02:31:15,610
 

7167
02:31:13,540 --> 02:31:19,180
 maybe like is there a reason why should

7168
02:31:15,600 --> 02:31:19,180
 

7169
02:31:15,610 --> 02:31:22,120
 also switch to random forests I'm very

7170
02:31:19,170 --> 02:31:22,120
 

7171
02:31:19,180 --> 02:31:23,710
 happy to chat offline I organized the

7172
02:31:22,110 --> 02:31:23,710
 

7173
02:31:22,120 --> 02:31:25,630
 based optimization workshop three times

7174
02:31:23,700 --> 02:31:25,630
 

7175
02:31:23,710 --> 02:31:27,189
 I'm feeling very deeply about based

7176
02:31:25,620 --> 02:31:27,189
 

7177
02:31:25,630 --> 02:31:29,260
 optimization I love it

7178
02:31:27,179 --> 02:31:29,260
 

7179
02:31:27,189 --> 02:31:31,060
 I do it with GPS I do it was based in

7180
02:31:29,250 --> 02:31:31,060
 

7181
02:31:29,260 --> 02:31:33,580
 neural nets I do it was random for us

7182
02:31:31,050 --> 02:31:33,580
 

7183
02:31:31,060 --> 02:31:36,160
 and it's just what whatever model fits

7184
02:31:33,570 --> 02:31:36,160
 

7185
02:31:33,580 --> 02:31:39,700
 the data best and and in this case so

7186
02:31:36,150 --> 02:31:39,700
 

7187
02:31:36,160 --> 02:31:42,850
 far we just found random forests to be

7188
02:31:39,690 --> 02:31:42,850
 

7189
02:31:39,700 --> 02:31:46,570
 the easiest solution but it's not going

7190
02:31:42,840 --> 02:31:46,570
 

7191
02:31:42,850 --> 02:31:48,520
 to work every time so it depends I think

7192
02:31:46,560 --> 02:31:48,520
 

7193
02:31:46,570 --> 02:31:50,050
 what you can have for example is a

7194
02:31:48,510 --> 02:31:50,050
 

7195
02:31:48,520 --> 02:31:51,670
 portfolio that looks at your data and

7196
02:31:50,040 --> 02:31:51,670
 

7197
02:31:50,050 --> 02:31:54,160
 just evaluates how well it's a fit with

7198
02:31:51,660 --> 02:31:54,160
 

7199
02:31:51,670 --> 02:31:57,040
 this particular model and then just uses

7200
02:31:54,150 --> 02:31:57,040
 

7201
02:31:54,160 --> 02:31:59,550
 the the right model for this data that

7202
02:31:57,030 --> 02:31:59,550
 

7203
02:31:57,040 --> 02:32:02,260
 that's kind of the simple solution to

7204
02:31:59,540 --> 02:32:02,260
 

7205
02:31:59,550 --> 02:32:05,229
 cover everything with one method right

7206
02:32:02,250 --> 02:32:05,229
 

7207
02:32:02,260 --> 02:32:08,170
 thank you thank you thanks again

7208
02:32:05,219 --> 02:32:08,170
 

7209
02:32:05,229 --> 02:32:09,729
 everybody it's been a long day three

7210
02:32:08,160 --> 02:32:09,729
 

7211
02:32:08,170 --> 02:32:12,850
 tutorials in a row for those of you who

7212
02:32:09,719 --> 02:32:12,850
 

7213
02:32:09,729 --> 02:32:16,200
 did it congratulations and let's all

7214
02:32:12,840 --> 02:32:16,200
 

7215
02:32:12,850 --> 02:32:16,200
 enjoy the reception thanks again

7216
02:32:34,810 --> 02:32:34,810
 

7217
02:32:34,820 --> 02:32:38,020
[Music]