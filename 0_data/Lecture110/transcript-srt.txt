1
00:00:12,300 --> 00:00:15,409
[Applause]

2
00:00:19,430 --> 00:00:19,430
 

3
00:00:19,440 --> 00:00:23,969
[Music]

4
00:00:39,230 --> 00:00:39,230
 

5
00:00:39,240 --> 00:00:42,399
[Music]

6
00:01:05,040 --> 00:01:05,040
 

7
00:01:05,050 --> 00:01:12,780
[Music]

8
00:01:18,470 --> 00:01:18,470
 

9
00:01:18,480 --> 00:01:21,569
[Music]

10
00:01:24,410 --> 00:01:24,410
 

11
00:01:24,420 --> 00:01:29,059
[Music]

12
00:01:55,090 --> 00:01:55,090
 

13
00:01:55,100 --> 00:02:01,620
[Music]

14
00:02:13,010 --> 00:02:13,010
 

15
00:02:13,020 --> 00:02:16,230
 and each

16
00:02:21,170 --> 00:02:21,170
 

17
00:02:21,180 --> 00:02:24,300
[Music]

18
00:02:28,560 --> 00:02:28,560
 

19
00:02:28,570 --> 00:02:32,320
 let's join in

20
00:02:34,270 --> 00:02:34,270
 

21
00:02:34,280 --> 00:02:38,419
[Music]

22
00:02:43,240 --> 00:02:43,240
 

23
00:02:43,250 --> 00:02:54,180
[Music]

24
00:03:02,790 --> 00:03:02,790
 

25
00:03:02,800 --> 00:03:05,869
[Music]

26
00:03:08,740 --> 00:03:08,740
 

27
00:03:08,750 --> 00:03:12,830
[Music]

28
00:03:26,910 --> 00:03:26,910
 

29
00:03:26,920 --> 00:03:31,419
[Music]

30
00:03:49,920 --> 00:03:49,920
 

31
00:03:49,930 --> 00:03:53,110
[Music]

32
00:03:55,730 --> 00:03:55,730
 

33
00:03:55,740 --> 00:04:14,020
[Music]

34
00:04:16,639 --> 00:04:16,639
 

35
00:04:16,649 --> 00:04:25,139
[Music]

36
00:05:08,360 --> 00:05:08,360
 

37
00:05:08,370 --> 00:05:15,220
[Music]

38
00:05:26,020 --> 00:05:26,020
 

39
00:05:26,030 --> 00:05:29,110
[Music]

40
00:05:34,850 --> 00:05:34,850
 

41
00:05:34,860 --> 00:05:41,589
[Music]

42
00:05:44,040 --> 00:05:44,040
 

43
00:05:44,050 --> 00:05:48,660
[Music]

44
00:06:00,180 --> 00:06:00,180
 

45
00:06:00,190 --> 00:06:11,550
[Music]

46
00:06:14,290 --> 00:06:14,290
 

47
00:06:14,300 --> 00:06:18,079
[Music]

48
00:06:21,830 --> 00:06:21,830
 

49
00:06:21,840 --> 00:06:25,020
[Music]

50
00:06:31,800 --> 00:06:31,800
 

51
00:06:31,810 --> 00:06:44,690
 sometimes worlds collide love big nights

52
00:06:38,700 --> 00:06:44,690
 

53
00:06:38,710 --> 00:06:48,650
 big dreams die either way we try our

54
00:06:44,680 --> 00:06:48,650
 

55
00:06:44,690 --> 00:06:51,250
 whole life try to be someone with the

56
00:06:48,640 --> 00:06:51,250
 

57
00:06:48,650 --> 00:06:51,250
 whole world

58
00:06:51,800 --> 00:06:51,800
 

59
00:06:51,810 --> 00:07:02,770
[Music]

60
00:07:06,320 --> 00:07:06,320
 

61
00:07:06,330 --> 00:07:22,089
[Music]

62
00:07:29,160 --> 00:07:29,160
 

63
00:07:29,170 --> 00:07:32,290
[Music]

64
00:07:39,090 --> 00:07:39,090
 

65
00:07:39,100 --> 00:07:45,410
[Music]

66
00:07:49,460 --> 00:07:49,460
 

67
00:07:49,470 --> 00:07:53,409
[Music]

68
00:07:58,910 --> 00:07:58,910
 

69
00:07:58,920 --> 00:08:18,389
[Music]

70
00:08:32,409 --> 00:08:32,409
 

71
00:08:32,419 --> 00:08:37,849
[Music]

72
00:08:46,580 --> 00:08:46,580
 

73
00:08:46,590 --> 00:08:49,940
[Music]

74
00:10:57,610 --> 00:10:57,610
 

75
00:10:57,620 --> 00:11:05,850
 okay welcome everybody to the last

76
00:11:01,910 --> 00:11:05,850
 

77
00:11:01,920 --> 00:11:07,860
 tutorial session of the day the this

78
00:11:05,840 --> 00:11:07,860
 

79
00:11:05,850 --> 00:11:11,780
 talk will be on attention in deep

80
00:11:07,850 --> 00:11:11,780
 

81
00:11:07,860 --> 00:11:14,460
 learning a powerful and important

82
00:11:11,770 --> 00:11:14,460
 

83
00:11:11,780 --> 00:11:16,950
 architecture I think and it's going to

84
00:11:14,450 --> 00:11:16,950
 

85
00:11:14,460 --> 00:11:22,770
 be presented by Alex mola and Aston

86
00:11:16,940 --> 00:11:22,770
 

87
00:11:16,950 --> 00:11:26,730
 Jiang both from Amazon Web Services okay

88
00:11:22,760 --> 00:11:26,730
 

89
00:11:22,770 --> 00:11:28,800
 so thanks for coming in here and so I

90
00:11:26,720 --> 00:11:28,800
 

91
00:11:26,730 --> 00:11:31,260
 hope that in the end you'll take

92
00:11:28,790 --> 00:11:31,260
 

93
00:11:28,800 --> 00:11:33,750
 something away about attention so who

94
00:11:31,250 --> 00:11:33,750
 

95
00:11:31,260 --> 00:11:35,820
 thinks that the average attention span

96
00:11:33,740 --> 00:11:35,820
 

97
00:11:33,750 --> 00:11:41,480
 of the human is longer than that of a

98
00:11:35,810 --> 00:11:41,480
 

99
00:11:35,820 --> 00:11:44,540
 goldfish actually turns out not quite so

100
00:11:41,470 --> 00:11:44,540
 

101
00:11:41,480 --> 00:11:46,460
 goldfish BT owns by one or two seconds

102
00:11:44,530 --> 00:11:46,460
 

103
00:11:44,540 --> 00:11:49,950
 we'll get to that later

104
00:11:46,450 --> 00:11:49,950
 

105
00:11:46,460 --> 00:11:54,090
 but okay so nonetheless attention is

106
00:11:49,940 --> 00:11:54,090
 

107
00:11:49,950 --> 00:11:57,960
 kind of important and well bar this a

108
00:11:54,080 --> 00:11:57,960
 

109
00:11:54,090 --> 00:12:00,270
 lot of echo so there's one important URL

110
00:11:57,950 --> 00:12:00,270
 

111
00:11:57,960 --> 00:12:04,350
 you probably want to remember if you go

112
00:12:00,260 --> 00:12:04,350
 

113
00:12:00,270 --> 00:12:08,640
 to bitly and you type in to capital R 1

114
00:12:04,340 --> 00:12:08,640
 

115
00:12:04,350 --> 00:12:12,120
 zero lowercase H capital T lowercase u

116
00:12:08,630 --> 00:12:12,120
 

117
00:12:08,640 --> 00:12:16,790
 um you'll get all the slides or you look

118
00:12:12,110 --> 00:12:16,790
 

119
00:12:12,120 --> 00:12:21,090
 at my Twitter feed or anywhere else ok

120
00:12:16,780 --> 00:12:21,090
 

121
00:12:16,790 --> 00:12:22,470
 so let's get started given that people

122
00:12:21,080 --> 00:12:22,470
 

123
00:12:21,090 --> 00:12:25,410
 are still streaming in let's start with

124
00:12:22,460 --> 00:12:25,410
 

125
00:12:22,470 --> 00:12:29,850
 something very easy all right um so a

126
00:12:25,400 --> 00:12:29,850
 

127
00:12:25,410 --> 00:12:31,350
 bit of biology so I guess everybody

128
00:12:29,840 --> 00:12:31,350
 

129
00:12:29,850 --> 00:12:34,140
 knows what that is it's a cross-section

130
00:12:31,340 --> 00:12:34,140
 

131
00:12:31,350 --> 00:12:36,030
 of an eye and one very important thing

132
00:12:34,130 --> 00:12:36,030
 

133
00:12:34,140 --> 00:12:38,280
 about this is that there's the thing

134
00:12:36,020 --> 00:12:38,280
 

135
00:12:36,030 --> 00:12:41,220
 called the fovea so Foley is the part

136
00:12:38,270 --> 00:12:41,220
 

137
00:12:38,280 --> 00:12:43,260
 where lots of essentially pixels are if

138
00:12:41,210 --> 00:12:43,260
 

139
00:12:41,220 --> 00:12:45,120
 you want to put it in computer speak in

140
00:12:43,250 --> 00:12:45,120
 

141
00:12:43,260 --> 00:12:49,589
 other words we use sensor has a very

142
00:12:45,110 --> 00:12:49,589
 

143
00:12:45,120 --> 00:12:51,450
 high quality and ok so well what does

144
00:12:49,579 --> 00:12:51,450
 

145
00:12:49,589 --> 00:12:53,190
 this have to do with this tutorial well

146
00:12:51,440 --> 00:12:53,190
 

147
00:12:51,450 --> 00:12:55,320
 suppose you need to make those slides

148
00:12:53,180 --> 00:12:55,320
 

149
00:12:53,190 --> 00:12:57,390
 alright and you're feeling kind of a

150
00:12:55,310 --> 00:12:57,390
 

151
00:12:55,320 --> 00:13:00,600
 little bit tired and you need to look

152
00:12:57,380 --> 00:13:00,600
 

153
00:12:57,390 --> 00:13:02,220
 through all those papers right to make

154
00:13:00,590 --> 00:13:02,220
 

155
00:13:00,600 --> 00:13:04,610
 sure that you know you're up to date

156
00:13:02,210 --> 00:13:04,610
 

157
00:13:02,220 --> 00:13:07,230
 with the latest papers and everything

158
00:13:04,600 --> 00:13:07,230
 

159
00:13:04,610 --> 00:13:07,620
 well then maybe because you're feeling a

160
00:13:07,220 --> 00:13:07,620
 

161
00:13:07,230 --> 00:13:08,610
 little bit

162
00:13:07,610 --> 00:13:08,610
 

163
00:13:07,620 --> 00:13:12,240
 all right you should focus your

164
00:13:08,600 --> 00:13:12,240
 

165
00:13:08,610 --> 00:13:16,410
 attention your attention waiting on two

166
00:13:12,230 --> 00:13:16,410
 

167
00:13:12,240 --> 00:13:19,080
 well that little cup of coffee and so

168
00:13:16,400 --> 00:13:19,080
 

169
00:13:16,410 --> 00:13:21,600
 what happens is basically you're now

170
00:13:19,070 --> 00:13:21,600
 

171
00:13:19,080 --> 00:13:24,690
 using a significant amount of the

172
00:13:21,590 --> 00:13:24,690
 

173
00:13:21,600 --> 00:13:26,880
 sensors of your receptive field for a

174
00:13:24,680 --> 00:13:26,880
 

175
00:13:24,690 --> 00:13:28,200
 cup of coffee and then you treat the

176
00:13:26,870 --> 00:13:28,200
 

177
00:13:26,880 --> 00:13:31,350
 coffee and then you know you feel a

178
00:13:28,190 --> 00:13:31,350
 

179
00:13:28,200 --> 00:13:33,360
 little bit strengthened by it and then

180
00:13:31,340 --> 00:13:33,360
 

181
00:13:31,350 --> 00:13:35,310
 you can attend to the papers and work

182
00:13:33,350 --> 00:13:35,310
 

183
00:13:33,360 --> 00:13:38,600
 through them one by one in other words

184
00:13:35,300 --> 00:13:38,600
 

185
00:13:35,310 --> 00:13:41,610
 you don't necessarily perceive the world

186
00:13:38,590 --> 00:13:41,610
 

187
00:13:38,600 --> 00:13:43,200
 uniformly in the sense that you're not

188
00:13:41,600 --> 00:13:43,200
 

189
00:13:41,610 --> 00:13:45,270
 investing the same amount of information

190
00:13:43,190 --> 00:13:45,270
 

191
00:13:43,200 --> 00:13:48,000
 processing capacity uniformly on

192
00:13:45,260 --> 00:13:48,000
 

193
00:13:45,270 --> 00:13:49,910
 everything but you focus on specific

194
00:13:47,990 --> 00:13:49,910
 

195
00:13:48,000 --> 00:13:53,490
 things so for instance I hope that

196
00:13:49,900 --> 00:13:53,490
 

197
00:13:49,910 --> 00:13:56,670
 during this tutorial that Aston Zhuang

198
00:13:53,480 --> 00:13:56,670
 

199
00:13:53,490 --> 00:13:58,170
 and I are presenting you will focus a

200
00:13:56,660 --> 00:13:58,170
 

201
00:13:56,670 --> 00:14:00,839
 lot of your attention on what we're

202
00:13:58,160 --> 00:14:00,839
 

203
00:13:58,170 --> 00:14:03,960
 saying as opposed to maybe what's going

204
00:14:00,829 --> 00:14:03,960
 

205
00:14:00,839 --> 00:14:07,950
 on on your Facebook right so okay that

206
00:14:03,950 --> 00:14:07,950
 

207
00:14:03,960 --> 00:14:10,170
 sounds silly let's look at why nature

208
00:14:07,940 --> 00:14:10,170
 

209
00:14:07,950 --> 00:14:14,040
 has invented stuff like this and this is

210
00:14:10,160 --> 00:14:14,040
 

211
00:14:10,170 --> 00:14:15,690
 yeah full disclaimer the glib stupid

212
00:14:14,030 --> 00:14:15,690
 

213
00:14:14,040 --> 00:14:17,570
 computer scientists version of it but

214
00:14:15,680 --> 00:14:17,570
 

215
00:14:15,690 --> 00:14:19,950
 basically if you think about it

216
00:14:17,560 --> 00:14:19,950
 

217
00:14:17,570 --> 00:14:22,470
 attention in animals does a number of

218
00:14:19,940 --> 00:14:22,470
 

219
00:14:19,950 --> 00:14:24,450
 things one of them is resource saving so

220
00:14:22,460 --> 00:14:24,450
 

221
00:14:22,470 --> 00:14:27,240
 what that means is that you only really

222
00:14:24,440 --> 00:14:27,240
 

223
00:14:24,450 --> 00:14:30,510
 need the sensors where relevant bits of

224
00:14:27,230 --> 00:14:30,510
 

225
00:14:27,240 --> 00:14:32,510
 information are so you only need to you

226
00:14:30,500 --> 00:14:32,510
 

227
00:14:30,510 --> 00:14:34,640
 know focus with your phobia on the

228
00:14:32,500 --> 00:14:34,640
 

229
00:14:32,510 --> 00:14:36,720
 pieces there for high resolution

230
00:14:34,630 --> 00:14:36,720
 

231
00:14:34,640 --> 00:14:38,640
 actually turns out your peripheral

232
00:14:36,710 --> 00:14:38,640
 

233
00:14:36,720 --> 00:14:40,500
 vision is really good for movement so

234
00:14:38,630 --> 00:14:40,500
 

235
00:14:38,640 --> 00:14:43,950
 it's a different type of attention there

236
00:14:40,490 --> 00:14:43,950
 

237
00:14:40,500 --> 00:14:46,560
 and the other thing then is you only

238
00:14:43,940 --> 00:14:46,560
 

239
00:14:43,950 --> 00:14:48,080
 need to do the computation there that

240
00:14:46,550 --> 00:14:48,080
 

241
00:14:46,560 --> 00:14:51,390
 actually matters quite a bit because

242
00:14:48,070 --> 00:14:51,390
 

243
00:14:48,080 --> 00:14:52,560
 well animals are quite energy

244
00:14:51,380 --> 00:14:52,560
 

245
00:14:51,390 --> 00:14:55,740
 constrained they're very energy

246
00:14:52,550 --> 00:14:55,740
 

247
00:14:52,560 --> 00:14:57,870
 efficient and if I can avoid doing a lot

248
00:14:55,730 --> 00:14:57,870
 

249
00:14:55,740 --> 00:15:00,690
 of processing in the areas that I don't

250
00:14:57,860 --> 00:15:00,690
 

251
00:14:57,870 --> 00:15:02,370
 really care about that much well I can

252
00:15:00,680 --> 00:15:02,370
 

253
00:15:00,690 --> 00:15:05,209
 save my energy for something else like

254
00:15:02,360 --> 00:15:05,209
 

255
00:15:02,370 --> 00:15:07,740
 thinking harder being smart and whatever

256
00:15:05,199 --> 00:15:07,740
 

257
00:15:05,209 --> 00:15:10,230
 the other nice thing is that this

258
00:15:07,730 --> 00:15:10,230
 

259
00:15:07,740 --> 00:15:12,300
 attention allows you to manipulate a

260
00:15:10,220 --> 00:15:12,300
 

261
00:15:10,230 --> 00:15:15,000
 variable state relatively efficiently

262
00:15:12,290 --> 00:15:15,000
 

263
00:15:12,300 --> 00:15:17,910
 okay so let's look at that cute Chiclets

264
00:15:14,990 --> 00:15:17,910
 

265
00:15:15,000 --> 00:15:19,920
 on the lower right and that is trying to

266
00:15:17,900 --> 00:15:19,920
 

267
00:15:17,910 --> 00:15:22,800
 eat some yellow great

268
00:15:19,910 --> 00:15:22,800
 

269
00:15:19,920 --> 00:15:25,680
 and the strickland proudly has learned

270
00:15:22,790 --> 00:15:25,680
 

271
00:15:22,800 --> 00:15:27,720
 at some point how to eat a grain and so

272
00:15:25,670 --> 00:15:27,720
 

273
00:15:25,680 --> 00:15:29,779
 now in order to eat in this case

274
00:15:27,710 --> 00:15:29,779
 

275
00:15:27,720 --> 00:15:33,089
 probably something like it doesn't

276
00:15:29,769 --> 00:15:33,089
 

277
00:15:29,779 --> 00:15:35,310
 pieces of grain it executes the eat

278
00:15:33,079 --> 00:15:35,310
 

279
00:15:33,089 --> 00:15:37,050
 grain subroutine for every one of those

280
00:15:35,300 --> 00:15:37,050
 

281
00:15:35,310 --> 00:15:38,910
 crimes and then it moves its attention

282
00:15:37,040 --> 00:15:38,910
 

283
00:15:37,050 --> 00:15:39,870
 to something else execute this routine

284
00:15:38,900 --> 00:15:39,870
 

285
00:15:38,910 --> 00:15:41,670
 again and so on

286
00:15:39,860 --> 00:15:41,670
 

287
00:15:39,870 --> 00:15:43,769
 so in other words that Chiclets didn't

288
00:15:41,660 --> 00:15:43,769
 

289
00:15:41,670 --> 00:15:46,079
 have to learn to eat grain routine for

290
00:15:43,759 --> 00:15:46,079
 

291
00:15:43,769 --> 00:15:47,639
 one or two or three or four and five

292
00:15:46,069 --> 00:15:47,639
 

293
00:15:46,079 --> 00:15:49,860
 pieces of grains but it just had to

294
00:15:47,629 --> 00:15:49,860
 

295
00:15:47,639 --> 00:15:53,010
 learn that subroutine and now it could

296
00:15:49,850 --> 00:15:53,010
 

297
00:15:49,860 --> 00:15:56,010
 iterate and apply it so this makes

298
00:15:53,000 --> 00:15:56,010
 

299
00:15:53,010 --> 00:15:58,470
 things a lot more modular and in machine

300
00:15:56,000 --> 00:15:58,470
 

301
00:15:56,010 --> 00:16:01,410
 learning parlance this means also that

302
00:15:58,460 --> 00:16:01,410
 

303
00:15:58,470 --> 00:16:05,399
 you have a much more nonparametric model

304
00:16:01,400 --> 00:16:05,399
 

305
00:16:01,410 --> 00:16:07,680
 that's really the key idea there so the

306
00:16:05,389 --> 00:16:07,680
 

307
00:16:05,399 --> 00:16:10,290
 question is of course can we steal those

308
00:16:07,670 --> 00:16:10,290
 

309
00:16:07,680 --> 00:16:13,769
 ideas and apply them to machine learning

310
00:16:10,280 --> 00:16:13,769
 

311
00:16:10,290 --> 00:16:16,139
 and if the past five six years are

312
00:16:13,759 --> 00:16:16,139
 

313
00:16:13,769 --> 00:16:20,190
 anything to go by the answer is very

314
00:16:16,129 --> 00:16:20,190
 

315
00:16:16,139 --> 00:16:22,440
 clearly and resoundingly yes um so I

316
00:16:20,180 --> 00:16:22,440
 

317
00:16:20,190 --> 00:16:25,649
 said to the past five six years actually

318
00:16:22,430 --> 00:16:25,649
 

319
00:16:22,440 --> 00:16:28,920
 turns out that if you will attention is

320
00:16:25,639 --> 00:16:28,920
 

321
00:16:25,649 --> 00:16:31,500
 an idea that's at least 55 years old if

322
00:16:28,910 --> 00:16:31,500
 

323
00:16:28,920 --> 00:16:33,180
 not older so I'm going to start with

324
00:16:31,490 --> 00:16:33,180
 

325
00:16:31,500 --> 00:16:35,100
 something that you may have heard of

326
00:16:33,170 --> 00:16:35,100
 

327
00:16:33,180 --> 00:16:37,769
 named it what's another I estimated from

328
00:16:35,090 --> 00:16:37,769
 

329
00:16:35,100 --> 00:16:39,779
 Statistics and they now look at pooling

330
00:16:37,759 --> 00:16:39,779
 

331
00:16:37,769 --> 00:16:42,779
 so single objects and hierarchical

332
00:16:39,769 --> 00:16:42,779
 

333
00:16:39,779 --> 00:16:44,699
 structures iterative pooling so this

334
00:16:42,769 --> 00:16:44,699
 

335
00:16:42,779 --> 00:16:47,190
 will get us to question answering for

336
00:16:44,689 --> 00:16:47,190
 

337
00:16:44,699 --> 00:16:50,190
 images in text in memory networks and

338
00:16:47,180 --> 00:16:50,190
 

339
00:16:47,190 --> 00:16:51,720
 then iterative pooling in generation so

340
00:16:50,180 --> 00:16:51,720
 

341
00:16:50,190 --> 00:16:54,329
 in this case we don't just iterate over

342
00:16:51,710 --> 00:16:54,329
 

343
00:16:51,720 --> 00:16:55,829
 our state but we emit things at every

344
00:16:54,319 --> 00:16:55,829
 

345
00:16:54,329 --> 00:16:57,810
 step and that gives you machine

346
00:16:55,819 --> 00:16:57,810
 

347
00:16:55,829 --> 00:17:00,329
 translation pointer networks and other

348
00:16:57,800 --> 00:17:00,329
 

349
00:16:57,810 --> 00:17:02,279
 things and then of course because the

350
00:17:00,319 --> 00:17:02,279
 

351
00:17:00,329 --> 00:17:03,750
 tension is good multiple pieces of

352
00:17:02,269 --> 00:17:03,750
 

353
00:17:02,279 --> 00:17:04,890
 attention are even better and that'll

354
00:17:03,740 --> 00:17:04,890
 

355
00:17:03,750 --> 00:17:07,980
 get us to transformers

356
00:17:04,880 --> 00:17:07,980
 

357
00:17:04,890 --> 00:17:11,280
 in part and then we'll conclude with a

358
00:17:07,970 --> 00:17:11,280
 

359
00:17:07,980 --> 00:17:14,189
 few pointers to where things currently

360
00:17:11,270 --> 00:17:14,189
 

361
00:17:11,280 --> 00:17:16,740
 are at in this context basically light

362
00:17:14,179 --> 00:17:16,740
 

363
00:17:14,189 --> 00:17:17,819
 weights structured sparse models and

364
00:17:16,730 --> 00:17:17,819
 

365
00:17:16,740 --> 00:17:19,740
 then the end we'll talk a little bit

366
00:17:17,809 --> 00:17:19,740
 

367
00:17:17,819 --> 00:17:22,160
 about some resources to help you get

368
00:17:19,730 --> 00:17:22,160
 

369
00:17:19,740 --> 00:17:22,160
 started

370
00:17:22,390 --> 00:17:22,390
 

371
00:17:22,400 --> 00:17:28,730
 so let's start with something very very

372
00:17:26,110 --> 00:17:28,730
 

373
00:17:26,120 --> 00:17:33,320
 old so Jeff Watson into this very odd

374
00:17:28,720 --> 00:17:33,320
 

375
00:17:28,730 --> 00:17:35,600
 area independently in 1964 had an idea

376
00:17:33,310 --> 00:17:35,600
 

377
00:17:33,320 --> 00:17:39,470
 of how to solve the following regression

378
00:17:35,590 --> 00:17:39,470
 

379
00:17:35,600 --> 00:17:41,930
 problem or something like this so if you

380
00:17:39,460 --> 00:17:41,930
 

381
00:17:39,470 --> 00:17:43,340
 look at that it's basically you know

382
00:17:41,920 --> 00:17:43,340
 

383
00:17:41,930 --> 00:17:45,290
 sign function with a little bit of noise

384
00:17:43,330 --> 00:17:45,290
 

385
00:17:43,340 --> 00:17:49,640
 added and they observed those five

386
00:17:45,280 --> 00:17:49,640
 

387
00:17:45,290 --> 00:17:53,690
 points so in other words have some data

388
00:17:49,630 --> 00:17:53,690
 

389
00:17:49,640 --> 00:18:00,440
 X I and labels Y I they want to estimate

390
00:17:53,680 --> 00:18:00,440
 

391
00:17:53,690 --> 00:18:03,170
 Y at the new location X obviously right

392
00:18:00,430 --> 00:18:03,170
 

393
00:18:00,440 --> 00:18:05,720
 so what I could do is I could design the

394
00:18:03,160 --> 00:18:05,720
 

395
00:18:03,170 --> 00:18:07,880
 world's dumbest estimator well maybe not

396
00:18:05,710 --> 00:18:07,880
 

397
00:18:05,720 --> 00:18:09,530
 the very dumbest but pretty close to

398
00:18:07,870 --> 00:18:09,530
 

399
00:18:07,880 --> 00:18:11,870
 that and what I could do is I could say

400
00:18:09,520 --> 00:18:11,870
 

401
00:18:09,530 --> 00:18:13,520
 well it's just average over all the

402
00:18:11,860 --> 00:18:13,520
 

403
00:18:11,870 --> 00:18:14,929
 labels that I've seen so let's assume

404
00:18:13,510 --> 00:18:14,929
 

405
00:18:13,520 --> 00:18:16,580
 there's a regression problem otherwise

406
00:18:14,919 --> 00:18:16,580
 

407
00:18:14,929 --> 00:18:18,800
 it gets a little bit more interesting

408
00:18:16,570 --> 00:18:18,800
 

409
00:18:16,580 --> 00:18:22,040
 but I can't just do is I can say well

410
00:18:18,790 --> 00:18:22,040
 

411
00:18:18,800 --> 00:18:24,700
 why is the average over all the Y's in

412
00:18:22,030 --> 00:18:24,700
 

413
00:18:22,040 --> 00:18:29,330
 other words completely ignore the XS and

414
00:18:24,690 --> 00:18:29,330
 

415
00:18:24,700 --> 00:18:32,480
 just use the wires and the average if we

416
00:18:29,320 --> 00:18:32,480
 

417
00:18:29,330 --> 00:18:33,890
 do that well if you look at the graph on

418
00:18:32,470 --> 00:18:33,890
 

419
00:18:32,480 --> 00:18:36,440
 the right hand side well you get the

420
00:18:33,880 --> 00:18:36,440
 

421
00:18:33,890 --> 00:18:39,530
 constant function and that sounds dumb

422
00:18:36,430 --> 00:18:39,530
 

423
00:18:36,440 --> 00:18:42,770
 but it's actually not that bad

424
00:18:39,520 --> 00:18:42,770
 

425
00:18:39,530 --> 00:18:45,440
 quite often of course you can do better

426
00:18:42,760 --> 00:18:45,440
 

427
00:18:42,770 --> 00:18:48,280
 and so the idea independently proposed

428
00:18:45,430 --> 00:18:48,280
 

429
00:18:45,440 --> 00:18:51,920
 by Jeff Watts name is Bernard Aria in

430
00:18:48,270 --> 00:18:51,920
 

431
00:18:48,280 --> 00:18:54,190
 1964 was well let's actually weigh those

432
00:18:51,910 --> 00:18:54,190
 

433
00:18:51,920 --> 00:18:56,690
 labels according to the location in

434
00:18:54,180 --> 00:18:56,690
 

435
00:18:54,190 --> 00:19:00,410
 other words let's have some weighting

436
00:18:56,680 --> 00:19:00,410
 

437
00:18:56,690 --> 00:19:03,800
 function alpha that depends on X and X I

438
00:19:00,400 --> 00:19:03,800
 

439
00:19:00,410 --> 00:19:06,460
 and Y I and then use that to come up

440
00:19:03,790 --> 00:19:06,460
 

441
00:19:03,800 --> 00:19:11,660
 with a good estimate like a regression

442
00:19:06,450 --> 00:19:11,660
 

443
00:19:06,460 --> 00:19:13,820
 and so if we unpack this and rename

444
00:19:11,650 --> 00:19:13,820
 

445
00:19:11,660 --> 00:19:17,150
 things in the parlance of how people now

446
00:19:13,810 --> 00:19:17,150
 

447
00:19:13,820 --> 00:19:20,600
 do that for you know attention in deep

448
00:19:17,140 --> 00:19:20,600
 

449
00:19:17,150 --> 00:19:22,940
 learning then this function alpha takes

450
00:19:20,590 --> 00:19:22,940
 

451
00:19:20,600 --> 00:19:24,590
 two arguments it takes a query namely X

452
00:19:22,930 --> 00:19:24,590
 

453
00:19:22,940 --> 00:19:28,280
 this is the location where I want to

454
00:19:24,580 --> 00:19:28,280
 

455
00:19:24,590 --> 00:19:30,440
 perform my regression have a key X I so

456
00:19:28,270 --> 00:19:30,440
 

457
00:19:28,280 --> 00:19:33,919
 that's the

458
00:19:30,430 --> 00:19:33,919
 

459
00:19:30,440 --> 00:19:35,419
 set of coverage that I'm using and I'm

460
00:19:33,909 --> 00:19:35,419
 

461
00:19:33,919 --> 00:19:38,780
 basically looking at the distance

462
00:19:35,409 --> 00:19:38,780
 

463
00:19:35,419 --> 00:19:42,860
 between X and X I and then I have some

464
00:19:38,770 --> 00:19:42,860
 

465
00:19:38,780 --> 00:19:44,570
 value Y I in some cases sometimes the

466
00:19:42,850 --> 00:19:44,570
 

467
00:19:42,860 --> 00:19:46,820
 key and the value will be the same later

468
00:19:44,560 --> 00:19:46,820
 

469
00:19:44,570 --> 00:19:49,309
 on and sometimes even the query will be

470
00:19:46,810 --> 00:19:49,309
 

471
00:19:46,820 --> 00:19:51,200
 the same or related and we'll call that

472
00:19:49,299 --> 00:19:51,200
 

473
00:19:49,309 --> 00:19:52,880
 self attention and so on but for now

474
00:19:51,190 --> 00:19:52,880
 

475
00:19:51,200 --> 00:19:57,860
 let's just assume that I have a query

476
00:19:52,870 --> 00:19:57,860
 

477
00:19:52,880 --> 00:20:00,049
 key and a value and this is it's very

478
00:19:57,850 --> 00:20:00,049
 

479
00:19:57,860 --> 00:20:01,580
 hard the attention mechanisms if you

480
00:20:00,039 --> 00:20:01,580
 

481
00:20:00,049 --> 00:20:03,860
 remember nothing else from the entire

482
00:20:01,570 --> 00:20:03,860
 

483
00:20:01,580 --> 00:20:07,909
 tutorial than that you've already made

484
00:20:03,850 --> 00:20:07,909
 

485
00:20:03,860 --> 00:20:09,530
 big progress ok so now of course let's

486
00:20:07,899 --> 00:20:09,530
 

487
00:20:07,909 --> 00:20:13,010
 look at what those weighting functions

488
00:20:09,520 --> 00:20:13,010
 

489
00:20:09,530 --> 00:20:14,900
 might look like for instance I could

490
00:20:13,000 --> 00:20:14,900
 

491
00:20:13,010 --> 00:20:18,770
 take a calcium so I could take the

492
00:20:14,890 --> 00:20:18,770
 

493
00:20:14,900 --> 00:20:22,250
 squared distance between you know key

494
00:20:18,760 --> 00:20:22,250
 

495
00:20:18,770 --> 00:20:24,049
 and query so between x and x i.e to the

496
00:20:22,240 --> 00:20:24,049
 

497
00:20:22,250 --> 00:20:26,059
 minus 1/2 that or maybe some other

498
00:20:24,039 --> 00:20:26,059
 

499
00:20:24,049 --> 00:20:30,200
 coefficient up front and i get those

500
00:20:26,049 --> 00:20:30,200
 

501
00:20:26,059 --> 00:20:32,360
 nice little bumps there and you can

502
00:20:30,190 --> 00:20:32,360
 

503
00:20:30,200 --> 00:20:34,880
 already see that this isn't quite the

504
00:20:32,350 --> 00:20:34,880
 

505
00:20:32,360 --> 00:20:38,780
 answer yet because those weights may sum

506
00:20:34,870 --> 00:20:38,780
 

507
00:20:34,880 --> 00:20:41,510
 up to more than 1 or less than 1 so

508
00:20:38,770 --> 00:20:41,510
 

509
00:20:38,780 --> 00:20:43,880
 that's not quite the solution what you

510
00:20:41,500 --> 00:20:43,880
 

511
00:20:41,510 --> 00:20:45,200
 want is that your weights always sum up

512
00:20:43,870 --> 00:20:45,200
 

513
00:20:43,880 --> 00:20:47,390
 to 1 such that you get the weighted

514
00:20:45,190 --> 00:20:47,390
 

515
00:20:45,200 --> 00:20:50,299
 average and there's nothing easier to do

516
00:20:47,380 --> 00:20:50,299
 

517
00:20:47,390 --> 00:20:53,000
 that then to normalize them and this is

518
00:20:50,289 --> 00:20:53,000
 

519
00:20:50,299 --> 00:20:56,000
 by default actually the normalization

520
00:20:52,990 --> 00:20:56,000
 

521
00:20:53,000 --> 00:20:59,059
 approach that people use so what you

522
00:20:55,990 --> 00:20:59,059
 

523
00:20:56,000 --> 00:21:01,940
 just do is use sum over you know all the

524
00:20:59,049 --> 00:21:01,940
 

525
00:20:59,059 --> 00:21:04,840
 K of XJ and X and use that as a

526
00:21:01,930 --> 00:21:04,840
 

527
00:21:01,940 --> 00:21:10,520
 normalization factor for the K of X in X

528
00:21:04,830 --> 00:21:10,520
 

529
00:21:04,840 --> 00:21:13,039
 and if you do that you get that so the

530
00:21:10,510 --> 00:21:13,039
 

531
00:21:10,520 --> 00:21:16,340
 orange function is now my regression

532
00:21:13,029 --> 00:21:16,340
 

533
00:21:13,039 --> 00:21:18,289
 estimate and the green function well

534
00:21:16,330 --> 00:21:18,289
 

535
00:21:16,340 --> 00:21:19,730
 that's the original ground truth but I

536
00:21:18,279 --> 00:21:19,730
 

537
00:21:18,289 --> 00:21:24,740
 don't really have that at my disposal

538
00:21:19,720 --> 00:21:24,740
 

539
00:21:19,730 --> 00:21:27,039
 all I have is just those 5 dots I'm

540
00:21:24,730 --> 00:21:27,039
 

541
00:21:24,740 --> 00:21:29,720
 given that it's actually not too bad

542
00:21:27,029 --> 00:21:29,720
 

543
00:21:27,039 --> 00:21:32,150
 because after all there's no way our

544
00:21:29,710 --> 00:21:32,150
 

545
00:21:29,720 --> 00:21:35,659
 regression estimator have any way of

546
00:21:32,140 --> 00:21:35,659
 

547
00:21:32,150 --> 00:21:37,820
 knowing that for instance as you know X

548
00:21:35,649 --> 00:21:37,820
 

549
00:21:35,659 --> 00:21:40,220
 becomes more positive the green function

550
00:21:37,810 --> 00:21:40,220
 

551
00:21:37,820 --> 00:21:42,490
 decreases again as a matter of fact if

552
00:21:40,210 --> 00:21:42,490
 

553
00:21:40,220 --> 00:21:44,140
 anything is go Y if you look at the

554
00:21:42,480 --> 00:21:44,140
 

555
00:21:42,490 --> 00:21:46,390
 starts on the right you might think that

556
00:21:44,130 --> 00:21:46,390
 

557
00:21:44,140 --> 00:21:48,450
 the function will keep on increasing so

558
00:21:46,380 --> 00:21:48,450
 

559
00:21:46,390 --> 00:21:55,000
 that's about as good as it gets

560
00:21:48,440 --> 00:21:55,000
 

561
00:21:48,450 --> 00:22:01,210
 okay so this is attention in the style

562
00:21:54,990 --> 00:22:01,210
 

563
00:21:55,000 --> 00:22:02,350
 of 1964 okay you're wondering like I

564
00:22:01,200 --> 00:22:02,350
 

565
00:22:01,210 --> 00:22:05,050
 mean you've come to deep learning

566
00:22:02,340 --> 00:22:05,050
 

567
00:22:02,350 --> 00:22:07,570
 tutorial right and I'm telling you

568
00:22:05,040 --> 00:22:07,570
 

569
00:22:05,050 --> 00:22:08,800
 really old statistics things right you

570
00:22:07,560 --> 00:22:08,800
 

571
00:22:07,570 --> 00:22:10,000
 know why bother about something that's

572
00:22:08,790 --> 00:22:10,000
 

573
00:22:08,800 --> 00:22:13,360
 fifty five years old

574
00:22:09,990 --> 00:22:13,360
 

575
00:22:10,000 --> 00:22:16,059
 most of us are less than that old right

576
00:22:13,350 --> 00:22:16,059
 

577
00:22:13,360 --> 00:22:18,760
 so well one of the really nice

578
00:22:16,049 --> 00:22:18,760
 

579
00:22:16,059 --> 00:22:21,429
 properties about this really ancient

580
00:22:18,750 --> 00:22:21,429
 

581
00:22:18,760 --> 00:22:22,990
 algorithm is that it's consistent so

582
00:22:21,419 --> 00:22:22,990
 

583
00:22:21,429 --> 00:22:25,480
 what that means is given enough data

584
00:22:22,980 --> 00:22:25,480
 

585
00:22:22,990 --> 00:22:28,809
 this algorithm actually does converge to

586
00:22:25,470 --> 00:22:28,809
 

587
00:22:25,480 --> 00:22:31,360
 the optimal solution right and for many

588
00:22:28,799 --> 00:22:31,360
 

589
00:22:28,809 --> 00:22:34,510
 deep networks proving that is actually a

590
00:22:31,350 --> 00:22:34,510
 

591
00:22:31,360 --> 00:22:36,730
 lot of work and in many cases it might

592
00:22:34,500 --> 00:22:36,730
 

593
00:22:34,510 --> 00:22:38,410
 not be possible if I have a neural

594
00:22:36,720 --> 00:22:38,410
 

595
00:22:36,730 --> 00:22:43,240
 network with a fixed number of weights

596
00:22:38,400 --> 00:22:43,240
 

597
00:22:38,410 --> 00:22:45,700
 let's say I take a resonant 50 the

598
00:22:43,230 --> 00:22:45,700
 

599
00:22:43,240 --> 00:22:49,330
 improving that to us will converge to

600
00:22:45,690 --> 00:22:49,330
 

601
00:22:45,700 --> 00:22:51,010
 the optimal classifier if I take data

602
00:22:49,320 --> 00:22:51,010
 

603
00:22:49,330 --> 00:22:53,980
 like from imagenet but an infinite

604
00:22:51,000 --> 00:22:53,980
 

605
00:22:51,010 --> 00:22:55,050
 amount of that well that's probably not

606
00:22:53,970 --> 00:22:55,050
 

607
00:22:53,980 --> 00:22:58,540
 gonna happen

608
00:22:55,040 --> 00:22:58,540
 

609
00:22:55,050 --> 00:23:00,910
 this ancient algorithm actually beats it

610
00:22:58,530 --> 00:23:00,910
 

611
00:22:58,540 --> 00:23:02,350
 in that property I mean of course you

612
00:23:00,900 --> 00:23:02,350
 

613
00:23:00,910 --> 00:23:04,059
 should I'm not arguing that you should

614
00:23:02,340 --> 00:23:04,059
 

615
00:23:02,350 --> 00:23:06,250
 use the what's another is tomato for

616
00:23:04,049 --> 00:23:06,250
 

617
00:23:04,059 --> 00:23:07,809
 image classification but if you look at

618
00:23:06,240 --> 00:23:07,809
 

619
00:23:06,250 --> 00:23:10,720
 it theoretical properties in what's

620
00:23:07,799 --> 00:23:10,720
 

621
00:23:07,809 --> 00:23:12,370
 known about it it's pretty good the

622
00:23:10,710 --> 00:23:12,370
 

623
00:23:10,720 --> 00:23:14,800
 other nice thing is that well it doesn't

624
00:23:12,360 --> 00:23:14,800
 

625
00:23:12,370 --> 00:23:17,050
 really have any free parameters right so

626
00:23:14,790 --> 00:23:17,050
 

627
00:23:14,800 --> 00:23:22,080
 I just take the data I weigh it and

628
00:23:17,040 --> 00:23:22,080
 

629
00:23:17,050 --> 00:23:24,309
 presto I have my regression estimator so

630
00:23:22,070 --> 00:23:24,309
 

631
00:23:22,080 --> 00:23:27,730
 what can we learn about it for today

632
00:23:24,299 --> 00:23:27,730
 

633
00:23:24,309 --> 00:23:29,650
 well of course we can make this deep so

634
00:23:27,720 --> 00:23:29,650
 

635
00:23:27,730 --> 00:23:31,870
 I might want to learn a weighting

636
00:23:29,640 --> 00:23:31,870
 

637
00:23:29,650 --> 00:23:34,570
 function and I might want to replace

638
00:23:31,860 --> 00:23:34,570
 

639
00:23:31,870 --> 00:23:38,710
 therefore averaging pooling operations

640
00:23:34,560 --> 00:23:38,710
 

641
00:23:34,570 --> 00:23:41,770
 by weighted pooling and this is kind of

642
00:23:38,700 --> 00:23:41,770
 

643
00:23:38,710 --> 00:23:44,290
 the marching orders for how to use

644
00:23:41,760 --> 00:23:44,290
 

645
00:23:41,770 --> 00:23:48,970
 attention in its simplest form namely

646
00:23:44,280 --> 00:23:48,970
 

647
00:23:44,290 --> 00:23:51,400
 for pooling okay so now that everybody's

648
00:23:48,960 --> 00:23:51,400
 

649
00:23:48,970 --> 00:23:52,530
 in the room let's scan let's start with

650
00:23:51,390 --> 00:23:52,530
 

651
00:23:51,400 --> 00:23:59,070
 the fun stuff right

652
00:23:52,520 --> 00:23:59,070
 

653
00:23:52,530 --> 00:24:03,390
 fooling so this is algorithm called deep

654
00:23:59,060 --> 00:24:03,390
 

655
00:23:59,070 --> 00:24:05,580
 says and essentially so my silks are

656
00:24:03,380 --> 00:24:05,580
 

657
00:24:03,390 --> 00:24:09,090
 here and others seem see what we did in

658
00:24:05,570 --> 00:24:09,090
 

659
00:24:05,580 --> 00:24:11,190
 this algorithm is we ask the question

660
00:24:09,080 --> 00:24:11,190
 

661
00:24:09,090 --> 00:24:15,179
 well if I want to define a function on a

662
00:24:11,180 --> 00:24:15,179
 

663
00:24:11,190 --> 00:24:17,280
 set so with that it means that it needs

664
00:24:15,169 --> 00:24:17,280
 

665
00:24:15,179 --> 00:24:19,950
 to be permutation invariant in other

666
00:24:17,270 --> 00:24:19,950
 

667
00:24:17,280 --> 00:24:21,929
 words if I give you you know f of the

668
00:24:19,940 --> 00:24:21,929
 

669
00:24:19,950 --> 00:24:24,090
 set or if I go and permute the elements

670
00:24:21,919 --> 00:24:24,090
 

671
00:24:21,929 --> 00:24:28,380
 of the set I always want to get the same

672
00:24:24,080 --> 00:24:28,380
 

673
00:24:24,090 --> 00:24:30,720
 answer and if you apply this constraints

674
00:24:28,370 --> 00:24:30,720
 

675
00:24:28,380 --> 00:24:32,549
 of this invariance and ask well what's

676
00:24:30,710 --> 00:24:32,549
 

677
00:24:30,720 --> 00:24:35,549
 the general class of functions that I

678
00:24:32,539 --> 00:24:35,549
 

679
00:24:32,549 --> 00:24:40,260
 could possibly get then it turns out

680
00:24:35,539 --> 00:24:40,260
 

681
00:24:35,549 --> 00:24:43,080
 that with some minor footnotes this into

682
00:24:40,250 --> 00:24:43,080
 

683
00:24:40,260 --> 00:24:47,100
 this function can be written as sum not

684
00:24:43,070 --> 00:24:47,100
 

685
00:24:43,080 --> 00:24:49,980
 on a linearity of the sum of some other

686
00:24:47,090 --> 00:24:49,980
 

687
00:24:47,100 --> 00:24:54,120
 non-linearity of each element of the set

688
00:24:49,970 --> 00:24:54,120
 

689
00:24:49,980 --> 00:24:57,240
 applied individually in other words take

690
00:24:54,110 --> 00:24:57,240
 

691
00:24:54,120 --> 00:25:01,380
 every limit from the set X apply Phi to

692
00:24:57,230 --> 00:25:01,380
 

693
00:24:57,240 --> 00:25:03,120
 it sum it up apply row to it and this

694
00:25:01,370 --> 00:25:03,120
 

695
00:25:01,380 --> 00:25:05,460
 works really beautifully and you can use

696
00:25:03,110 --> 00:25:05,460
 

697
00:25:03,120 --> 00:25:07,799
 it for point clouds set extension or

698
00:25:05,450 --> 00:25:07,799
 

699
00:25:05,460 --> 00:25:11,600
 redshift or galaxies or text retrieval

700
00:25:07,789 --> 00:25:11,600
 

701
00:25:07,799 --> 00:25:13,890
 or tagging and so on or graphs right

702
00:25:11,590 --> 00:25:13,890
 

703
00:25:11,600 --> 00:25:16,320
 basically anywhere where you have

704
00:25:13,880 --> 00:25:16,320
 

705
00:25:13,890 --> 00:25:17,880
 permutation invariants you can

706
00:25:16,310 --> 00:25:17,880
 

707
00:25:16,320 --> 00:25:20,580
 immediately apply this hammer and say

708
00:25:17,870 --> 00:25:20,580
 

709
00:25:17,880 --> 00:25:22,980
 okay well this drastically reduces my

710
00:25:20,570 --> 00:25:22,980
 

711
00:25:20,580 --> 00:25:24,929
 function class the things that I need to

712
00:25:22,970 --> 00:25:24,929
 

713
00:25:22,980 --> 00:25:28,559
 learn and I just need to learn us two

714
00:25:24,919 --> 00:25:28,559
 

715
00:25:24,929 --> 00:25:30,570
 nonlinearities and I'm done so for

716
00:25:28,549 --> 00:25:30,570
 

717
00:25:28,559 --> 00:25:34,980
 instance you can use that to detect

718
00:25:30,560 --> 00:25:34,980
 

719
00:25:30,570 --> 00:25:37,650
 outliers in sets of images and so these

720
00:25:34,970 --> 00:25:37,650
 

721
00:25:34,980 --> 00:25:40,620
 are some pictures and basically we

722
00:25:37,640 --> 00:25:40,620
 

723
00:25:37,650 --> 00:25:43,470
 inserted you know an outlier in each of

724
00:25:40,610 --> 00:25:43,470
 

725
00:25:40,620 --> 00:25:46,860
 those and we had a network determine

726
00:25:43,460 --> 00:25:46,860
 

727
00:25:43,470 --> 00:25:48,890
 what the outlier might be and in a fair

728
00:25:46,850 --> 00:25:48,890
 

729
00:25:46,860 --> 00:25:51,450
 number of cases actually gets it right

730
00:25:48,880 --> 00:25:51,450
 

731
00:25:48,890 --> 00:25:55,049
 doesn't get it right in the middle but

732
00:25:51,440 --> 00:25:55,049
 

733
00:25:51,450 --> 00:25:57,179
 you know try for yourself to you know

734
00:25:55,039 --> 00:25:57,179
 

735
00:25:55,049 --> 00:25:59,630
 see whether you cannot easily identify

736
00:25:57,169 --> 00:25:59,630
 

737
00:25:57,179 --> 00:26:02,470
 that and

738
00:25:59,620 --> 00:26:02,470
 

739
00:25:59,630 --> 00:26:05,350
 so in the middle the idea was you know

740
00:26:02,460 --> 00:26:05,350
 

741
00:26:02,470 --> 00:26:07,730
 double chin and wavy hair and if you

742
00:26:05,340 --> 00:26:07,730
 

743
00:26:05,350 --> 00:26:10,970
 don't have that well it's not so good

744
00:26:07,720 --> 00:26:10,970
 

745
00:26:07,730 --> 00:26:12,380
 but okay try by yourself so it's

746
00:26:10,960 --> 00:26:12,380
 

747
00:26:10,970 --> 00:26:16,220
 actually quite surprising that he gets

748
00:26:12,370 --> 00:26:16,220
 

749
00:26:12,380 --> 00:26:19,419
 this right um okay so this is a very

750
00:26:16,210 --> 00:26:19,419
 

751
00:26:16,220 --> 00:26:22,429
 simple averaging pooling operation so

752
00:26:19,409 --> 00:26:22,429
 

753
00:26:19,419 --> 00:26:24,950
 drumroll please of course there's an

754
00:26:22,419 --> 00:26:24,950
 

755
00:26:22,429 --> 00:26:25,970
 attention version of this so last year I

756
00:26:24,940 --> 00:26:25,970
 

757
00:26:24,950 --> 00:26:28,820
 think it I clear

758
00:26:25,960 --> 00:26:28,820
 

759
00:26:25,970 --> 00:26:31,760
 Ilse Tom Chuck and Welling used the same

760
00:26:28,810 --> 00:26:31,760
 

761
00:26:28,820 --> 00:26:35,030
 idea and extended it with attention

762
00:26:31,750 --> 00:26:35,030
 

763
00:26:31,760 --> 00:26:37,820
 waiting so the problem they tried to

764
00:26:35,020 --> 00:26:37,820
 

765
00:26:35,030 --> 00:26:40,340
 solve is one for which attention waiting

766
00:26:37,810 --> 00:26:40,340
 

767
00:26:37,820 --> 00:26:43,909
 is actually really quite useful namely

768
00:26:40,330 --> 00:26:43,909
 

769
00:26:40,340 --> 00:26:47,049
 multiple instance learning so imagine

770
00:26:43,899 --> 00:26:47,049
 

771
00:26:43,909 --> 00:26:50,270
 you want to do drug discovery and so you

772
00:26:47,039 --> 00:26:50,270
 

773
00:26:47,049 --> 00:26:52,940
 know inject you animal you know your lab

774
00:26:50,260 --> 00:26:52,940
 

775
00:26:50,270 --> 00:26:55,970
 rat or whatever with a cocktail of drugs

776
00:26:52,930 --> 00:26:55,970
 

777
00:26:52,940 --> 00:26:58,880
 right and you didn't check whether you

778
00:26:55,960 --> 00:26:58,880
 

779
00:26:55,970 --> 00:27:02,570
 know the drug you know that lab rat gets

780
00:26:58,870 --> 00:27:02,570
 

781
00:26:58,880 --> 00:27:04,490
 better or worse and you know if it does

782
00:27:02,560 --> 00:27:04,490
 

783
00:27:02,570 --> 00:27:06,830
 in assuming that those drugs don't

784
00:27:04,480 --> 00:27:06,830
 

785
00:27:04,490 --> 00:27:09,919
 interact with each other well you can

786
00:27:06,820 --> 00:27:09,919
 

787
00:27:06,830 --> 00:27:12,140
 therefore conclude that maybe there was

788
00:27:09,909 --> 00:27:12,140
 

789
00:27:09,919 --> 00:27:15,230
 one drug in that cocktail that actually

790
00:27:12,130 --> 00:27:15,230
 

791
00:27:12,140 --> 00:27:17,570
 made the lab rat healthy again okay

792
00:27:15,220 --> 00:27:17,570
 

793
00:27:15,230 --> 00:27:19,640
 sounds good the promise you don't know

794
00:27:17,560 --> 00:27:19,640
 

795
00:27:17,570 --> 00:27:21,470
 which one it is and of course you can go

796
00:27:19,630 --> 00:27:21,470
 

797
00:27:19,640 --> 00:27:24,770
 and you know do it while having and all

798
00:27:21,460 --> 00:27:24,770
 

799
00:27:21,470 --> 00:27:26,750
 of that and but then actually doing this

800
00:27:24,760 --> 00:27:26,750
 

801
00:27:24,770 --> 00:27:28,190
 properly and synthesizing you know the

802
00:27:26,740 --> 00:27:28,190
 

803
00:27:26,750 --> 00:27:30,650
 corresponding cocktails and all of that

804
00:27:28,180 --> 00:27:30,650
 

805
00:27:28,190 --> 00:27:32,870
 is quite late they were intensive so

806
00:27:30,640 --> 00:27:32,870
 

807
00:27:30,650 --> 00:27:34,700
 maybe you can do better otherwise this

808
00:27:32,860 --> 00:27:34,700
 

809
00:27:32,870 --> 00:27:37,460
 is called a multiple instance problem

810
00:27:34,690 --> 00:27:37,460
 

811
00:27:34,700 --> 00:27:39,080
 another application like a model

812
00:27:37,450 --> 00:27:39,080
 

813
00:27:37,460 --> 00:27:41,600
 applications if you have a big key ring

814
00:27:39,070 --> 00:27:41,600
 

815
00:27:39,080 --> 00:27:43,760
 with many many keys on it and the key

816
00:27:41,590 --> 00:27:43,760
 

817
00:27:41,600 --> 00:27:45,710
 ring opens the door if one of the keys

818
00:27:43,750 --> 00:27:45,710
 

819
00:27:43,760 --> 00:27:48,200
 opens it but I'm not going to tell you

820
00:27:45,700 --> 00:27:48,200
 

821
00:27:45,710 --> 00:27:51,080
 which one and you goal is to find out

822
00:27:48,190 --> 00:27:51,080
 

823
00:27:48,200 --> 00:27:54,919
 whether you know a certain keyring and

824
00:27:51,070 --> 00:27:54,919
 

825
00:27:51,080 --> 00:27:57,740
 thus a certain key opens the door so one

826
00:27:54,909 --> 00:27:57,740
 

827
00:27:54,919 --> 00:28:00,890
 way of doing this a little bit better is

828
00:27:57,730 --> 00:28:00,890
 

829
00:27:57,740 --> 00:28:04,039
 to learn an attention function which

830
00:28:00,880 --> 00:28:04,039
 

831
00:28:00,890 --> 00:28:07,640
 helps us in this context to identify

832
00:28:04,029 --> 00:28:07,640
 

833
00:28:04,039 --> 00:28:09,500
 which of the keys or the drugs or

834
00:28:07,630 --> 00:28:09,500
 

835
00:28:07,640 --> 00:28:11,660
 whatever other things might be relevant

836
00:28:09,490 --> 00:28:11,660
 

837
00:28:09,500 --> 00:28:15,740
 through attention writing

838
00:28:11,650 --> 00:28:15,740
 

839
00:28:11,660 --> 00:28:17,480
 some function alpha of w NX w can either

840
00:28:15,730 --> 00:28:17,480
 

841
00:28:15,740 --> 00:28:19,040
 be learned it can be you know query

842
00:28:17,470 --> 00:28:19,040
 

843
00:28:17,480 --> 00:28:24,800
 dependent maybe depending on a

844
00:28:19,030 --> 00:28:24,800
 

845
00:28:19,040 --> 00:28:26,360
 particular lock X is the key of for

846
00:28:24,790 --> 00:28:26,360
 

847
00:28:24,800 --> 00:28:28,040
 instance the key of the drug and then

848
00:28:26,350 --> 00:28:28,040
 

849
00:28:26,360 --> 00:28:31,820
 Phi of X will be the value that you

850
00:28:28,030 --> 00:28:31,820
 

851
00:28:28,040 --> 00:28:33,710
 aggregate popular choice for an

852
00:28:31,810 --> 00:28:33,710
 

853
00:28:31,820 --> 00:28:36,530
 attention function is e to the W

854
00:28:33,700 --> 00:28:36,530
 

855
00:28:33,710 --> 00:28:38,410
 transposed tange of V X but there are

856
00:28:36,520 --> 00:28:38,410
 

857
00:28:36,530 --> 00:28:42,230
 lots of other choices that you can pick

858
00:28:38,400 --> 00:28:42,230
 

859
00:28:38,410 --> 00:28:44,390
 and so turns out that this works quite

860
00:28:42,220 --> 00:28:44,390
 

861
00:28:42,230 --> 00:28:45,800
 beautifully as a matter of fact if it

862
00:28:44,380 --> 00:28:45,800
 

863
00:28:44,390 --> 00:28:48,740
 didn't probably wouldn't have this paper

864
00:28:45,790 --> 00:28:48,740
 

865
00:28:45,800 --> 00:28:51,380
 so in a toy experiment what they did is

866
00:28:48,730 --> 00:28:51,380
 

867
00:28:48,740 --> 00:28:55,730
 they looked at you know can we detect

868
00:28:51,370 --> 00:28:55,730
 

869
00:28:51,380 --> 00:28:58,010
 lines in a bag of digits because since

870
00:28:55,720 --> 00:28:58,010
 

871
00:28:55,730 --> 00:29:00,350
 the property was does it contain a line

872
00:28:58,000 --> 00:29:00,350
 

873
00:28:58,010 --> 00:29:02,330
 or not and guess what it's pretty good

874
00:29:00,340 --> 00:29:02,330
 

875
00:29:00,350 --> 00:29:03,710
 at detecting lines in this case there

876
00:29:02,320 --> 00:29:03,710
 

877
00:29:02,330 --> 00:29:08,330
 are four nines and they all get a body

878
00:29:03,700 --> 00:29:08,330
 

879
00:29:03,710 --> 00:29:10,160
 called weight um rather less frivolous

880
00:29:08,320 --> 00:29:10,160
 

881
00:29:08,330 --> 00:29:15,680
 application this would be this one there

882
00:29:10,150 --> 00:29:15,680
 

883
00:29:10,160 --> 00:29:17,420
 so deep set for well cancer so suppose I

884
00:29:15,670 --> 00:29:17,420
 

885
00:29:15,680 --> 00:29:21,140
 have a tissue sample like the one on the

886
00:29:17,410 --> 00:29:21,140
 

887
00:29:17,420 --> 00:29:25,630
 left and my goal is to identify whether

888
00:29:21,130 --> 00:29:25,630
 

889
00:29:21,140 --> 00:29:28,640
 it has any cancerous cells in there so a

890
00:29:25,620 --> 00:29:28,640
 

891
00:29:25,630 --> 00:29:31,760
 good strategy is first to identify what

892
00:29:28,630 --> 00:29:31,760
 

893
00:29:28,640 --> 00:29:32,990
 the cells themselves are and turns out

894
00:29:31,750 --> 00:29:32,990
 

895
00:29:31,760 --> 00:29:35,960
 that there are some subroutines that

896
00:29:32,980 --> 00:29:35,960
 

897
00:29:32,990 --> 00:29:40,610
 will very nicely allow me to pull out

898
00:29:35,950 --> 00:29:40,610
 

899
00:29:35,960 --> 00:29:42,260
 those windows cell nuclei looking at all

900
00:29:40,600 --> 00:29:42,260
 

901
00:29:40,610 --> 00:29:44,240
 the locations where those cells are

902
00:29:42,250 --> 00:29:44,240
 

903
00:29:42,260 --> 00:29:48,110
 putting you know the window around it so

904
00:29:44,230 --> 00:29:48,110
 

905
00:29:44,240 --> 00:29:50,420
 now I have turned this image into multi

906
00:29:48,100 --> 00:29:50,420
 

907
00:29:48,110 --> 00:29:53,450
 instance problem where effectively have

908
00:29:50,410 --> 00:29:53,450
 

909
00:29:50,420 --> 00:29:59,300
 a long list of pictures of the nuclei

910
00:29:53,440 --> 00:29:59,300
 

911
00:29:53,450 --> 00:30:00,560
 and the second image from the right this

912
00:29:59,290 --> 00:30:00,560
 

913
00:29:59,300 --> 00:30:03,320
 is a picture of all that kind of

914
00:30:00,550 --> 00:30:03,320
 

915
00:30:00,560 --> 00:30:05,060
 cancerous cells of course I don't know

916
00:30:03,310 --> 00:30:05,060
 

917
00:30:03,320 --> 00:30:08,930
 that I just know that well okay this

918
00:30:05,050 --> 00:30:08,930
 

919
00:30:05,060 --> 00:30:13,160
 person has cancer right but what I can

920
00:30:08,920 --> 00:30:13,160
 

921
00:30:08,930 --> 00:30:15,920
 do is it can now learn a set kernel

922
00:30:13,150 --> 00:30:15,920
 

923
00:30:13,160 --> 00:30:18,230
 visitor the deep set problem with

924
00:30:15,910 --> 00:30:18,230
 

925
00:30:15,920 --> 00:30:19,610
 attention waiting and I can look at the

926
00:30:18,220 --> 00:30:19,610
 

927
00:30:18,230 --> 00:30:22,550
 attention weights that I'm getting and

928
00:30:19,600 --> 00:30:22,550
 

929
00:30:19,610 --> 00:30:24,330
 it turns out that the attention weights

930
00:30:22,540 --> 00:30:24,330
 

931
00:30:22,550 --> 00:30:28,840
 are exactly what I would have expect

932
00:30:24,320 --> 00:30:28,840
 

933
00:30:24,330 --> 00:30:33,250
 so there you go and then they show that

934
00:30:28,830 --> 00:30:33,250
 

935
00:30:28,840 --> 00:30:36,370
 this actually works very well so this is

936
00:30:33,240 --> 00:30:36,370
 

937
00:30:33,250 --> 00:30:38,250
 about as simple an application as you

938
00:30:36,360 --> 00:30:38,250
 

939
00:30:36,370 --> 00:30:42,670
 can think of in the context of

940
00:30:38,240 --> 00:30:42,670
 

941
00:30:38,250 --> 00:30:44,770
 attentions and sets so anything that

942
00:30:42,660 --> 00:30:44,770
 

943
00:30:42,670 --> 00:30:46,390
 will do from now on will just repeat

944
00:30:44,760 --> 00:30:46,390
 

945
00:30:44,770 --> 00:30:47,710
 this pattern the only difference is that

946
00:30:46,380 --> 00:30:47,710
 

947
00:30:46,390 --> 00:30:48,990
 will make it a little bit more

948
00:30:47,700 --> 00:30:48,990
 

949
00:30:47,710 --> 00:30:52,570
 complicated

950
00:30:48,980 --> 00:30:52,570
 

951
00:30:48,990 --> 00:30:55,090
 so to recap what we're doing is we are

952
00:30:52,560 --> 00:30:55,090
 

953
00:30:52,570 --> 00:30:59,260
 basically pooling with an attention

954
00:30:55,080 --> 00:30:59,260
 

955
00:30:55,090 --> 00:31:02,410
 weight and then we have some embeddings

956
00:30:59,250 --> 00:31:02,410
 

957
00:30:59,260 --> 00:31:06,810
 of fireworks and this is what allows us

958
00:31:02,400 --> 00:31:06,810
 

959
00:31:02,410 --> 00:31:06,810
 to then come up to with some conclusion

960
00:31:06,950 --> 00:31:06,950
 

961
00:31:06,960 --> 00:31:14,230
 now here's a slightly more interesting

962
00:31:11,220 --> 00:31:14,230
 

963
00:31:11,230 --> 00:31:18,460
 application so suppose I want to

964
00:31:14,220 --> 00:31:18,460
 

965
00:31:14,230 --> 00:31:21,070
 classify documents right so what I could

966
00:31:18,450 --> 00:31:21,070
 

967
00:31:18,460 --> 00:31:24,130
 do is I could you know take my trusty

968
00:31:21,060 --> 00:31:24,130
 

969
00:31:21,070 --> 00:31:27,970
 word to vacuum embedding or maybe I used

970
00:31:24,120 --> 00:31:27,970
 

971
00:31:24,130 --> 00:31:30,370
 some you know just you know bag of words

972
00:31:27,960 --> 00:31:30,370
 

973
00:31:27,970 --> 00:31:33,340
 embedding right so just indicators like

974
00:31:30,360 --> 00:31:33,340
 

975
00:31:30,370 --> 00:31:35,620
 salt and McGill or I can use a zero you

976
00:31:33,330 --> 00:31:35,620
 

977
00:31:33,340 --> 00:31:38,020
 are an a-list eeehm and I basically take

978
00:31:35,610 --> 00:31:38,020
 

979
00:31:35,620 --> 00:31:39,760
 every word as we go along and I embed it

980
00:31:38,010 --> 00:31:39,760
 

981
00:31:38,020 --> 00:31:41,830
 and then in the end I get those

982
00:31:39,750 --> 00:31:41,830
 

983
00:31:39,760 --> 00:31:43,840
 competing vectors out for instance all

984
00:31:41,820 --> 00:31:43,840
 

985
00:31:41,830 --> 00:31:46,150
 the tutorial is awesome and of course

986
00:31:43,830 --> 00:31:46,150
 

987
00:31:43,840 --> 00:31:47,920
 the tutorial is is pretty boring for

988
00:31:46,140 --> 00:31:47,920
 

989
00:31:46,150 --> 00:31:51,400
 that regard but awesome is really the

990
00:31:47,910 --> 00:31:51,400
 

991
00:31:47,920 --> 00:31:54,940
 thing you care about um and then you

992
00:31:51,390 --> 00:31:54,940
 

993
00:31:51,400 --> 00:31:57,250
 know you're happy and so this is you

994
00:31:54,930 --> 00:31:57,250
 

995
00:31:54,940 --> 00:32:01,060
 know what people typically would do for

996
00:31:57,240 --> 00:32:01,060
 

997
00:31:57,250 --> 00:32:05,320
 a bag of words or a bag of embeddings to

998
00:32:01,050 --> 00:32:05,320
 

999
00:32:01,060 --> 00:32:07,600
 classify for instance sentiment well the

1000
00:32:05,310 --> 00:32:07,600
 

1001
00:32:05,320 --> 00:32:09,850
 trouble is that if this obnoxious Alex

1002
00:32:07,590 --> 00:32:09,850
 

1003
00:32:07,600 --> 00:32:12,460
 comes into play like Alex's of not just

1004
00:32:09,840 --> 00:32:12,460
 

1005
00:32:09,850 --> 00:32:15,340
 but the tutorial is awesome then things

1006
00:32:12,450 --> 00:32:15,340
 

1007
00:32:12,460 --> 00:32:16,660
 go badly wrong right because the Alex's

1008
00:32:15,330 --> 00:32:16,660
 

1009
00:32:15,340 --> 00:32:20,050
 of not just party specially the

1010
00:32:16,650 --> 00:32:20,050
 

1011
00:32:16,660 --> 00:32:22,480
 obnoxious piece in the but have negative

1012
00:32:20,040 --> 00:32:22,480
 

1013
00:32:20,050 --> 00:32:23,890
 connotations and they will completely

1014
00:32:22,470 --> 00:32:23,890
 

1015
00:32:22,480 --> 00:32:25,929
 swamp the rest

1016
00:32:23,880 --> 00:32:25,929
 

1017
00:32:23,890 --> 00:32:28,240
 I mean obviously not here for the Alex

1018
00:32:25,919 --> 00:32:28,240
 

1019
00:32:25,929 --> 00:32:29,470
 but you here for the tutorial so we all

1020
00:32:28,230 --> 00:32:29,470
 

1021
00:32:28,240 --> 00:32:32,530
 know that this should be still a

1022
00:32:29,460 --> 00:32:32,530
 

1023
00:32:29,470 --> 00:32:36,429
 positive sentiment but how deep network

1024
00:32:32,520 --> 00:32:36,429
 

1025
00:32:32,530 --> 00:32:41,679
 doesn't know so goal would be to ignore

1026
00:32:36,419 --> 00:32:41,679
 

1027
00:32:36,429 --> 00:32:44,290
 this and of course we already know what

1028
00:32:41,669 --> 00:32:44,290
 

1029
00:32:41,679 --> 00:32:48,760
 the answer has to be namely we can use

1030
00:32:44,280 --> 00:32:48,760
 

1031
00:32:44,290 --> 00:32:50,710
 attention waiting it's exactly what's

1032
00:32:48,750 --> 00:32:50,710
 

1033
00:32:48,760 --> 00:32:53,260
 wrong at all did in 2016

1034
00:32:50,700 --> 00:32:53,260
 

1035
00:32:50,710 --> 00:32:55,809
 actually they didn't use a bidirectional

1036
00:32:53,250 --> 00:32:55,809
 

1037
00:32:53,260 --> 00:32:57,850
 esteem or a GRE in the bottom they just

1038
00:32:55,799 --> 00:32:57,850
 

1039
00:32:55,809 --> 00:33:00,040
 use a unidirectional one but it doesn't

1040
00:32:57,840 --> 00:33:00,040
 

1041
00:32:57,850 --> 00:33:03,030
 really matter for this and so what you

1042
00:33:00,030 --> 00:33:03,030
 

1043
00:33:00,040 --> 00:33:06,250
 can do is you can just replace the

1044
00:33:03,020 --> 00:33:06,250
 

1045
00:33:03,030 --> 00:33:07,660
 pooling over the embeddings by an

1046
00:33:06,240 --> 00:33:07,660
 

1047
00:33:06,250 --> 00:33:12,850
 attention weighted pooling over the

1048
00:33:07,650 --> 00:33:12,850
 

1049
00:33:07,660 --> 00:33:14,410
 embeddings and this works better okay so

1050
00:33:12,840 --> 00:33:14,410
 

1051
00:33:12,850 --> 00:33:16,419
 what you probably would have noticed

1052
00:33:14,400 --> 00:33:16,419
 

1053
00:33:14,410 --> 00:33:18,340
 already now is that actually those

1054
00:33:16,409 --> 00:33:18,340
 

1055
00:33:16,419 --> 00:33:20,830
 references don't necessarily come in

1056
00:33:18,330 --> 00:33:20,830
 

1057
00:33:18,340 --> 00:33:23,559
 chronological order as a matter of fact

1058
00:33:20,820 --> 00:33:23,559
 

1059
00:33:20,830 --> 00:33:26,169
 we'll get to a rather complex model

1060
00:33:23,549 --> 00:33:26,169
 

1061
00:33:23,559 --> 00:33:29,500
 later on namely machine translation

1062
00:33:26,159 --> 00:33:29,500
 

1063
00:33:26,169 --> 00:33:32,410
 which was sort of the you know the you

1064
00:33:29,490 --> 00:33:32,410
 

1065
00:33:29,500 --> 00:33:34,750
 know condensation point or termination

1066
00:33:32,400 --> 00:33:34,750
 

1067
00:33:32,410 --> 00:33:36,850
 point of a lot of disattention work and

1068
00:33:34,740 --> 00:33:36,850
 

1069
00:33:34,750 --> 00:33:38,440
 that actually came fairly early on and

1070
00:33:36,840 --> 00:33:38,440
 

1071
00:33:36,850 --> 00:33:41,440
 then people afterwards stripped away

1072
00:33:38,430 --> 00:33:41,440
 

1073
00:33:38,440 --> 00:33:43,030
 pieces at and simplified it so this

1074
00:33:41,430 --> 00:33:43,030
 

1075
00:33:41,440 --> 00:33:44,650
 presentation I'm giving you right now is

1076
00:33:43,020 --> 00:33:44,650
 

1077
00:33:43,030 --> 00:33:46,510
 conceptually from simple to complicated

1078
00:33:44,640 --> 00:33:46,510
 

1079
00:33:44,650 --> 00:33:48,040
 but actually people came up with a

1080
00:33:46,500 --> 00:33:48,040
 

1081
00:33:46,510 --> 00:33:49,179
 really difficult things first and then

1082
00:33:48,030 --> 00:33:49,179
 

1083
00:33:48,040 --> 00:33:55,540
 they simplified it later

1084
00:33:49,169 --> 00:33:55,540
 

1085
00:33:49,179 --> 00:33:57,400
 so if kind of funny now okay so we have

1086
00:33:55,530 --> 00:33:57,400
 

1087
00:33:55,540 --> 00:34:01,720
 something how to deal with the obnoxious

1088
00:33:57,390 --> 00:34:01,720
 

1089
00:33:57,400 --> 00:34:06,070
 Alex but what about that so let's look

1090
00:34:01,710 --> 00:34:06,070
 

1091
00:34:01,720 --> 00:34:08,230
 at these two reviews right so it's a

1092
00:34:06,060 --> 00:34:08,230
 

1093
00:34:06,070 --> 00:34:11,530
 Yelp reviews and one of them for

1094
00:34:08,220 --> 00:34:11,530
 

1095
00:34:08,230 --> 00:34:12,820
 instance where you know granters is that

1096
00:34:11,520 --> 00:34:12,820
 

1097
00:34:11,530 --> 00:34:15,070
 this person's pretty much like the

1098
00:34:12,810 --> 00:34:15,070
 

1099
00:34:12,820 --> 00:34:17,710
 restaurant goes like this pork belly

1100
00:34:15,060 --> 00:34:17,710
 

1101
00:34:15,070 --> 00:34:20,679
 equals delicious scallops I don't even

1102
00:34:17,700 --> 00:34:20,679
 

1103
00:34:17,710 --> 00:34:22,510
 like scallops and these are amazing fine

1104
00:34:20,669 --> 00:34:22,510
 

1105
00:34:20,679 --> 00:34:23,980
 and tasty cocktails next time in Phoenix

1106
00:34:22,500 --> 00:34:23,980
 

1107
00:34:22,510 --> 00:34:27,540
 I will go back here

1108
00:34:23,970 --> 00:34:27,540
 

1109
00:34:23,980 --> 00:34:31,070
 highly recommended we're another one

1110
00:34:27,530 --> 00:34:31,070
 

1111
00:34:27,540 --> 00:34:35,940
 which wasn't very good terrible value

1112
00:34:31,060 --> 00:34:35,940
 

1113
00:34:31,070 --> 00:34:38,460
 water pasta entre 1695 good taste but

1114
00:34:35,930 --> 00:34:38,460
 

1115
00:34:35,940 --> 00:34:39,419
 sighs was an appetizer sighs no salad no

1116
00:34:38,450 --> 00:34:39,419
 

1117
00:34:38,460 --> 00:34:43,649
 bread in the vegetable

1118
00:34:39,409 --> 00:34:43,649
 

1119
00:34:39,419 --> 00:34:47,460
 this was our and tasty cocktails our

1120
00:34:43,639 --> 00:34:47,460
 

1121
00:34:43,649 --> 00:34:48,899
 second visit I will not go back so if

1122
00:34:47,450 --> 00:34:48,899
 

1123
00:34:47,460 --> 00:34:51,360
 you look at the review on the right hand

1124
00:34:48,889 --> 00:34:51,360
 

1125
00:34:48,899 --> 00:34:54,120
 side if you just you know balance

1126
00:34:51,350 --> 00:34:54,120
 

1127
00:34:51,360 --> 00:34:55,800
 positive versus negative aspects you'd

1128
00:34:54,110 --> 00:34:55,800
 

1129
00:34:54,120 --> 00:34:57,000
 think it's kind of level right I mean

1130
00:34:55,790 --> 00:34:57,000
 

1131
00:34:55,800 --> 00:35:01,170
 the food actually was pretty good the

1132
00:34:56,990 --> 00:35:01,170
 

1133
00:34:57,000 --> 00:35:02,880
 cocktails were tasty but then and this

1134
00:35:01,160 --> 00:35:02,880
 

1135
00:35:01,170 --> 00:35:04,880
 is our second visit right so there are a

1136
00:35:02,870 --> 00:35:04,880
 

1137
00:35:02,880 --> 00:35:07,980
 lot of good things about this place

1138
00:35:04,870 --> 00:35:07,980
 

1139
00:35:04,880 --> 00:35:10,200
 turns out well it's really overpriced

1140
00:35:07,970 --> 00:35:10,200
 

1141
00:35:07,980 --> 00:35:11,580
 and he's not gonna be back so the first

1142
00:35:10,190 --> 00:35:11,580
 

1143
00:35:10,200 --> 00:35:14,190
 and the last sentence are really the

1144
00:35:11,570 --> 00:35:14,190
 

1145
00:35:11,580 --> 00:35:17,160
 things that matter everything in between

1146
00:35:14,180 --> 00:35:17,160
 

1147
00:35:14,190 --> 00:35:20,250
 is just fluff to you know show that he's

1148
00:35:17,150 --> 00:35:20,250
 

1149
00:35:17,160 --> 00:35:22,920
 thought of different aspects but he

1150
00:35:20,240 --> 00:35:22,920
 

1151
00:35:20,250 --> 00:35:25,200
 really pants this place in the eights so

1152
00:35:22,910 --> 00:35:25,200
 

1153
00:35:22,920 --> 00:35:27,330
 what that means is you would really want

1154
00:35:25,190 --> 00:35:27,330
 

1155
00:35:25,200 --> 00:35:31,110
 to be able to weigh not just words

1156
00:35:27,320 --> 00:35:31,110
 

1157
00:35:27,330 --> 00:35:33,600
 within a sentence but also sentences to

1158
00:35:31,100 --> 00:35:33,600
 

1159
00:35:31,110 --> 00:35:36,450
 trade off things in terms of you know

1160
00:35:33,590 --> 00:35:36,450
 

1161
00:35:33,600 --> 00:35:40,220
 what matters and doesn't and if you look

1162
00:35:36,440 --> 00:35:40,220
 

1163
00:35:36,450 --> 00:35:44,130
 at the colors the different use of red

1164
00:35:40,210 --> 00:35:44,130
 

1165
00:35:40,220 --> 00:35:45,510
 tell you how you can go or how you

1166
00:35:44,120 --> 00:35:45,510
 

1167
00:35:44,130 --> 00:35:48,120
 should probably weigh the various

1168
00:35:45,500 --> 00:35:48,120
 

1169
00:35:45,510 --> 00:35:50,310
 sentences whereas the different shades

1170
00:35:48,110 --> 00:35:50,310
 

1171
00:35:48,120 --> 00:35:53,220
 of blue will tell you how you should

1172
00:35:50,300 --> 00:35:53,220
 

1173
00:35:50,310 --> 00:35:55,650
 weigh the words within the sentence so

1174
00:35:53,210 --> 00:35:55,650
 

1175
00:35:53,220 --> 00:36:00,060
 now you have attention within words of a

1176
00:35:55,640 --> 00:36:00,060
 

1177
00:35:55,650 --> 00:36:02,730
 sentence and within sentences and so if

1178
00:36:00,050 --> 00:36:02,730
 

1179
00:36:00,060 --> 00:36:05,100
 you compare to this picture here now

1180
00:36:02,720 --> 00:36:05,100
 

1181
00:36:02,730 --> 00:36:08,990
 we'll see the full story namely you can

1182
00:36:05,090 --> 00:36:08,990
 

1183
00:36:05,100 --> 00:36:11,970
 have attention waiting within a sentence

1184
00:36:08,980 --> 00:36:11,970
 

1185
00:36:08,990 --> 00:36:14,070
 you pull that together then you get

1186
00:36:11,960 --> 00:36:14,070
 

1187
00:36:11,970 --> 00:36:16,290
 attention waiting between sentences and

1188
00:36:14,060 --> 00:36:16,290
 

1189
00:36:14,070 --> 00:36:19,380
 you pull that together again and guess

1190
00:36:16,280 --> 00:36:19,380
 

1191
00:36:16,290 --> 00:36:20,320
 what that works and yeah that's what we

1192
00:36:19,370 --> 00:36:20,320
 

1193
00:36:19,380 --> 00:36:24,100
 did

1194
00:36:20,310 --> 00:36:24,100
 

1195
00:36:20,320 --> 00:36:26,110
 and you get three good models I mean

1196
00:36:24,090 --> 00:36:26,110
 

1197
00:36:24,100 --> 00:36:27,940
 nowadays rather than a GRU you would

1198
00:36:26,100 --> 00:36:27,940
 

1199
00:36:26,110 --> 00:36:30,430
 probably go and use something like pert

1200
00:36:27,930 --> 00:36:30,430
 

1201
00:36:27,940 --> 00:36:31,840
 and it might work an epsilon better if

1202
00:36:30,420 --> 00:36:31,840
 

1203
00:36:30,430 --> 00:36:36,060
 you have an undergrad that's probably a

1204
00:36:31,830 --> 00:36:36,060
 

1205
00:36:31,840 --> 00:36:38,710
 cool project to get them started on and

1206
00:36:36,050 --> 00:36:38,710
 

1207
00:36:36,060 --> 00:36:41,740
 it's exactly the same pattern just that

1208
00:36:38,700 --> 00:36:41,740
 

1209
00:36:38,710 --> 00:36:46,780
 well we used a slightly more refined

1210
00:36:41,730 --> 00:36:46,780
 

1211
00:36:41,740 --> 00:36:49,870
 structure so of course this is not the

1212
00:36:46,770 --> 00:36:49,870
 

1213
00:36:46,780 --> 00:36:51,850
 only place where this simple aggregation

1214
00:36:49,860 --> 00:36:51,850
 

1215
00:36:49,870 --> 00:36:53,740
 and replace it by waiting has been

1216
00:36:51,840 --> 00:36:53,740
 

1217
00:36:51,850 --> 00:36:56,350
 applied for instance they are the

1218
00:36:53,730 --> 00:36:56,350
 

1219
00:36:53,740 --> 00:37:00,790
 squeeze excitation networks and in this

1220
00:36:56,340 --> 00:37:00,790
 

1221
00:36:56,350 --> 00:37:05,770
 case you go and wave by Channel right so

1222
00:37:00,780 --> 00:37:05,770
 

1223
00:37:00,790 --> 00:37:09,160
 you have over all your filters in your

1224
00:37:05,760 --> 00:37:09,160
 

1225
00:37:05,770 --> 00:37:11,530
 you know continent and then you use the

1226
00:37:09,150 --> 00:37:11,530
 

1227
00:37:09,160 --> 00:37:13,270
 overall state of your attributes to come

1228
00:37:11,520 --> 00:37:13,270
 

1229
00:37:11,530 --> 00:37:15,280
 up with per channel ratings you'll

1230
00:37:13,260 --> 00:37:15,280
 

1231
00:37:13,270 --> 00:37:17,620
 rescale those and then you propagate it

1232
00:37:15,270 --> 00:37:17,620
 

1233
00:37:15,280 --> 00:37:20,230
 further and it turns out that these

1234
00:37:17,610 --> 00:37:20,230
 

1235
00:37:17,620 --> 00:37:22,540
 units as they're called rock a little

1236
00:37:20,220 --> 00:37:22,540
 

1237
00:37:20,230 --> 00:37:25,900
 bit better than their non excited

1238
00:37:22,530 --> 00:37:25,900
 

1239
00:37:22,540 --> 00:37:28,960
 networks and yeah it's actually very

1240
00:37:25,890 --> 00:37:28,960
 

1241
00:37:25,900 --> 00:37:31,150
 cheap modification now you can do the

1242
00:37:28,950 --> 00:37:31,150
 

1243
00:37:28,960 --> 00:37:33,850
 same thing for graphs so rather than in

1244
00:37:31,140 --> 00:37:33,850
 

1245
00:37:31,150 --> 00:37:35,890
 a you know graph Network where you just

1246
00:37:33,840 --> 00:37:35,890
 

1247
00:37:33,850 --> 00:37:38,080
 take your neighbors rather than just

1248
00:37:35,880 --> 00:37:38,080
 

1249
00:37:35,890 --> 00:37:41,310
 pulling over them you can do a tension

1250
00:37:38,070 --> 00:37:41,310
 

1251
00:37:38,080 --> 00:37:43,510
 pooling and guess what it works better

1252
00:37:41,300 --> 00:37:43,510
 

1253
00:37:41,310 --> 00:37:46,380
 which actually makes a lot of sense

1254
00:37:43,500 --> 00:37:46,380
 

1255
00:37:43,510 --> 00:37:49,510
 because let's say I'm following maybe

1256
00:37:46,370 --> 00:37:49,510
 

1257
00:37:46,380 --> 00:37:53,710
 Obama and I'm following maybe I don't

1258
00:37:49,500 --> 00:37:53,710
 

1259
00:37:49,510 --> 00:37:57,490
 know Justin Bieber then well okay I

1260
00:37:53,700 --> 00:37:57,490
 

1261
00:37:53,710 --> 00:37:58,870
 don't follow Justin Bieber but suppose I

1262
00:37:57,480 --> 00:37:58,870
 

1263
00:37:57,490 --> 00:38:01,540
 do and then I follow the mother and a

1264
00:37:58,860 --> 00:38:01,540
 

1265
00:37:58,870 --> 00:38:04,840
 person then it's a reasonable assumption

1266
00:38:01,530 --> 00:38:04,840
 

1267
00:38:01,540 --> 00:38:06,640
 to make that the tweets of different

1268
00:38:04,830 --> 00:38:06,640
 

1269
00:38:04,840 --> 00:38:11,770
 people who I follow might have different

1270
00:38:06,630 --> 00:38:11,770
 

1271
00:38:06,640 --> 00:38:14,170
 weight and so what I can do then is I

1272
00:38:11,760 --> 00:38:14,170
 

1273
00:38:11,770 --> 00:38:18,070
 can use that to weigh and assess

1274
00:38:14,160 --> 00:38:18,070
 

1275
00:38:14,170 --> 00:38:19,900
 appropriately you know which part is

1276
00:38:18,060 --> 00:38:19,900
 

1277
00:38:18,070 --> 00:38:22,420
 relevant which part matters and this

1278
00:38:19,890 --> 00:38:22,420
 

1279
00:38:19,900 --> 00:38:26,180
 gives me high accuracy

1280
00:38:22,410 --> 00:38:26,180
 

1281
00:38:22,420 --> 00:38:30,070
 so to make a very very very long story

1282
00:38:26,170 --> 00:38:30,070
 

1283
00:38:26,180 --> 00:38:34,040
 short what we have is we have this thing

1284
00:38:30,060 --> 00:38:34,040
 

1285
00:38:30,070 --> 00:38:37,460
 called pooling where you go and sum over

1286
00:38:34,030 --> 00:38:37,460
 

1287
00:38:34,040 --> 00:38:41,240
 the embeddings and what you can do is

1288
00:38:37,450 --> 00:38:41,240
 

1289
00:38:37,460 --> 00:38:45,170
 you can use attention pooling to weigh

1290
00:38:41,230 --> 00:38:45,170
 

1291
00:38:41,240 --> 00:38:49,700
 and rebalance things such that rather

1292
00:38:45,160 --> 00:38:49,700
 

1293
00:38:45,170 --> 00:38:52,190
 than taking the original embeddings you

1294
00:38:49,690 --> 00:38:52,190
 

1295
00:38:49,700 --> 00:38:57,770
 now take weighted embeddings and you

1296
00:38:52,180 --> 00:38:57,770
 

1297
00:38:52,190 --> 00:39:00,740
 aggregate those now this query can

1298
00:38:57,760 --> 00:39:00,740
 

1299
00:38:57,770 --> 00:39:03,830
 depend on the context I can possibly

1300
00:39:00,730 --> 00:39:03,830
 

1301
00:39:00,740 --> 00:39:06,140
 learn some function W that will help me

1302
00:39:03,820 --> 00:39:06,140
 

1303
00:39:03,830 --> 00:39:09,080
 do this and then I just sum things up

1304
00:39:06,130 --> 00:39:09,080
 

1305
00:39:06,140 --> 00:39:11,420
 and there we go now there are a number

1306
00:39:09,070 --> 00:39:11,420
 

1307
00:39:09,080 --> 00:39:13,790
 of possible choices that I can use for

1308
00:39:11,410 --> 00:39:13,790
 

1309
00:39:11,420 --> 00:39:15,800
 this attention function so one of the

1310
00:39:13,780 --> 00:39:15,800
 

1311
00:39:13,790 --> 00:39:18,710
 measure I'm showing here so that's just

1312
00:39:15,790 --> 00:39:18,710
 

1313
00:39:15,800 --> 00:39:21,920
 you know in a product between some

1314
00:39:18,700 --> 00:39:21,920
 

1315
00:39:18,710 --> 00:39:26,570
 embedding of X and some weight vector W

1316
00:39:21,910 --> 00:39:26,570
 

1317
00:39:21,920 --> 00:39:28,490
 and now one of the reasons why you might

1318
00:39:26,560 --> 00:39:28,490
 

1319
00:39:26,570 --> 00:39:31,490
 want to use Tanja's because it kind of

1320
00:39:28,480 --> 00:39:31,490
 

1321
00:39:28,490 --> 00:39:33,860
 constraints the range so the values

1322
00:39:31,480 --> 00:39:33,860
 

1323
00:39:31,490 --> 00:39:39,410
 don't diverge why too much you can use

1324
00:39:33,850 --> 00:39:39,410
 

1325
00:39:33,860 --> 00:39:42,920
 that so to sum things up the simple

1326
00:39:39,400 --> 00:39:42,920
 

1327
00:39:39,410 --> 00:39:44,960
 version of attention is just go forth

1328
00:39:42,910 --> 00:39:44,960
 

1329
00:39:42,920 --> 00:39:48,080
 and replace wherever in your paper you

1330
00:39:44,950 --> 00:39:48,080
 

1331
00:39:44,960 --> 00:39:50,810
 network you have pooling by weighted

1332
00:39:48,070 --> 00:39:50,810
 

1333
00:39:48,080 --> 00:39:53,860
 pooling learn the weighting function and

1334
00:39:50,800 --> 00:39:53,860
 

1335
00:39:50,810 --> 00:39:56,150
 your network will probably work better a

1336
00:39:53,850 --> 00:39:56,150
 

1337
00:39:53,860 --> 00:39:59,780
 little bit slower but it will be a lot

1338
00:39:56,140 --> 00:39:59,780
 

1339
00:39:56,150 --> 00:40:01,910
 better the other nice thing in doing

1340
00:39:59,770 --> 00:40:01,910
 

1341
00:39:59,780 --> 00:40:04,910
 that is that you now no longer

1342
00:40:01,900 --> 00:40:04,910
 

1343
00:40:01,910 --> 00:40:07,850
 susceptible to the number of inputs that

1344
00:40:04,900 --> 00:40:07,850
 

1345
00:40:04,910 --> 00:40:13,160
 you have right if you look at the same

1346
00:40:07,840 --> 00:40:13,160
 

1347
00:40:07,850 --> 00:40:16,010
 kernel let's go back to this right so in

1348
00:40:13,150 --> 00:40:16,010
 

1349
00:40:13,160 --> 00:40:18,650
 the end that formulation over here we

1350
00:40:16,000 --> 00:40:18,650
 

1351
00:40:16,010 --> 00:40:20,840
 have to be careful of how to rescale

1352
00:40:18,640 --> 00:40:20,840
 

1353
00:40:18,650 --> 00:40:23,780
 things if the number of inputs was

1354
00:40:20,830 --> 00:40:23,780
 

1355
00:40:20,840 --> 00:40:25,460
 different you could go and just say well

1356
00:40:23,770 --> 00:40:25,460
 

1357
00:40:23,780 --> 00:40:26,390
 I'm going to replace the sum by an

1358
00:40:25,450 --> 00:40:26,390
 

1359
00:40:25,460 --> 00:40:29,630
 average which is

1360
00:40:26,380 --> 00:40:29,630
 

1361
00:40:26,390 --> 00:40:31,819
 perfectly reasonable but effectively you

1362
00:40:29,620 --> 00:40:31,819
 

1363
00:40:29,630 --> 00:40:33,829
 have to at least make some additional

1364
00:40:31,809 --> 00:40:33,829
 

1365
00:40:31,819 --> 00:40:39,200
 precautions to ensure that things are

1366
00:40:33,819 --> 00:40:39,200
 

1367
00:40:33,829 --> 00:40:43,359
 properly scaled on the other hand if I

1368
00:40:39,190 --> 00:40:43,359
 

1369
00:40:39,200 --> 00:40:46,579
 use this weighted averaging then I can

1370
00:40:43,349 --> 00:40:46,579
 

1371
00:40:43,359 --> 00:40:49,670
 allow my model to focus on the relevant

1372
00:40:46,569 --> 00:40:49,670
 

1373
00:40:46,579 --> 00:40:53,769
 pieces and I can allow it to process a

1374
00:40:49,660 --> 00:40:53,769
 

1375
00:40:49,670 --> 00:40:57,289
 variable amount of input quite easily so

1376
00:40:53,759 --> 00:40:57,289
 

1377
00:40:53,769 --> 00:41:02,150
 this overall is actually a really

1378
00:40:57,279 --> 00:41:02,150
 

1379
00:40:57,289 --> 00:41:04,670
 important property of attention that it

1380
00:41:02,140 --> 00:41:04,670
 

1381
00:41:02,150 --> 00:41:08,619
 allows you to deal with variable sized

1382
00:41:04,660 --> 00:41:08,619
 

1383
00:41:04,670 --> 00:41:11,809
 inputs and to for instance

1384
00:41:08,609 --> 00:41:11,809
 

1385
00:41:08,619 --> 00:41:14,029
 come up with some estimate on them or to

1386
00:41:11,799 --> 00:41:14,029
 

1387
00:41:11,809 --> 00:41:16,910
 process those elements in a set as we'll

1388
00:41:14,019 --> 00:41:16,910
 

1389
00:41:14,029 --> 00:41:19,430
 see later on when we look at machine

1390
00:41:16,900 --> 00:41:19,430
 

1391
00:41:16,910 --> 00:41:21,019
 translation or when we look at pointa

1392
00:41:19,420 --> 00:41:21,019
 

1393
00:41:19,430 --> 00:41:24,950
 networks and other things we basically

1394
00:41:21,009 --> 00:41:24,950
 

1395
00:41:21,019 --> 00:41:31,750
 go and generate and emit symbols one at

1396
00:41:24,940 --> 00:41:31,750
 

1397
00:41:24,950 --> 00:41:31,750
 a time are any questions so far

1398
00:41:34,130 --> 00:41:34,130
 

1399
00:41:34,140 --> 00:41:36,769
 yes

1400
00:41:37,810 --> 00:41:37,810
 

1401
00:41:37,820 --> 00:41:45,280
 okay so I was asked to reshare the link

1402
00:41:39,940 --> 00:41:45,280
 

1403
00:41:39,950 --> 00:41:50,050
 to the slides okay that's it yeah

1404
00:41:45,270 --> 00:41:50,050
 

1405
00:41:45,280 --> 00:41:52,610
 if you wait until after the presentation

1406
00:41:50,040 --> 00:41:52,610
 

1407
00:41:50,050 --> 00:41:55,220
 we'll have two slides with the updated

1408
00:41:52,600 --> 00:41:55,220
 

1409
00:41:52,610 --> 00:41:56,800
 version of references just turned out

1410
00:41:55,210 --> 00:41:56,800
 

1411
00:41:55,220 --> 00:42:03,800
 that the network said a little bit slow

1412
00:41:56,790 --> 00:42:03,800
 

1413
00:41:56,800 --> 00:42:07,330
 okay okay any other questions yes could

1414
00:42:03,790 --> 00:42:07,330
 

1415
00:42:03,800 --> 00:42:11,860
 you just discuss or say you're going to

1416
00:42:07,320 --> 00:42:11,860
 

1417
00:42:07,330 --> 00:42:13,940
 aspects of kind of differentiating and

1418
00:42:11,850 --> 00:42:13,940
 

1419
00:42:11,860 --> 00:42:15,920
 exploring the attention function in the

1420
00:42:13,930 --> 00:42:15,920
 

1421
00:42:13,940 --> 00:42:17,510
 training process do you want to like

1422
00:42:15,910 --> 00:42:17,510
 

1423
00:42:15,920 --> 00:42:19,790
 organize your training epochs in a

1424
00:42:17,500 --> 00:42:19,790
 

1425
00:42:17,510 --> 00:42:24,170
 certain way and and this practices like

1426
00:42:19,780 --> 00:42:24,170
 

1427
00:42:19,790 --> 00:42:26,960
 that okay so that depends okay so how to

1428
00:42:24,160 --> 00:42:26,960
 

1429
00:42:24,170 --> 00:42:29,990
 best train well one thing that you may

1430
00:42:26,950 --> 00:42:29,990
 

1431
00:42:26,960 --> 00:42:32,240
 want to do is use a nice impressive

1432
00:42:29,980 --> 00:42:32,240
 

1433
00:42:29,990 --> 00:42:34,700
 framework but you so in other words

1434
00:42:32,230 --> 00:42:34,700
 

1435
00:42:32,240 --> 00:42:38,600
 sends a float eager or fight words or MX

1436
00:42:34,690 --> 00:42:38,600
 

1437
00:42:34,700 --> 00:42:40,070
 net blue on to write out a nice forward

1438
00:42:38,590 --> 00:42:40,070
 

1439
00:42:38,600 --> 00:42:41,480
 path because otherwise you're

1440
00:42:40,060 --> 00:42:41,480
 

1441
00:42:40,070 --> 00:42:43,520
 essentially at the mercy of whether

1442
00:42:41,470 --> 00:42:43,520
 

1443
00:42:41,480 --> 00:42:46,730
 somebody implemented that operator or

1444
00:42:43,510 --> 00:42:46,730
 

1445
00:42:43,520 --> 00:42:50,510
 not that's the first thing you may want

1446
00:42:46,720 --> 00:42:50,510
 

1447
00:42:46,730 --> 00:42:52,520
 to make sure that you don't over weight

1448
00:42:50,500 --> 00:42:52,520
 

1449
00:42:50,510 --> 00:42:55,910
 individual observations initially by too

1450
00:42:52,510 --> 00:42:55,910
 

1451
00:42:52,520 --> 00:42:57,920
 much so you could for instance you know

1452
00:42:55,900 --> 00:42:57,920
 

1453
00:42:55,910 --> 00:42:59,930
 first train with attention switched off

1454
00:42:57,910 --> 00:42:59,930
 

1455
00:42:57,920 --> 00:43:02,390
 and then you turn on attention there's a

1456
00:42:59,920 --> 00:43:02,390
 

1457
00:42:59,930 --> 00:43:05,030
 number of things we'll get to that later

1458
00:43:02,380 --> 00:43:05,030
 

1459
00:43:02,390 --> 00:43:08,990
 but overall it turns out to be

1460
00:43:05,020 --> 00:43:08,990
 

1461
00:43:05,030 --> 00:43:10,940
 reasonably robust we'll see actually

1462
00:43:08,980 --> 00:43:10,940
 

1463
00:43:08,990 --> 00:43:12,740
 considerably more complex models as we

1464
00:43:10,930 --> 00:43:12,740
 

1465
00:43:10,940 --> 00:43:15,380
 go along so for instance in the case of

1466
00:43:12,730 --> 00:43:15,380
 

1467
00:43:12,740 --> 00:43:18,050
 transformers you have multiple attention

1468
00:43:15,370 --> 00:43:18,050
 

1469
00:43:15,380 --> 00:43:21,680
 heads in a fairly complicated setting so

1470
00:43:18,040 --> 00:43:21,680
 

1471
00:43:18,050 --> 00:43:24,470
 a lot of the considerations there in

1472
00:43:21,670 --> 00:43:24,470
 

1473
00:43:21,680 --> 00:43:27,760
 simplified manner apply to how to train

1474
00:43:24,460 --> 00:43:27,760
 

1475
00:43:24,470 --> 00:43:27,760
 basic attention networks to

1476
00:43:28,380 --> 00:43:28,380
 

1477
00:43:28,390 --> 00:43:36,020
 so but one thing that you may want to do

1478
00:43:32,230 --> 00:43:36,020
 

1479
00:43:32,240 --> 00:43:39,050
 is and we'll point to that later so if

1480
00:43:36,010 --> 00:43:39,050
 

1481
00:43:36,020 --> 00:43:42,080
 you go to d2l dot ai you'll actually see

1482
00:43:39,040 --> 00:43:42,080
 

1483
00:43:39,050 --> 00:43:44,450
 a number of tutorials and notebooks and

1484
00:43:42,070 --> 00:43:44,450
 

1485
00:43:42,080 --> 00:43:47,060
 I apologize for doing a bit of a baton

1486
00:43:44,440 --> 00:43:47,060
 

1487
00:43:44,450 --> 00:43:50,060
 switch on you we won't have enough time

1488
00:43:47,050 --> 00:43:50,060
 

1489
00:43:47,060 --> 00:43:52,070
 to cover the notebooks in addition to

1490
00:43:50,050 --> 00:43:52,070
 

1491
00:43:50,060 --> 00:43:53,870
 all the material but if you go there

1492
00:43:52,060 --> 00:43:53,870
 

1493
00:43:52,070 --> 00:43:56,780
 you'll be able to download all the

1494
00:43:53,860 --> 00:43:56,780
 

1495
00:43:53,870 --> 00:44:09,850
 notebooks and more detailed discussion

1496
00:43:56,770 --> 00:44:09,850
 

1497
00:43:56,780 --> 00:44:09,850
 as you go along any other questions

1498
00:44:13,049 --> 00:44:13,049
 

1499
00:44:13,059 --> 00:44:23,999
 okay yes sorry so on this slide Phi is

1500
00:44:20,609 --> 00:44:23,999
 

1501
00:44:20,619 --> 00:44:29,499
 just some nonlinear function right yes

1502
00:44:23,989 --> 00:44:29,499
 

1503
00:44:23,999 --> 00:44:31,329
 so the class of these functions why is

1504
00:44:29,489 --> 00:44:31,329
 

1505
00:44:29,499 --> 00:44:36,189
 it different from the class of functions

1506
00:44:31,319 --> 00:44:36,189
 

1507
00:44:31,329 --> 00:44:40,029
 like alpha times Phi okay oh thanks for

1508
00:44:36,179 --> 00:44:40,029
 

1509
00:44:36,189 --> 00:44:44,309
 asking this so Phi of X it's just some

1510
00:44:40,019 --> 00:44:44,309
 

1511
00:44:40,029 --> 00:44:47,829
 embedding of X right and this could be

1512
00:44:44,299 --> 00:44:47,829
 

1513
00:44:44,309 --> 00:44:49,689
 pre-trained so it might fall out of a

1514
00:44:47,819 --> 00:44:49,689
 

1515
00:44:47,829 --> 00:44:52,419
 truck like using a protein baiting or

1516
00:44:49,679 --> 00:44:52,419
 

1517
00:44:49,689 --> 00:44:54,609
 over to make a whatever you might use

1518
00:44:52,409 --> 00:44:54,609
 

1519
00:44:52,419 --> 00:44:56,799
 that for you know for instance you can

1520
00:44:54,599 --> 00:44:56,799
 

1521
00:44:54,609 --> 00:45:00,099
 have a preacher a model for images you

1522
00:44:56,789 --> 00:45:00,099
 

1523
00:44:56,799 --> 00:45:02,279
 know maybe your favorite resonate 53

1524
00:45:00,089 --> 00:45:02,279
 

1525
00:45:00,099 --> 00:45:05,849
 train on image net or darknet or

1526
00:45:02,269 --> 00:45:05,849
 

1527
00:45:02,279 --> 00:45:09,999
 whatever alpha is a scalar

1528
00:45:05,839 --> 00:45:09,999
 

1529
00:45:05,849 --> 00:45:12,519
 now 5x only really depends on X alpha

1530
00:45:09,989 --> 00:45:12,519
 

1531
00:45:09,999 --> 00:45:14,140
 and it's I'm being playing a little bit

1532
00:45:12,509 --> 00:45:14,140
 

1533
00:45:12,519 --> 00:45:16,900
 fast and loose with the notation here

1534
00:45:14,130 --> 00:45:16,900
 

1535
00:45:14,140 --> 00:45:19,119
 alpha is a scalar at least right now

1536
00:45:16,890 --> 00:45:19,119
 

1537
00:45:16,900 --> 00:45:20,829
 it's just a simple number later on when

1538
00:45:19,109 --> 00:45:20,829
 

1539
00:45:19,119 --> 00:45:24,999
 we look at transformers it'll be

1540
00:45:20,819 --> 00:45:24,999
 

1541
00:45:20,829 --> 00:45:27,339
 actually a low dimensional vector and

1542
00:45:24,989 --> 00:45:27,339
 

1543
00:45:24,999 --> 00:45:30,279
 that's set up in such a way that it's

1544
00:45:27,329 --> 00:45:30,279
 

1545
00:45:27,339 --> 00:45:33,369
 normalized so technically speaking I

1546
00:45:30,269 --> 00:45:33,369
 

1547
00:45:30,279 --> 00:45:35,499
 would have to provide alpha not just

1548
00:45:33,359 --> 00:45:35,499
 

1549
00:45:33,369 --> 00:45:37,599
 with lowercase X and W but also with

1550
00:45:35,489 --> 00:45:37,599
 

1551
00:45:35,499 --> 00:45:39,789
 capital X in order to make sure that we

1552
00:45:37,589 --> 00:45:39,789
 

1553
00:45:37,599 --> 00:45:41,559
 have the proper normalization so if you

1554
00:45:39,779 --> 00:45:41,559
 

1555
00:45:39,789 --> 00:45:46,119
 look at the last line you can see what's

1556
00:45:41,549 --> 00:45:46,119
 

1557
00:45:41,559 --> 00:45:49,179
 going on alpha of X is proportional to e

1558
00:45:46,109 --> 00:45:49,179
 

1559
00:45:46,119 --> 00:45:51,909
 to the W transposed tange of UX and then

1560
00:45:49,169 --> 00:45:51,909
 

1561
00:45:49,179 --> 00:45:54,189
 you normalize okay I think the gentleman

1562
00:45:51,899 --> 00:45:54,189
 

1563
00:45:51,909 --> 00:45:56,199
 behind you also the question so this is

1564
00:45:54,179 --> 00:45:56,199
 

1565
00:45:54,189 --> 00:45:58,589
 very nice way of looking at self

1566
00:45:56,189 --> 00:45:58,589
 

1567
00:45:56,199 --> 00:46:01,659
 attention writing down they give it like

1568
00:45:58,579 --> 00:46:01,659
 

1569
00:45:58,589 --> 00:46:06,519
 is it based on the problem indeed the

1570
00:46:01,649 --> 00:46:06,519
 

1571
00:46:01,659 --> 00:46:09,130
 issue though is that I said if you need

1572
00:46:06,509 --> 00:46:09,130
 

1573
00:46:06,519 --> 00:46:11,769
 a large number of steps that would be

1574
00:46:09,120 --> 00:46:11,769
 

1575
00:46:09,130 --> 00:46:13,989
 only required for fairly complex queries

1576
00:46:11,759 --> 00:46:13,989
 

1577
00:46:11,769 --> 00:46:16,419
 where you need to take many logical

1578
00:46:13,979 --> 00:46:16,419
 

1579
00:46:13,989 --> 00:46:18,579
 steps in order to get somewhere in that

1580
00:46:16,409 --> 00:46:18,579
 

1581
00:46:16,419 --> 00:46:21,729
 case I would strongly recommend that you

1582
00:46:18,569 --> 00:46:21,729
 

1583
00:46:18,579 --> 00:46:23,499
 use something smarter than just simply

1584
00:46:21,719 --> 00:46:23,499
 

1585
00:46:21,729 --> 00:46:24,460
 it iterative reasoning you might

1586
00:46:23,489 --> 00:46:24,460
 

1587
00:46:23,499 --> 00:46:27,340
 actually want to

1588
00:46:24,450 --> 00:46:27,340
 

1589
00:46:24,460 --> 00:46:30,700
 in shape how your attention behaves

1590
00:46:27,330 --> 00:46:30,700
 

1591
00:46:27,340 --> 00:46:32,560
 right see might if you need multiple

1592
00:46:30,690 --> 00:46:32,560
 

1593
00:46:30,700 --> 00:46:34,860
 steps you probably want to include some

1594
00:46:32,550 --> 00:46:34,860
 

1595
00:46:32,560 --> 00:46:38,500
 prior knowledge on your problem right

1596
00:46:34,850 --> 00:46:38,500
 

1597
00:46:34,860 --> 00:46:40,330
 this could be a fun paper so for

1598
00:46:38,490 --> 00:46:40,330
 

1599
00:46:38,500 --> 00:46:43,300
 instance if you know that first you need

1600
00:46:40,320 --> 00:46:43,300
 

1601
00:46:40,330 --> 00:46:45,100
 to identify the people in the image and

1602
00:46:43,290 --> 00:46:45,100
 

1603
00:46:43,300 --> 00:46:46,810
 then you need to find out what they're

1604
00:46:45,090 --> 00:46:46,810
 

1605
00:46:45,100 --> 00:46:49,450
 doing and then you can count how many

1606
00:46:46,800 --> 00:46:49,450
 

1607
00:46:46,810 --> 00:46:51,340
 times they're doing certain things then

1608
00:46:49,440 --> 00:46:51,340
 

1609
00:46:49,450 --> 00:46:53,290
 it's probably a really good idea to

1610
00:46:51,330 --> 00:46:53,290
 

1611
00:46:51,340 --> 00:46:55,420
 encode that in the structure of your

1612
00:46:53,280 --> 00:46:55,420
 

1613
00:46:53,290 --> 00:46:58,360
 problem with otherwise you are going to

1614
00:46:55,410 --> 00:46:58,360
 

1615
00:46:55,420 --> 00:47:00,310
 need a lot of prior knowledge or a lot

1616
00:46:58,350 --> 00:47:00,310
 

1617
00:46:58,360 --> 00:47:04,060
 of you think you need a lot of data to

1618
00:47:00,300 --> 00:47:04,060
 

1619
00:47:00,310 --> 00:47:05,440
 make this work okay could you go back to

1620
00:47:04,050 --> 00:47:05,440
 

1621
00:47:04,060 --> 00:47:09,940
 sites where you are answering questions

1622
00:47:05,430 --> 00:47:09,940
 

1623
00:47:05,440 --> 00:47:13,780
 yeah so the first image on the left top

1624
00:47:09,930 --> 00:47:13,780
 

1625
00:47:09,940 --> 00:47:19,060
 so it's actually seems to be cows or

1626
00:47:13,770 --> 00:47:19,060
 

1627
00:47:13,780 --> 00:47:21,670
 bullocks I agree it just turns out that

1628
00:47:19,050 --> 00:47:21,670
 

1629
00:47:19,060 --> 00:47:24,370
 of the labels and the prediction are

1630
00:47:21,660 --> 00:47:24,370
 

1631
00:47:21,670 --> 00:47:28,180
 forces I also would have thought these

1632
00:47:24,360 --> 00:47:28,180
 

1633
00:47:24,370 --> 00:47:32,740
 are towels but I don't know I'm yeah I

1634
00:47:28,170 --> 00:47:32,740
 

1635
00:47:28,180 --> 00:47:36,160
 guess so yeah so my question is how did

1636
00:47:32,730 --> 00:47:36,160
 

1637
00:47:32,740 --> 00:47:39,550
 it infer its cow means horses means what

1638
00:47:36,150 --> 00:47:39,550
 

1639
00:47:36,160 --> 00:47:43,620
 what what did you are provide you to

1640
00:47:39,540 --> 00:47:43,620
 

1641
00:47:39,550 --> 00:47:45,880
 train so what okay so okay so these

1642
00:47:43,610 --> 00:47:45,880
 

1643
00:47:43,620 --> 00:47:48,370
 results look actually more impressive

1644
00:47:45,870 --> 00:47:48,370
 

1645
00:47:45,880 --> 00:47:51,610
 than they are anybody who's done vqa

1646
00:47:48,360 --> 00:47:51,610
 

1647
00:47:48,370 --> 00:47:54,550
 knows that in a lot of those data sets

1648
00:47:51,600 --> 00:47:54,550
 

1649
00:47:51,610 --> 00:47:57,700
 you have a set of possible candidate

1650
00:47:54,540 --> 00:47:57,700
 

1651
00:47:54,550 --> 00:48:01,350
 answers and so the candidate answers

1652
00:47:57,690 --> 00:48:01,350
 

1653
00:47:57,700 --> 00:48:06,190
 might be something like horses laptops

1654
00:48:01,340 --> 00:48:06,190
 

1655
00:48:01,350 --> 00:48:08,950
 trucks cows and fish right and then that

1656
00:48:06,180 --> 00:48:08,950
 

1657
00:48:06,190 --> 00:48:11,380
 very quickly narrows it down that there

1658
00:48:08,940 --> 00:48:11,380
 

1659
00:48:08,950 --> 00:48:13,990
 can only be a small number of things so

1660
00:48:11,370 --> 00:48:13,990
 

1661
00:48:11,380 --> 00:48:16,420
 that significantly simplifies the

1662
00:48:13,980 --> 00:48:16,420
 

1663
00:48:13,990 --> 00:48:19,240
 problem to something that's a lot less

1664
00:48:16,410 --> 00:48:19,240
 

1665
00:48:16,420 --> 00:48:21,160
 impressive and just this directly looks

1666
00:48:19,230 --> 00:48:21,160
 

1667
00:48:19,240 --> 00:48:24,370
 like but yeah that's pretty much what

1668
00:48:21,150 --> 00:48:24,370
 

1669
00:48:21,160 --> 00:48:27,880
 all vqa and also a lot of the text

1670
00:48:24,360 --> 00:48:27,880
 

1671
00:48:24,370 --> 00:48:30,010
 understanding problems do part of that

1672
00:48:27,870 --> 00:48:30,010
 

1673
00:48:27,880 --> 00:48:32,760
 is that otherwise it's just really hard

1674
00:48:30,000 --> 00:48:32,760
 

1675
00:48:30,010 --> 00:48:35,710
 to measure whether the answer is correct

1676
00:48:32,750 --> 00:48:35,710
 

1677
00:48:32,760 --> 00:48:37,870
 because you know if one if the network

1678
00:48:35,700 --> 00:48:37,870
 

1679
00:48:35,710 --> 00:48:39,640
 might answer white horses and the

1680
00:48:37,860 --> 00:48:39,640
 

1681
00:48:37,870 --> 00:48:41,170
 his forces then you need a human to

1682
00:48:39,630 --> 00:48:41,170
 

1683
00:48:39,640 --> 00:48:45,850
 identify and say well actually white

1684
00:48:41,160 --> 00:48:45,850
 

1685
00:48:41,170 --> 00:48:48,610
 force this is really good right so some

1686
00:48:45,840 --> 00:48:48,610
 

1687
00:48:45,850 --> 00:48:51,750
 of it has to do with the imperfection in

1688
00:48:48,600 --> 00:48:51,750
 

1689
00:48:48,610 --> 00:48:55,210
 how people design training sets

1690
00:48:51,740 --> 00:48:55,210
 

1691
00:48:51,750 --> 00:48:57,730
 nonetheless I mean if you feel compelled

1692
00:48:55,200 --> 00:48:57,730
 

1693
00:48:55,210 --> 00:49:00,510
 to do so I would strongly encourage you

1694
00:48:57,720 --> 00:49:00,510
 

1695
00:48:57,730 --> 00:49:01,750
 to help generate better training sense

1696
00:49:00,500 --> 00:49:01,750
 

1697
00:49:00,510 --> 00:49:04,000
 okay

1698
00:49:01,740 --> 00:49:04,000
 

1699
00:49:01,750 --> 00:49:06,640
 yes question middle so when I think

1700
00:49:03,990 --> 00:49:06,640
 

1701
00:49:04,000 --> 00:49:09,610
 about attention I think it depends on

1702
00:49:06,630 --> 00:49:09,610
 

1703
00:49:06,640 --> 00:49:11,650
 the task if I'm driving and I'm hungry

1704
00:49:09,600 --> 00:49:11,650
 

1705
00:49:09,610 --> 00:49:13,060
 I'm probably gonna pay attention to

1706
00:49:11,640 --> 00:49:13,060
 

1707
00:49:11,650 --> 00:49:15,090
 restaurants but if I'm doing something

1708
00:49:13,050 --> 00:49:15,090
 

1709
00:49:13,060 --> 00:49:19,140
 else I'll pay attention to other things

1710
00:49:15,080 --> 00:49:19,140
 

1711
00:49:15,090 --> 00:49:24,310
 so how is it possible that these simple

1712
00:49:19,130 --> 00:49:24,310
 

1713
00:49:19,140 --> 00:49:26,140
 functions are repeatable and across that

1714
00:49:24,300 --> 00:49:26,140
 

1715
00:49:24,310 --> 00:49:28,630
 so why does this formulation actually

1716
00:49:26,130 --> 00:49:28,630
 

1717
00:49:26,140 --> 00:49:30,450
 make sense in terms of attention and

1718
00:49:28,620 --> 00:49:30,450
 

1719
00:49:28,630 --> 00:49:33,250
 obviously when you're doing recursive

1720
00:49:30,440 --> 00:49:33,250
 

1721
00:49:30,450 --> 00:49:35,110
 you know the answer of three layers is

1722
00:49:33,240 --> 00:49:35,110
 

1723
00:49:33,250 --> 00:49:36,520
 good because otherwise the it's not

1724
00:49:35,100 --> 00:49:36,520
 

1725
00:49:35,110 --> 00:49:38,650
 satisfactory so what are the foundations

1726
00:49:36,510 --> 00:49:38,650
 

1727
00:49:36,520 --> 00:49:41,590
 of this why does it make sense to do all

1728
00:49:38,640 --> 00:49:41,590
 

1729
00:49:38,650 --> 00:49:44,020
 these okay this is a good question and

1730
00:49:41,580 --> 00:49:44,020
 

1731
00:49:41,590 --> 00:49:47,170
 first of all the unfortunate answer is

1732
00:49:44,010 --> 00:49:47,170
 

1733
00:49:44,020 --> 00:49:51,640
 that even for the simple attention

1734
00:49:47,160 --> 00:49:51,640
 

1735
00:49:47,170 --> 00:49:54,130
 mechanism that one is still not really

1736
00:49:51,630 --> 00:49:54,130
 

1737
00:49:51,640 --> 00:49:56,890
 well analyzed and I have some open

1738
00:49:54,120 --> 00:49:56,890
 

1739
00:49:54,130 --> 00:49:58,780
 questions at the end so basically if

1740
00:49:56,880 --> 00:49:58,780
 

1741
00:49:56,890 --> 00:50:01,240
 even proving something like consistency

1742
00:49:58,770 --> 00:50:01,240
 

1743
00:49:58,780 --> 00:50:03,910
 for a simple attention mechanism would

1744
00:50:01,230 --> 00:50:03,910
 

1745
00:50:01,240 --> 00:50:05,680
 be nice if somebody could do that but

1746
00:50:03,900 --> 00:50:05,680
 

1747
00:50:03,910 --> 00:50:08,260
 okay to answer your question why does it

1748
00:50:05,670 --> 00:50:08,260
 

1749
00:50:05,680 --> 00:50:10,090
 work well what happens is that you're

1750
00:50:08,250 --> 00:50:10,090
 

1751
00:50:08,260 --> 00:50:13,420
 basically also learning and embedding of

1752
00:50:10,080 --> 00:50:13,420
 

1753
00:50:10,090 --> 00:50:15,490
 the query right and you're not just

1754
00:50:13,410 --> 00:50:15,490
 

1755
00:50:13,420 --> 00:50:17,440
 taking the query and you don't have any

1756
00:50:15,480 --> 00:50:17,440
 

1757
00:50:15,490 --> 00:50:19,960
 other context but you're going to use a

1758
00:50:17,430 --> 00:50:19,960
 

1759
00:50:17,440 --> 00:50:22,360
 lot of text to come up with good

1760
00:50:19,950 --> 00:50:22,360
 

1761
00:50:19,960 --> 00:50:25,090
 embeddings for the text and thus the

1762
00:50:22,350 --> 00:50:25,090
 

1763
00:50:22,360 --> 00:50:26,830
 query you're also using a lot of context

1764
00:50:25,080 --> 00:50:26,830
 

1765
00:50:25,090 --> 00:50:28,990
 and thus prior knowledge to come up with

1766
00:50:26,820 --> 00:50:28,990
 

1767
00:50:26,830 --> 00:50:31,000
 embeddings for the images right for the

1768
00:50:28,980 --> 00:50:31,000
 

1769
00:50:28,990 --> 00:50:34,260
 objects maybe you'll even use an object

1770
00:50:30,990 --> 00:50:34,260
 

1771
00:50:31,000 --> 00:50:36,970
 detector and a few other things so

1772
00:50:34,250 --> 00:50:36,970
 

1773
00:50:34,260 --> 00:50:38,830
 therefore you're really standing on the

1774
00:50:36,960 --> 00:50:38,830
 

1775
00:50:36,970 --> 00:50:41,680
 shoulders of giants at least data wise

1776
00:50:38,820 --> 00:50:41,680
 

1777
00:50:38,830 --> 00:50:45,700
 in terms of transfer learning so those

1778
00:50:41,670 --> 00:50:45,700
 

1779
00:50:41,680 --> 00:50:50,110
 give you good priors on what the

1780
00:50:45,690 --> 00:50:50,110
 

1781
00:50:45,700 --> 00:50:52,600
 relevant representations ought to be and

1782
00:50:50,100 --> 00:50:52,600
 

1783
00:50:50,110 --> 00:50:55,900
 that will help you do well for certain

1784
00:50:52,590 --> 00:50:55,900
 

1785
00:50:52,600 --> 00:50:57,880
 applications so for instance if one of

1786
00:50:55,890 --> 00:50:57,880
 

1787
00:50:55,900 --> 00:51:00,250
 the questions was you know what is the

1788
00:50:57,870 --> 00:51:00,250
 

1789
00:50:57,880 --> 00:51:02,620
 amount of pixel noise in an image then

1790
00:51:00,240 --> 00:51:02,620
 

1791
00:51:00,250 --> 00:51:04,330
 probably a resonant embedding that's

1792
00:51:02,610 --> 00:51:04,330
 

1793
00:51:02,620 --> 00:51:06,010
 trained on image net will not do very

1794
00:51:04,320 --> 00:51:06,010
 

1795
00:51:04,330 --> 00:51:09,610
 well right because it's actually trained

1796
00:51:06,000 --> 00:51:09,610
 

1797
00:51:06,010 --> 00:51:12,310
 to ignore this or to also ignore other

1798
00:51:09,600 --> 00:51:12,310
 

1799
00:51:09,610 --> 00:51:14,710
 statistic variations right so to some

1800
00:51:12,300 --> 00:51:14,710
 

1801
00:51:12,310 --> 00:51:19,090
 extent the reason that this works is

1802
00:51:14,700 --> 00:51:19,090
 

1803
00:51:14,710 --> 00:51:21,430
 because a lot of the let's safety

1804
00:51:19,080 --> 00:51:21,430
 

1805
00:51:19,090 --> 00:51:24,940
 planning benchmarks and problems are

1806
00:51:21,420 --> 00:51:24,940
 

1807
00:51:21,430 --> 00:51:26,680
 actually quite related they focus very

1808
00:51:24,930 --> 00:51:26,680
 

1809
00:51:24,940 --> 00:51:30,100
 much on the types of questions that

1810
00:51:26,670 --> 00:51:30,100
 

1811
00:51:26,680 --> 00:51:31,450
 humans pose were all set in some cases

1812
00:51:30,090 --> 00:51:31,450
 

1813
00:51:30,100 --> 00:51:34,510
 it's just that the other set gets

1814
00:51:31,440 --> 00:51:34,510
 

1815
00:51:31,450 --> 00:51:37,120
 released it's available under some

1816
00:51:34,500 --> 00:51:37,120
 

1817
00:51:34,510 --> 00:51:39,490
 beneficial license and then different

1818
00:51:37,110 --> 00:51:39,490
 

1819
00:51:37,120 --> 00:51:40,840
 teams pack on different labelings on top

1820
00:51:39,480 --> 00:51:40,840
 

1821
00:51:39,490 --> 00:51:42,370
 of that so for instance if you look at

1822
00:51:40,830 --> 00:51:42,370
 

1823
00:51:40,840 --> 00:51:45,010
 the image cocoa data set there are

1824
00:51:42,360 --> 00:51:45,010
 

1825
00:51:42,370 --> 00:51:47,890
 various extensions of that that all rely

1826
00:51:45,000 --> 00:51:47,890
 

1827
00:51:45,010 --> 00:51:49,930
 on the same data set that's to some

1828
00:51:47,880 --> 00:51:49,930
 

1829
00:51:47,890 --> 00:51:52,450
 extent because humans tend to be lazy

1830
00:51:49,920 --> 00:51:52,450
 

1831
00:51:49,930 --> 00:51:54,160
 right so if you already have a data set

1832
00:51:52,440 --> 00:51:54,160
 

1833
00:51:52,450 --> 00:51:56,650
 available that's awesome so I don't have

1834
00:51:54,150 --> 00:51:56,650
 

1835
00:51:54,160 --> 00:51:58,660
 to do any extra work to add another set

1836
00:51:56,640 --> 00:51:58,660
 

1837
00:51:56,650 --> 00:52:01,450
 of labels to that I don't have to fight

1838
00:51:58,650 --> 00:52:01,450
 

1839
00:51:58,660 --> 00:52:03,130
 with my legal department to get approval

1840
00:52:01,440 --> 00:52:03,130
 

1841
00:52:01,450 --> 00:52:05,770
 for releasing the data set there's

1842
00:52:03,120 --> 00:52:05,770
 

1843
00:52:03,130 --> 00:52:08,740
 somebody else already you know ate the

1844
00:52:05,760 --> 00:52:08,740
 

1845
00:52:05,770 --> 00:52:11,920
 Frog before you right and that's part of

1846
00:52:08,730 --> 00:52:11,920
 

1847
00:52:08,740 --> 00:52:14,800
 the reasons why a lot of data sets are

1848
00:52:11,910 --> 00:52:14,800
 

1849
00:52:11,920 --> 00:52:16,540
 related and that sometimes may make you

1850
00:52:14,790 --> 00:52:16,540
 

1851
00:52:14,800 --> 00:52:17,760
 think that our networks are smarter than

1852
00:52:16,530 --> 00:52:17,760
 

1853
00:52:16,540 --> 00:52:20,050
 they actually are

1854
00:52:17,750 --> 00:52:20,050
 

1855
00:52:17,760 --> 00:52:21,610
 okay there was a question of what

1856
00:52:20,040 --> 00:52:21,610
 

1857
00:52:20,050 --> 00:52:25,840
 they're in the right and then we can

1858
00:52:21,600 --> 00:52:25,840
 

1859
00:52:21,610 --> 00:52:28,300
 make it one hi so most of the cases we

1860
00:52:25,830 --> 00:52:28,300
 

1861
00:52:25,840 --> 00:52:30,820
 have seen the key and the values are the

1862
00:52:28,290 --> 00:52:30,820
 

1863
00:52:28,300 --> 00:52:32,470
 same set of vectors so in the original

1864
00:52:30,810 --> 00:52:32,470
 

1865
00:52:30,820 --> 00:52:35,290
 transformer paper when they have

1866
00:52:32,460 --> 00:52:35,290
 

1867
00:52:32,470 --> 00:52:38,080
 multiple heads they project these keys

1868
00:52:35,280 --> 00:52:38,080
 

1869
00:52:35,290 --> 00:52:41,140
 and the values to different subspaces

1870
00:52:38,070 --> 00:52:41,140
 

1871
00:52:38,080 --> 00:52:43,270
 and they say that different head looked

1872
00:52:41,130 --> 00:52:43,270
 

1873
00:52:41,140 --> 00:52:43,960
 into different semantic meanings that's

1874
00:52:43,260 --> 00:52:43,960
 

1875
00:52:43,270 --> 00:52:46,840
 why they do it

1876
00:52:43,950 --> 00:52:46,840
 

1877
00:52:43,960 --> 00:52:49,420
 my question is when we have one head or

1878
00:52:46,830 --> 00:52:49,420
 

1879
00:52:46,840 --> 00:52:51,970
 one kind of attention what is the

1880
00:52:49,410 --> 00:52:51,970
 

1881
00:52:49,420 --> 00:52:56,470
 necessity of doing this extra projection

1882
00:52:51,960 --> 00:52:56,470
 

1883
00:52:51,970 --> 00:52:59,230
 on the key and the value vectors so why

1884
00:52:56,460 --> 00:52:59,230
 

1885
00:52:56,470 --> 00:53:00,330
 default start with keys and values being

1886
00:52:59,220 --> 00:53:00,330
 

1887
00:52:59,230 --> 00:53:03,240
 the same

1888
00:53:00,320 --> 00:53:03,240
 

1889
00:53:00,330 --> 00:53:07,500
 only if that doesn't work use different

1890
00:53:03,230 --> 00:53:07,500
 

1891
00:53:03,240 --> 00:53:09,690
 things to some extent it is a function

1892
00:53:07,490 --> 00:53:09,690
 

1893
00:53:07,500 --> 00:53:12,240
 of what the experimenter needs to do

1894
00:53:09,680 --> 00:53:12,240
 

1895
00:53:09,690 --> 00:53:13,980
 like in the very first example they show

1896
00:53:12,230 --> 00:53:13,980
 

1897
00:53:12,240 --> 00:53:16,380
 the Watson adhara estimator it's very

1898
00:53:13,970 --> 00:53:16,380
 

1899
00:53:13,980 --> 00:53:19,590
 clear that the key are the XS and the

1900
00:53:16,370 --> 00:53:19,590
 

1901
00:53:16,380 --> 00:53:22,020
 wide Y's are the values right because

1902
00:53:19,580 --> 00:53:22,020
 

1903
00:53:19,590 --> 00:53:24,060
 you want to regress and you only care

1904
00:53:22,010 --> 00:53:24,060
 

1905
00:53:22,020 --> 00:53:25,830
 about the XS insofar as they tell you

1906
00:53:24,050 --> 00:53:25,830
 

1907
00:53:24,060 --> 00:53:31,620
 you know how close to your query they

1908
00:53:25,820 --> 00:53:31,620
 

1909
00:53:25,830 --> 00:53:33,650
 are right so I would unless it feels

1910
00:53:31,610 --> 00:53:33,650
 

1911
00:53:31,620 --> 00:53:36,780
 natural to do so

1912
00:53:33,640 --> 00:53:36,780
 

1913
00:53:33,650 --> 00:53:38,490
 it quite key and value and that's

1914
00:53:36,770 --> 00:53:38,490
 

1915
00:53:36,780 --> 00:53:42,120
 actually what a lot of modern approaches

1916
00:53:38,480 --> 00:53:42,120
 

1917
00:53:38,490 --> 00:53:43,590
 use it's just that I'll be aware of the

1918
00:53:42,110 --> 00:53:43,590
 

1919
00:53:42,120 --> 00:53:47,220
 fact that you have a choice to use

1920
00:53:43,580 --> 00:53:47,220
 

1921
00:53:43,590 --> 00:53:49,440
 different things or you might have

1922
00:53:47,210 --> 00:53:49,440
 

1923
00:53:47,220 --> 00:53:55,050
 additional values available that you

1924
00:53:49,430 --> 00:53:55,050
 

1925
00:53:49,440 --> 00:53:57,240
 shouldn't use otherwise okay I think we

1926
00:53:55,040 --> 00:53:57,240
 

1927
00:53:55,050 --> 00:53:59,300
 need okay well one more one last

1928
00:53:57,230 --> 00:53:59,300
 

1929
00:53:57,240 --> 00:54:02,220
 question and then we need to move on

1930
00:53:59,290 --> 00:54:02,220
 

1931
00:53:59,300 --> 00:54:05,220
 there are some common techniques to make

1932
00:54:02,210 --> 00:54:05,220
 

1933
00:54:02,220 --> 00:54:08,400
 multi-layer attention network a train

1934
00:54:05,210 --> 00:54:08,400
 

1935
00:54:05,220 --> 00:54:11,130
 easier so do you typically tween them

1936
00:54:08,390 --> 00:54:11,130
 

1937
00:54:08,400 --> 00:54:13,350
 end to end or say train the first a

1938
00:54:11,120 --> 00:54:13,350
 

1939
00:54:11,130 --> 00:54:15,120
 layer first and then this and add

1940
00:54:13,340 --> 00:54:15,120
 

1941
00:54:13,350 --> 00:54:17,490
 another layer anything out of the third

1942
00:54:15,110 --> 00:54:17,490
 

1943
00:54:15,120 --> 00:54:22,290
 layer ok so again it depends a little

1944
00:54:17,480 --> 00:54:22,290
 

1945
00:54:17,490 --> 00:54:24,180
 bit nay so first of all if you have you

1946
00:54:22,280 --> 00:54:24,180
 

1947
00:54:22,290 --> 00:54:26,970
 know a problem that's applied to a

1948
00:54:24,170 --> 00:54:26,970
 

1949
00:54:24,180 --> 00:54:28,710
 common data type and in almost all cases

1950
00:54:26,960 --> 00:54:28,710
 

1951
00:54:26,970 --> 00:54:30,300
 you would have that like you would have

1952
00:54:28,700 --> 00:54:30,300
 

1953
00:54:28,710 --> 00:54:35,010
 text that you would have images or audio

1954
00:54:30,290 --> 00:54:35,010
 

1955
00:54:30,300 --> 00:54:36,840
 or whatever then by all means use a pre

1956
00:54:35,000 --> 00:54:36,840
 

1957
00:54:35,010 --> 00:54:40,380
 trained network that you get from there

1958
00:54:36,830 --> 00:54:40,380
 

1959
00:54:36,840 --> 00:54:42,870
 to apply it and use it this works most

1960
00:54:40,370 --> 00:54:42,870
 

1961
00:54:40,380 --> 00:54:45,180
 of the times let me give you an example

1962
00:54:42,860 --> 00:54:45,180
 

1963
00:54:42,870 --> 00:54:47,880
 where this doesn't work so let's say you

1964
00:54:45,170 --> 00:54:47,880
 

1965
00:54:45,180 --> 00:54:50,010
 want to have a Image Search application

1966
00:54:47,870 --> 00:54:50,010
 

1967
00:54:47,880 --> 00:54:53,760
 where you want to look up satellite

1968
00:54:50,000 --> 00:54:53,760
 

1969
00:54:50,010 --> 00:54:55,410
 images and if you want to do that you

1970
00:54:53,750 --> 00:54:55,410
 

1971
00:54:53,760 --> 00:54:57,840
 might think that well ok satellite

1972
00:54:55,400 --> 00:54:57,840
 

1973
00:54:55,410 --> 00:55:00,540
 images are images after all and you know

1974
00:54:57,830 --> 00:55:00,540
 

1975
00:54:57,840 --> 00:55:03,000
 let's say there are actually RGB so

1976
00:55:00,530 --> 00:55:03,000
 

1977
00:55:00,540 --> 00:55:05,310
 let's just pre-trained some embeddings

1978
00:55:02,990 --> 00:55:05,310
 

1979
00:55:03,000 --> 00:55:06,990
 based on image nits and then use them

1980
00:55:05,300 --> 00:55:06,990
 

1981
00:55:05,310 --> 00:55:08,050
 for nearest neighbor look up for

1982
00:55:06,980 --> 00:55:08,050
 

1983
00:55:06,990 --> 00:55:11,530
 satellite images

1984
00:55:08,040 --> 00:55:11,530
 

1985
00:55:08,050 --> 00:55:15,820
 and we did this it was a total disaster

1986
00:55:11,520 --> 00:55:15,820
 

1987
00:55:11,530 --> 00:55:19,360
 it didn't work and part of the reason

1988
00:55:15,810 --> 00:55:19,360
 

1989
00:55:15,820 --> 00:55:21,280
 why it didn't work is because satellite

1990
00:55:19,350 --> 00:55:21,280
 

1991
00:55:19,360 --> 00:55:24,670
 images look very different from other

1992
00:55:21,270 --> 00:55:24,670
 

1993
00:55:21,280 --> 00:55:26,670
 real images so in the end what we had to

1994
00:55:24,660 --> 00:55:26,670
 

1995
00:55:24,670 --> 00:55:27,910
 do is we had to pre train on

1996
00:55:26,660 --> 00:55:27,910
 

1997
00:55:26,670 --> 00:55:30,400
 OpenStreetMaps

1998
00:55:27,900 --> 00:55:30,400
 

1999
00:55:27,910 --> 00:55:33,400
 and then things were fine again but this

2000
00:55:30,390 --> 00:55:33,400
 

2001
00:55:30,400 --> 00:55:35,800
 was one this is about the only example

2002
00:55:33,390 --> 00:55:35,800
 

2003
00:55:33,400 --> 00:55:38,410
 that I know where pre-training actually

2004
00:55:35,790 --> 00:55:38,410
 

2005
00:55:35,800 --> 00:55:40,750
 did not work at all in most other cases

2006
00:55:38,400 --> 00:55:40,750
 

2007
00:55:38,410 --> 00:55:44,980
 pre training and learning embeddings for

2008
00:55:40,740 --> 00:55:44,980
 

2009
00:55:40,750 --> 00:55:47,470
 the specific types is your friend so and

2010
00:55:44,970 --> 00:55:47,470
 

2011
00:55:44,980 --> 00:55:49,120
 we'll actually get to this to Allah in

2012
00:55:47,460 --> 00:55:49,120
 

2013
00:55:47,470 --> 00:55:51,490
 much more detail later on when we

2014
00:55:49,110 --> 00:55:51,490
 

2015
00:55:49,120 --> 00:55:54,810
 discuss pert and we'll see how you can

2016
00:55:51,480 --> 00:55:54,810
 

2017
00:55:51,490 --> 00:55:59,410
 use that to solve a wide range of

2018
00:55:54,800 --> 00:55:59,410
 

2019
00:55:54,810 --> 00:56:01,960
 specific applications for an LTE with

2020
00:55:59,400 --> 00:56:01,960
 

2021
00:55:59,410 --> 00:56:06,400
 our test free training and you get

2022
00:56:01,950 --> 00:56:06,400
 

2023
00:56:01,960 --> 00:56:12,010
 better VAT outcomes okay so now let's

2024
00:56:06,390 --> 00:56:12,010
 

2025
00:56:06,400 --> 00:56:16,210
 move on to something very logical namely

2026
00:56:12,000 --> 00:56:16,210
 

2027
00:56:12,010 --> 00:56:21,090
 so far we iterated over the input with a

2028
00:56:16,200 --> 00:56:21,090
 

2029
00:56:16,210 --> 00:56:24,910
 query and we got a single output right

2030
00:56:21,080 --> 00:56:24,910
 

2031
00:56:21,090 --> 00:56:29,220
 so obviously rather than having a single

2032
00:56:24,900 --> 00:56:29,220
 

2033
00:56:24,910 --> 00:56:34,270
 output you could have multiple outputs

2034
00:56:29,210 --> 00:56:34,270
 

2035
00:56:29,220 --> 00:56:36,880
 so let me motivate this suppose I want

2036
00:56:34,260 --> 00:56:36,880
 

2037
00:56:34,270 --> 00:56:38,760
 to do sequence the sequence now for

2038
00:56:36,870 --> 00:56:38,760
 

2039
00:56:36,880 --> 00:56:43,090
 machine translation this is paper from

2040
00:56:38,750 --> 00:56:43,090
 

2041
00:56:38,760 --> 00:56:46,360
 2014 it was quiet let's just say a

2042
00:56:43,080 --> 00:56:46,360
 

2043
00:56:43,090 --> 00:56:48,190
 remarkable presentation at nips because

2044
00:56:46,350 --> 00:56:48,190
 

2045
00:56:46,360 --> 00:56:51,010
 the entire presentation was something

2046
00:56:48,180 --> 00:56:51,010
 

2047
00:56:48,190 --> 00:56:53,140
 like hey we took an LST my mini stacks

2048
00:56:51,000 --> 00:56:53,140
 

2049
00:56:51,010 --> 00:56:58,540
 and we trained it on many machines and

2050
00:56:53,130 --> 00:56:58,540
 

2051
00:56:53,140 --> 00:57:01,420
 it worked so what did they do well they

2052
00:56:58,530 --> 00:57:01,420
 

2053
00:56:58,540 --> 00:57:05,260
 basically went so this is let's give a

2054
00:57:01,410 --> 00:57:05,260
 

2055
00:57:01,420 --> 00:57:09,940
 thousand let they took an input sequence

2056
00:57:05,250 --> 00:57:09,940
 

2057
00:57:05,260 --> 00:57:11,350
 and they ran it through an LST m and

2058
00:57:09,930 --> 00:57:11,350
 

2059
00:57:09,940 --> 00:57:14,320
 they got some embedding out of it so

2060
00:57:11,340 --> 00:57:14,320
 

2061
00:57:11,350 --> 00:57:20,080
 firebase and

2062
00:57:14,310 --> 00:57:20,080
 

2063
00:57:14,320 --> 00:57:22,980
 they applied this for on a decoder and

2064
00:57:20,070 --> 00:57:22,980
 

2065
00:57:20,080 --> 00:57:25,470
 in the decoder day you know generated

2066
00:57:22,970 --> 00:57:25,470
 

2067
00:57:22,980 --> 00:57:29,290
 you know the target language out of that

2068
00:57:25,460 --> 00:57:29,290
 

2069
00:57:25,470 --> 00:57:30,700
 so I input ABC and then I get Phi of

2070
00:57:29,280 --> 00:57:30,700
 

2071
00:57:29,290 --> 00:57:32,530
 this string submitted some

2072
00:57:30,690 --> 00:57:32,530
 

2073
00:57:30,700 --> 00:57:36,610
 representation and then I start you know

2074
00:57:32,520 --> 00:57:36,610
 

2075
00:57:32,530 --> 00:57:39,070
 generating WXYZ in an end of stream and

2076
00:57:36,600 --> 00:57:39,070
 

2077
00:57:36,610 --> 00:57:40,750
 of course I have five generator W I use

2078
00:57:39,060 --> 00:57:40,750
 

2079
00:57:39,070 --> 00:57:44,320
 that as an additional input to generate

2080
00:57:40,740 --> 00:57:44,320
 

2081
00:57:40,750 --> 00:57:46,750
 X and then to Y and so on and on and

2082
00:57:44,310 --> 00:57:46,750
 

2083
00:57:44,320 --> 00:57:48,700
 this works beautifully if I have very

2084
00:57:46,740 --> 00:57:48,700
 

2085
00:57:46,750 --> 00:57:51,010
 short sequences like the table is round

2086
00:57:48,690 --> 00:57:51,010
 

2087
00:57:48,700 --> 00:57:54,520
 well you know it's not great poetry that

2088
00:57:51,000 --> 00:57:54,520
 

2089
00:57:51,010 --> 00:57:58,330
 issues alone fine but it started failing

2090
00:57:54,510 --> 00:57:58,330
 

2091
00:57:54,520 --> 00:58:00,670
 quite badly when you had very very long

2092
00:57:58,320 --> 00:58:00,670
 

2093
00:57:58,330 --> 00:58:03,640
 sentences maybe with sub sentences so

2094
00:58:00,660 --> 00:58:03,640
 

2095
00:58:00,670 --> 00:58:05,200
 German is really infamous for that well

2096
00:58:03,630 --> 00:58:05,200
 

2097
00:58:03,640 --> 00:58:06,970
 you might have sentences that spam

2098
00:58:05,190 --> 00:58:06,970
 

2099
00:58:05,200 --> 00:58:09,730
 twenty thirty words and it's actually

2100
00:58:06,960 --> 00:58:09,730
 

2101
00:58:06,970 --> 00:58:11,890
 consider great style if you craft those

2102
00:58:09,720 --> 00:58:11,890
 

2103
00:58:09,730 --> 00:58:13,900
 properly with them in English it's

2104
00:58:11,880 --> 00:58:13,900
 

2105
00:58:11,890 --> 00:58:15,850
 considered bad style but in German

2106
00:58:13,890 --> 00:58:15,850
 

2107
00:58:13,900 --> 00:58:18,010
 people think that you're very smart and

2108
00:58:15,840 --> 00:58:18,010
 

2109
00:58:15,850 --> 00:58:23,140
 educated if you make really complicated

2110
00:58:18,000 --> 00:58:23,140
 

2111
00:58:18,010 --> 00:58:25,360
 sentences so unfortunately this sequence

2112
00:58:23,130 --> 00:58:25,360
 

2113
00:58:23,140 --> 00:58:28,510
 sequence approach fails miserably for

2114
00:58:25,350 --> 00:58:28,510
 

2115
00:58:25,360 --> 00:58:31,030
 that right and there's a simple reason

2116
00:58:28,500 --> 00:58:31,030
 

2117
00:58:28,510 --> 00:58:32,790
 because well you know the representation

2118
00:58:31,020 --> 00:58:32,790
 

2119
00:58:31,030 --> 00:58:35,740
 isn't rich enough for those really

2120
00:58:32,780 --> 00:58:35,740
 

2121
00:58:32,790 --> 00:58:39,790
 complicated twenty words and more German

2122
00:58:35,730 --> 00:58:39,790
 

2123
00:58:35,740 --> 00:58:41,830
 sentences overall you know you're just

2124
00:58:39,780 --> 00:58:41,830
 

2125
00:58:39,790 --> 00:58:45,370
 asking the network to do too much to

2126
00:58:41,820 --> 00:58:45,370
 

2127
00:58:41,830 --> 00:58:48,190
 embed a very very long sequence into a

2128
00:58:45,360 --> 00:58:48,190
 

2129
00:58:45,370 --> 00:58:52,050
 finite dimensional state vector and then

2130
00:58:48,180 --> 00:58:52,050
 

2131
00:58:48,190 --> 00:58:54,580
 to disgorge that in the target language

2132
00:58:52,040 --> 00:58:54,580
 

2133
00:58:52,050 --> 00:58:57,250
 you're basically forcing that phonetic

2134
00:58:54,570 --> 00:58:57,250
 

2135
00:58:54,580 --> 00:58:59,710
 to memorize that source sequence and

2136
00:58:57,240 --> 00:58:59,710
 

2137
00:58:57,250 --> 00:59:01,600
 then to translate and keep in mind all

2138
00:58:59,700 --> 00:59:01,600
 

2139
00:58:59,710 --> 00:59:04,390
 the things that it's already generated

2140
00:59:01,590 --> 00:59:04,390
 

2141
00:59:01,600 --> 00:59:05,680
 in the target right so try that for

2142
00:59:04,380 --> 00:59:05,680
 

2143
00:59:04,390 --> 00:59:09,910
 yourself with a very long source

2144
00:59:05,670 --> 00:59:09,910
 

2145
00:59:05,680 --> 00:59:11,290
 sentence and you'd run into trouble but

2146
00:59:09,900 --> 00:59:11,290
 

2147
00:59:09,910 --> 00:59:13,270
 if you think about it

2148
00:59:11,280 --> 00:59:13,270
 

2149
00:59:11,290 --> 00:59:17,290
 this is actually making life way too

2150
00:59:13,260 --> 00:59:17,290
 

2151
00:59:13,270 --> 00:59:20,140
 hard or you know that Network right

2152
00:59:17,280 --> 00:59:20,140
 

2153
00:59:17,290 --> 00:59:22,660
 because you actually still have your

2154
00:59:20,130 --> 00:59:22,660
 

2155
00:59:20,140 --> 00:59:24,580
 entire source sentence at your just've

2156
00:59:22,650 --> 00:59:24,580
 

2157
00:59:22,660 --> 00:59:25,509
 disposal so you know why not look it up

2158
00:59:24,570 --> 00:59:25,509
 

2159
00:59:24,580 --> 00:59:27,699
 right

2160
00:59:25,499 --> 00:59:27,699
 

2161
00:59:25,509 --> 00:59:29,799
 and what we can do is we can compare as

2162
00:59:27,689 --> 00:59:29,799
 

2163
00:59:27,699 --> 00:59:32,139
 we generate you know the target sequence

2164
00:59:29,789 --> 00:59:32,139
 

2165
00:59:29,799 --> 00:59:33,459
 we generate one word after the other we

2166
00:59:32,129 --> 00:59:33,459
 

2167
00:59:32,139 --> 00:59:34,839
 can look at well which ones have we

2168
00:59:33,449 --> 00:59:34,839
 

2169
00:59:33,459 --> 00:59:38,589
 already looked at which ones I haven't

2170
00:59:34,829 --> 00:59:38,589
 

2171
00:59:34,839 --> 00:59:41,109
 we seen yet and well the hope is that

2172
00:59:38,579 --> 00:59:41,109
 

2173
00:59:38,589 --> 00:59:45,489
 this works better as a matter of fact

2174
00:59:41,099 --> 00:59:45,489
 

2175
00:59:41,109 --> 00:59:47,799
 this is the you know grandfather of all

2176
00:59:45,479 --> 00:59:47,799
 

2177
00:59:45,489 --> 00:59:51,699
 the attention papers really by by the

2178
00:59:47,789 --> 00:59:51,699
 

2179
00:59:47,799 --> 00:59:53,439
 know Joe and Andrew from 2014 and all

2180
00:59:51,689 --> 00:59:53,439
 

2181
00:59:51,699 --> 00:59:56,769
 those simplifications happen later right

2182
00:59:53,429 --> 00:59:56,769
 

2183
00:59:53,439 --> 00:59:59,169
 I mean part of what's not area estimator

2184
00:59:56,759 --> 00:59:59,169
 

2185
00:59:56,769 --> 01:00:02,949
 and probably a few statistics in between

2186
00:59:59,159 --> 01:00:02,949
 

2187
00:59:59,169 --> 01:00:06,459
 and then there's a variant of that by

2188
01:00:02,939 --> 01:00:06,459
 

2189
01:00:02,949 --> 01:00:11,649
 farm dominant Manning and essentially

2190
01:00:06,449 --> 01:00:11,649
 

2191
01:00:06,459 --> 01:00:13,839
 his hide works so you know you go and

2192
01:00:11,639 --> 01:00:13,839
 

2193
01:00:11,649 --> 01:00:17,079
 encode you store see sequence as you

2194
01:00:13,829 --> 01:00:17,079
 

2195
01:00:13,839 --> 01:00:20,859
 would and then you you know you get some

2196
01:00:17,069 --> 01:00:20,859
 

2197
01:00:17,079 --> 01:00:24,909
 hidden state and you use that him state

2198
01:00:20,849 --> 01:00:24,909
 

2199
01:00:20,859 --> 01:00:28,929
 to emit let's say X now what you do is

2200
01:00:24,899 --> 01:00:28,929
 

2201
01:00:24,909 --> 01:00:32,259
 you use X and you know the currently

2202
01:00:28,919 --> 01:00:32,259
 

2203
01:00:28,929 --> 01:00:35,559
 state to look at a new attention waiting

2204
01:00:32,249 --> 01:00:35,559
 

2205
01:00:32,259 --> 01:00:37,929
 over your source and then you meet Y and

2206
01:00:35,549 --> 01:00:37,929
 

2207
01:00:35,559 --> 01:00:39,789
 then you figure out you know what to

2208
01:00:37,919 --> 01:00:39,789
 

2209
01:00:37,929 --> 01:00:42,729
 attend to next and you keep on doing

2210
01:00:39,779 --> 01:00:42,729
 

2211
01:00:39,789 --> 01:00:45,189
 this until years through the string the

2212
01:00:42,719 --> 01:00:45,189
 

2213
01:00:42,729 --> 01:00:48,399
 benefit is that now all the sudden your

2214
01:00:45,179 --> 01:00:48,399
 

2215
01:00:45,189 --> 01:00:50,380
 hidden state needs to encode only very

2216
01:00:48,389 --> 01:00:50,380
 

2217
01:00:48,399 --> 01:00:52,059
 little namely it needs to encode kind of

2218
01:00:50,370 --> 01:00:52,059
 

2219
01:00:50,380 --> 01:00:52,779
 what we've already seen so far and what

2220
01:00:52,049 --> 01:00:52,779
 

2221
01:00:52,059 --> 01:00:56,649
 comes next

2222
01:00:52,769 --> 01:00:56,649
 

2223
01:00:52,779 --> 01:00:59,289
 it doesn't have to encode anymore what

2224
01:00:56,639 --> 01:00:59,289
 

2225
01:00:56,649 --> 01:01:01,989
 needs to be translated but just like

2226
01:00:59,279 --> 01:01:01,989
 

2227
01:00:59,289 --> 01:01:08,380
 we're in that process of translation we

2228
01:01:01,979 --> 01:01:08,380
 

2229
01:01:01,989 --> 01:01:10,599
 are so far this is a lot easier so for

2230
01:01:08,370 --> 01:01:10,599
 

2231
01:01:08,380 --> 01:01:13,359
 instance you can have non detention wait

2232
01:01:10,589 --> 01:01:13,359
 

2233
01:01:10,599 --> 01:01:15,849
 and this is now you know clocked by you

2234
01:01:13,349 --> 01:01:15,849
 

2235
01:01:13,359 --> 01:01:18,759
 know where we are in that sequence and

2236
01:01:15,839 --> 01:01:18,759
 

2237
01:01:15,849 --> 01:01:20,319
 it depends on the embedding and in this

2238
01:01:18,749 --> 01:01:20,319
 

2239
01:01:18,759 --> 01:01:23,499
 case again key and value are the same

2240
01:01:20,309 --> 01:01:23,499
 

2241
01:01:20,319 --> 01:01:26,380
 and then I'm using the hidden state that

2242
01:01:23,489 --> 01:01:26,380
 

2243
01:01:23,499 --> 01:01:29,439
 I've also used to generate the output as

2244
01:01:26,370 --> 01:01:29,439
 

2245
01:01:26,380 --> 01:01:32,019
 the query for you know what to attend to

2246
01:01:29,429 --> 01:01:32,019
 

2247
01:01:29,439 --> 01:01:33,609
 next I then perform appropriate

2248
01:01:32,009 --> 01:01:33,609
 

2249
01:01:32,019 --> 01:01:37,299
 attention pooling circuit does the eyes

2250
01:01:33,599 --> 01:01:37,299
 

2251
01:01:33,609 --> 01:01:37,890
 back I use that in conjunction with you

2252
01:01:37,289 --> 01:01:37,890
 

2253
01:01:37,299 --> 01:01:40,980
 know whatever

2254
01:01:37,880 --> 01:01:40,980
 

2255
01:01:37,890 --> 01:01:43,560
 I generated before to come up with a new

2256
01:01:40,970 --> 01:01:43,560
 

2257
01:01:40,980 --> 01:01:45,780
 hidden state and I also omit the

2258
01:01:43,550 --> 01:01:45,780
 

2259
01:01:43,560 --> 01:01:48,060
 corresponding why I there are lots of

2260
01:01:45,770 --> 01:01:48,060
 

2261
01:01:45,780 --> 01:01:49,860
 different flavors of this and every one

2262
01:01:48,050 --> 01:01:49,860
 

2263
01:01:48,060 --> 01:01:53,070
 of those works a little bit better and a

2264
01:01:49,850 --> 01:01:53,070
 

2265
01:01:49,860 --> 01:01:58,170
 bit differently but the gist of it is

2266
01:01:53,060 --> 01:01:58,170
 

2267
01:01:53,070 --> 01:02:01,770
 that you use the hidden state to help

2268
01:01:58,160 --> 01:02:01,770
 

2269
01:01:58,170 --> 01:02:06,210
 attend to your sequence and then omit

2270
01:02:01,760 --> 01:02:06,210
 

2271
01:02:01,770 --> 01:02:08,160
 one target for that time so to show you

2272
01:02:06,200 --> 01:02:08,160
 

2273
01:02:06,210 --> 01:02:11,130
 this in a different graph that's a bit

2274
01:02:08,150 --> 01:02:11,130
 

2275
01:02:08,160 --> 01:02:12,030
 simplified you basically have the

2276
01:02:11,120 --> 01:02:12,030
 

2277
01:02:11,130 --> 01:02:16,850
 original source

2278
01:02:12,020 --> 01:02:16,850
 

2279
01:02:12,030 --> 01:02:20,310
 this is encoded you then use attention

2280
01:02:16,840 --> 01:02:20,310
 

2281
01:02:16,850 --> 01:02:23,220
 to query the corresponding key value

2282
01:02:20,300 --> 01:02:23,220
 

2283
01:02:20,310 --> 01:02:25,770
 pairs to generate an output and you do

2284
01:02:23,210 --> 01:02:25,770
 

2285
01:02:23,220 --> 01:02:27,450
 that one at a time then you do clever

2286
01:02:25,760 --> 01:02:27,450
 

2287
01:02:25,770 --> 01:02:30,950
 things like you know fancy beam

2288
01:02:27,440 --> 01:02:30,950
 

2289
01:02:27,450 --> 01:02:35,760
 searching whatever to get on with that

2290
01:02:30,940 --> 01:02:35,760
 

2291
01:02:30,950 --> 01:02:37,680
 so if you will this is one beyond memory

2292
01:02:35,750 --> 01:02:37,680
 

2293
01:02:35,760 --> 01:02:39,450
 networks because memory networks you

2294
01:02:37,670 --> 01:02:39,450
 

2295
01:02:37,680 --> 01:02:43,350
 know do this maybe one to three steps

2296
01:02:39,440 --> 01:02:43,350
 

2297
01:02:39,450 --> 01:02:46,260
 and then they emit one symbol in machine

2298
01:02:43,340 --> 01:02:46,260
 

2299
01:02:43,350 --> 01:02:49,890
 translation with attention you emit many

2300
01:02:46,250 --> 01:02:49,890
 

2301
01:02:46,260 --> 01:02:52,590
 symbols one sample at a time so to show

2302
01:02:49,880 --> 01:02:52,590
 

2303
01:02:49,890 --> 01:02:55,410
 you that this works well this is

2304
01:02:52,580 --> 01:02:55,410
 

2305
01:02:52,590 --> 01:02:59,370
 basically what happens if you look at

2306
01:02:55,400 --> 01:02:59,370
 

2307
01:02:55,410 --> 01:03:01,800
 blues or so larger is better for

2308
01:02:59,360 --> 01:03:01,800
 

2309
01:02:59,370 --> 01:03:03,930
 different sentence lengths and it turns

2310
01:03:01,790 --> 01:03:03,930
 

2311
01:03:01,800 --> 01:03:06,060
 out that if you use attention then the

2312
01:03:03,920 --> 01:03:06,060
 

2313
01:03:03,930 --> 01:03:08,760
 system doesn't degrade with longer

2314
01:03:06,050 --> 01:03:08,760
 

2315
01:03:06,060 --> 01:03:13,470
 sentences whereas if you don't use

2316
01:03:08,750 --> 01:03:13,470
 

2317
01:03:08,760 --> 01:03:19,470
 attention then while it does degrade so

2318
01:03:13,460 --> 01:03:19,470
 

2319
01:03:13,470 --> 01:03:21,620
 this is essentially the even slightly

2320
01:03:19,460 --> 01:03:21,620
 

2321
01:03:19,470 --> 01:03:24,120
 more complicated version of iterative

2322
01:03:21,610 --> 01:03:24,120
 

2323
01:03:21,620 --> 01:03:26,130
 reasoning before that we just took

2324
01:03:24,110 --> 01:03:26,130
 

2325
01:03:24,120 --> 01:03:29,010
 multiple steps and it regenerated one

2326
01:03:26,120 --> 01:03:29,010
 

2327
01:03:26,130 --> 01:03:30,900
 output now we take multiple steps and at

2328
01:03:29,000 --> 01:03:30,900
 

2329
01:03:29,010 --> 01:03:35,100
 every step on the way we generate one

2330
01:03:30,890 --> 01:03:35,100
 

2331
01:03:30,900 --> 01:03:38,970
 output so we've taken quite a long

2332
01:03:35,090 --> 01:03:38,970
 

2333
01:03:35,100 --> 01:03:41,240
 journey from now from pooling to

2334
01:03:38,960 --> 01:03:41,240
 

2335
01:03:38,970 --> 01:03:44,450
 weighted average weighted pooling

2336
01:03:41,230 --> 01:03:44,450
 

2337
01:03:41,240 --> 01:03:46,369
 - weighted iterative pooling - waiter it

2338
01:03:44,440 --> 01:03:46,369
 

2339
01:03:44,450 --> 01:03:50,690
 iterative pooling where we omit one

2340
01:03:46,359 --> 01:03:50,690
 

2341
01:03:46,369 --> 01:03:53,390
 symbol at a time okay and now it's time

2342
01:03:50,680 --> 01:03:53,390
 

2343
01:03:50,690 --> 01:03:56,089
 for me to shut up and hand over to Assam

2344
01:03:53,380 --> 01:03:56,089
 

2345
01:03:53,390 --> 01:03:58,720
 who is going to be your host for the

2346
01:03:56,079 --> 01:03:58,720
 

2347
01:03:56,089 --> 01:03:58,720
 rest of today

2348
01:03:59,140 --> 01:03:59,140
 

2349
01:03:59,150 --> 01:04:02,429
[Applause]

2350
01:04:04,199 --> 01:04:04,199
 

2351
01:04:04,209 --> 01:04:12,410
 and thanks Alex so as I just mentioned

2352
01:04:09,160 --> 01:04:12,410
 

2353
01:04:09,170 --> 01:04:15,140
 so we have been a very long journey

2354
01:04:12,400 --> 01:04:15,140
 

2355
01:04:12,410 --> 01:04:16,849
 until we can check we can do the

2356
01:04:15,130 --> 01:04:16,849
 

2357
01:04:15,140 --> 01:04:19,039
 iterative pulling attention pudding

2358
01:04:16,839 --> 01:04:19,039
 

2359
01:04:16,849 --> 01:04:21,559
 while we image the symbol at each time

2360
01:04:19,029 --> 01:04:21,559
 

2361
01:04:19,039 --> 01:04:24,650
 step and actually there are many other

2362
01:04:21,549 --> 01:04:24,650
 

2363
01:04:21,559 --> 01:04:27,380
 applications which also inherit the same

2364
01:04:24,640 --> 01:04:27,380
 

2365
01:04:24,650 --> 01:04:31,039
 spirit so for instance counter network

2366
01:04:27,370 --> 01:04:31,039
 

2367
01:04:27,380 --> 01:04:33,709
 is one important candidate and this can

2368
01:04:31,029 --> 01:04:33,709
 

2369
01:04:31,039 --> 01:04:36,319
 be used to solve some famous accuracy

2370
01:04:33,699 --> 01:04:36,319
 

2371
01:04:33,709 --> 01:04:40,249
 algorithmic problems like convex hull

2372
01:04:36,309 --> 01:04:40,249
 

2373
01:04:36,319 --> 01:04:43,339
 so recall that a convex hull is to find

2374
01:04:40,239 --> 01:04:43,339
 

2375
01:04:40,249 --> 01:04:46,219
 the smallest common set to enclose the

2376
01:04:43,329 --> 01:04:46,219
 

2377
01:04:43,339 --> 01:04:49,849
 inputs like this so for instance if you

2378
01:04:46,209 --> 01:04:49,849
 

2379
01:04:46,219 --> 01:04:52,160
 look at the the input which are four

2380
01:04:49,839 --> 01:04:52,160
 

2381
01:04:49,849 --> 01:04:56,119
 points with each has two coordinates

2382
01:04:52,150 --> 01:04:56,119
 

2383
01:04:52,160 --> 01:04:59,029
 then the output orbiters paths to

2384
01:04:56,109 --> 01:04:59,029
 

2385
01:04:56,119 --> 01:05:01,729
 enclose such data points from the input

2386
01:04:59,019 --> 01:05:01,729
 

2387
01:04:59,029 --> 01:05:05,180
 set like we go from start from point one

2388
01:05:01,719 --> 01:05:05,180
 

2389
01:05:01,729 --> 01:05:08,479
 point four point two point one back then

2390
01:05:05,170 --> 01:05:08,479
 

2391
01:05:05,180 --> 01:05:10,910
 it forms a smallest common sense so at

2392
01:05:08,469 --> 01:05:10,910
 

2393
01:05:08,479 --> 01:05:14,029
 the first type it may be tempting to

2394
01:05:10,900 --> 01:05:14,029
 

2395
01:05:10,910 --> 01:05:17,119
 formulate this problem with sequence to

2396
01:05:14,019 --> 01:05:17,119
 

2397
01:05:14,029 --> 01:05:18,920
 a sequence model however record that in

2398
01:05:17,109 --> 01:05:18,920
 

2399
01:05:17,119 --> 01:05:20,929
 sequence of student model for instance

2400
01:05:18,910 --> 01:05:20,929
 

2401
01:05:18,920 --> 01:05:23,539
 for those that we use to solve the

2402
01:05:20,919 --> 01:05:23,539
 

2403
01:05:20,929 --> 01:05:26,179
 machine translation problem the output

2404
01:05:23,529 --> 01:05:26,179
 

2405
01:05:23,539 --> 01:05:28,670
 size is usually predefined for instance

2406
01:05:26,169 --> 01:05:28,670
 

2407
01:05:26,179 --> 01:05:31,549
 the opposites in between translation

2408
01:05:28,660 --> 01:05:31,549
 

2409
01:05:28,670 --> 01:05:34,130
 problem the output size is the same as

2410
01:05:31,539 --> 01:05:34,130
 

2411
01:05:31,549 --> 01:05:36,559
 the output of the vocabulary size of the

2412
01:05:34,120 --> 01:05:36,559
 

2413
01:05:34,130 --> 01:05:40,819
 target language right but for this

2414
01:05:36,549 --> 01:05:40,819
 

2415
01:05:36,559 --> 01:05:43,130
 problem the output is only determined by

2416
01:05:40,809 --> 01:05:43,130
 

2417
01:05:40,819 --> 01:05:46,459
 the size of the input because for each

2418
01:05:43,120 --> 01:05:46,459
 

2419
01:05:43,130 --> 01:05:49,459
 of at each of the decoding stage the

2420
01:05:46,449 --> 01:05:49,459
 

2421
01:05:46,459 --> 01:05:52,519
 output should be one of the elements

2422
01:05:49,449 --> 01:05:52,519
 

2423
01:05:49,459 --> 01:05:57,099
 from input set so how can we solve this

2424
01:05:52,509 --> 01:05:57,099
 

2425
01:05:52,519 --> 01:05:59,359
 problem then we can still use the

2426
01:05:57,089 --> 01:05:59,359
 

2427
01:05:57,099 --> 01:06:01,549
 sequence of sequence idea for instance

2428
01:05:59,349 --> 01:06:01,549
 

2429
01:05:59,359 --> 01:06:03,859
 here we can use to record our recurrent

2430
01:06:01,539 --> 01:06:03,859
 

2431
01:06:01,549 --> 01:06:07,489
 neural networks to do the Inc to encode

2432
01:06:03,849 --> 01:06:07,489
 

2433
01:06:03,859 --> 01:06:10,729
 and decode the encoding will be using a

2434
01:06:07,479 --> 01:06:10,729
 

2435
01:06:07,489 --> 01:06:13,880
 iron to encode the input set like the

2436
01:06:10,719 --> 01:06:13,880
 

2437
01:06:10,729 --> 01:06:15,400
 left part of the paradigm and then when

2438
01:06:13,870 --> 01:06:15,400
 

2439
01:06:13,880 --> 01:06:19,000
 at the decoding time at

2440
01:06:15,390 --> 01:06:19,000
 

2441
01:06:15,400 --> 01:06:22,960
 time we will use the current decoding

2442
01:06:18,990 --> 01:06:22,960
 

2443
01:06:19,000 --> 01:06:27,339
 hidden state as a query to pull over

2444
01:06:22,950 --> 01:06:27,339
 

2445
01:06:22,960 --> 01:06:29,859
 other inputs from the input set and the

2446
01:06:27,329 --> 01:06:29,859
 

2447
01:06:27,339 --> 01:06:32,380
 elements of the input set was served as

2448
01:06:29,849 --> 01:06:32,380
 

2449
01:06:29,859 --> 01:06:35,079
 opposed to key and value like in this

2450
01:06:32,370 --> 01:06:35,079
 

2451
01:06:32,380 --> 01:06:38,170
 case the hidden state of the decoder

2452
01:06:35,069 --> 01:06:38,170
 

2453
01:06:35,079 --> 01:06:41,619
 will be the query and then we use that

2454
01:06:38,160 --> 01:06:41,619
 

2455
01:06:38,170 --> 01:06:44,589
 to prove over the inputs from the from

2456
01:06:41,609 --> 01:06:44,589
 

2457
01:06:41,619 --> 01:06:47,710
 the encoder and we can directly generate

2458
01:06:44,579 --> 01:06:47,710
 

2459
01:06:44,589 --> 01:06:49,660
 the prediction distribution by using the

2460
01:06:47,700 --> 01:06:49,660
 

2461
01:06:47,710 --> 01:06:53,470
 attention weight when we apply the

2462
01:06:49,650 --> 01:06:53,470
 

2463
01:06:49,660 --> 01:06:56,619
 attention here and note that here every

2464
01:06:53,460 --> 01:06:56,619
 

2465
01:06:53,470 --> 01:07:00,279
 time when we add each time step of

2466
01:06:56,609 --> 01:07:00,279
 

2467
01:06:56,619 --> 01:07:04,089
 decoding the output from the previous

2468
01:07:00,269 --> 01:07:04,089
 

2469
01:07:00,279 --> 01:07:07,720
 time step war piece will be fed into the

2470
01:07:04,079 --> 01:07:07,720
 

2471
01:07:04,089 --> 01:07:10,359
 next hidden hidden state computation so

2472
01:07:07,710 --> 01:07:10,359
 

2473
01:07:07,720 --> 01:07:12,490
 that's why in spirit it is still the

2474
01:07:10,349 --> 01:07:12,490
 

2475
01:07:10,359 --> 01:07:15,309
 same is very similar to the machine

2476
01:07:12,480 --> 01:07:15,309
 

2477
01:07:12,490 --> 01:07:17,890
 translation problem where we were posed

2478
01:07:15,299 --> 01:07:17,890
 

2479
01:07:15,309 --> 01:07:21,520
 we'll use the iterative output as the

2480
01:07:17,880 --> 01:07:21,520
 

2481
01:07:17,890 --> 01:07:25,779
 input for decoding the next output by

2482
01:07:21,510 --> 01:07:25,779
 

2483
01:07:21,520 --> 01:07:28,510
 using attention so in this case you can

2484
01:07:25,769 --> 01:07:28,510
 

2485
01:07:25,779 --> 01:07:30,730
 see that in the for the purple color the

2486
01:07:28,500 --> 01:07:30,730
 

2487
01:07:28,510 --> 01:07:33,369
 at the first time step of the decoding

2488
01:07:30,720 --> 01:07:33,369
 

2489
01:07:30,730 --> 01:07:37,210
 we we pull over all the hidden States

2490
01:07:33,359 --> 01:07:37,210
 

2491
01:07:33,369 --> 01:07:39,760
 from in color and then we output the one

2492
01:07:37,200 --> 01:07:39,760
 

2493
01:07:37,210 --> 01:07:42,160
 as the output for this time step because

2494
01:07:39,750 --> 01:07:42,160
 

2495
01:07:39,760 --> 01:07:44,890
 the distribution wait maybe had the

2496
01:07:42,150 --> 01:07:44,890
 

2497
01:07:42,160 --> 01:07:46,690
 highest over the distribution then we

2498
01:07:44,880 --> 01:07:46,690
 

2499
01:07:44,890 --> 01:07:49,660
 send the input the output generated

2500
01:07:46,680 --> 01:07:49,660
 

2501
01:07:46,690 --> 01:07:51,609
 output one to be the to the next hidden

2502
01:07:49,650 --> 01:07:51,609
 

2503
01:07:49,660 --> 01:07:56,380
 state to decode the next output then we

2504
01:07:51,599 --> 01:07:56,380
 

2505
01:07:51,609 --> 01:07:58,630
 do it recurrent recursively so besides

2506
01:07:56,370 --> 01:07:58,630
 

2507
01:07:56,380 --> 01:08:00,579
 the comments how actually such pointer

2508
01:07:58,620 --> 01:08:00,579
 

2509
01:07:58,630 --> 01:08:03,900
 networks can also solve other similar

2510
01:08:00,569 --> 01:08:03,900
 

2511
01:08:00,579 --> 01:08:07,559
 problems not like the denali

2512
01:08:03,890 --> 01:08:07,559
 

2513
01:08:03,900 --> 01:08:10,480
 triangulation and the Traveling Salesman

2514
01:08:07,549 --> 01:08:10,480
 

2515
01:08:07,559 --> 01:08:13,119
 salesperson problem which is actually MP

2516
01:08:10,470 --> 01:08:13,119
 

2517
01:08:10,480 --> 01:08:15,490
 hard right so we just can use a deep

2518
01:08:13,109 --> 01:08:15,490
 

2519
01:08:13,119 --> 01:08:18,069
 learning like with the tension and the

2520
01:08:15,480 --> 01:08:18,069
 

2521
01:08:15,490 --> 01:08:22,560
 iterative output to solve such algorithm

2522
01:08:18,059 --> 01:08:22,560
 

2523
01:08:18,069 --> 01:08:25,569
 ik problems but now it's already 2019 so

2524
01:08:22,550 --> 01:08:25,569
 

2525
01:08:22,560 --> 01:08:27,730
 we saw that originally they used to ask

2526
01:08:25,559 --> 01:08:27,730
 

2527
01:08:25,569 --> 01:08:28,779
 for the encoding and decoding right so

2528
01:08:27,720 --> 01:08:28,779
 

2529
01:08:27,730 --> 01:08:31,929
 now there are some

2530
01:08:28,769 --> 01:08:31,929
 

2531
01:08:28,779 --> 01:08:34,839
 very simple simple enhancement for the

2532
01:08:31,919 --> 01:08:34,839
 

2533
01:08:31,929 --> 01:08:36,789
 existing original model for instance one

2534
01:08:34,829 --> 01:08:36,789
 

2535
01:08:34,839 --> 01:08:39,369
 way is that we can apply the transformer

2536
01:08:36,779 --> 01:08:39,369
 

2537
01:08:36,789 --> 01:08:41,469
 to encoder inputs and together and also

2538
01:08:39,359 --> 01:08:41,469
 

2539
01:08:39,369 --> 01:08:45,099
 maybe the output as well which work out

2540
01:08:41,459 --> 01:08:45,099
 

2541
01:08:41,469 --> 01:08:48,130
 later and also we may use like graph new

2542
01:08:45,089 --> 01:08:48,130
 

2543
01:08:45,099 --> 01:08:50,559
 neural neural networks to encode more

2544
01:08:48,120 --> 01:08:50,559
 

2545
01:08:48,130 --> 01:08:52,900
 information by from the graph

2546
01:08:50,549 --> 01:08:52,900
 

2547
01:08:50,559 --> 01:08:54,849
 representation perspective for instance

2548
01:08:52,890 --> 01:08:54,849
 

2549
01:08:52,900 --> 01:08:57,609
 like the traveling salesperson problem

2550
01:08:54,839 --> 01:08:57,609
 

2551
01:08:54,849 --> 01:09:00,250
 right we have distance between each data

2552
01:08:57,599 --> 01:09:00,250
 

2553
01:08:57,609 --> 01:09:02,920
 points so this is in central a graph and

2554
01:09:00,240 --> 01:09:02,920
 

2555
01:09:00,250 --> 01:09:04,750
 maybe for the graph neural networks this

2556
01:09:02,910 --> 01:09:04,750
 

2557
01:09:02,920 --> 01:09:08,619
 is a very good background for such a

2558
01:09:04,740 --> 01:09:08,619
 

2559
01:09:04,750 --> 01:09:10,989
 powerful graph based model okay so

2560
01:09:08,609 --> 01:09:10,989
 

2561
01:09:08,619 --> 01:09:13,839
 another example that inherits a sense

2562
01:09:10,979 --> 01:09:13,839
 

2563
01:09:10,989 --> 01:09:17,710
 period is the new new rotor emerging so

2564
01:09:13,829 --> 01:09:17,710
 

2565
01:09:13,839 --> 01:09:18,639
 for intend to control Network will take

2566
01:09:17,700 --> 01:09:18,639
 

2567
01:09:17,710 --> 01:09:22,900
 the input from the environment

2568
01:09:18,629 --> 01:09:22,900
 

2569
01:09:18,639 --> 01:09:26,799
 environment then then generate an output

2570
01:09:22,890 --> 01:09:26,799
 

2571
01:09:22,900 --> 01:09:30,159
 and when before generating an output it

2572
01:09:26,789 --> 01:09:30,159
 

2573
01:09:26,799 --> 01:09:32,679
 has to try to pull over from the memory

2574
01:09:30,149 --> 01:09:32,679
 

2575
01:09:30,159 --> 01:09:35,799
 cell so the memory cells actually form a

2576
01:09:32,669 --> 01:09:35,799
 

2577
01:09:32,679 --> 01:09:38,920
 memory bank here and every time you will

2578
01:09:35,789 --> 01:09:38,920
 

2579
01:09:35,799 --> 01:09:40,809
 read read from the memory like read some

2580
01:09:38,910 --> 01:09:40,809
 

2581
01:09:38,920 --> 01:09:42,789
 certain hats from the memory cells and

2582
01:09:40,799 --> 01:09:42,789
 

2583
01:09:40,809 --> 01:09:45,489
 also write back to the memory bank

2584
01:09:42,779 --> 01:09:45,489
 

2585
01:09:42,789 --> 01:09:48,099
 so the to the memory cell that reading

2586
01:09:45,479 --> 01:09:48,099
 

2587
01:09:45,489 --> 01:09:50,469
 back is the generated output that will

2588
01:09:48,089 --> 01:09:50,469
 

2589
01:09:48,099 --> 01:09:54,760
 be used for the pooling later

2590
01:09:50,459 --> 01:09:54,760
 

2591
01:09:50,469 --> 01:09:57,070
 so here the values in the attention

2592
01:09:54,750 --> 01:09:57,070
 

2593
01:09:54,760 --> 01:10:00,639
 mechanisms are all the memory cells and

2594
01:09:57,060 --> 01:10:00,639
 

2595
01:09:57,070 --> 01:10:03,670
 the attention weight here will be

2596
01:10:00,629 --> 01:10:03,670
 

2597
01:10:00,639 --> 01:10:06,840
 applied to pull over the memory cells in

2598
01:10:03,660 --> 01:10:06,840
 

2599
01:10:03,670 --> 01:10:11,199
 order to generate the hats for decoding

2600
01:10:06,830 --> 01:10:11,199
 

2601
01:10:06,840 --> 01:10:15,010
 so different from many other models or

2602
01:10:11,189 --> 01:10:15,010
 

2603
01:10:11,199 --> 01:10:17,320
 networks so that in to in a new Turing

2604
01:10:15,000 --> 01:10:17,320
 

2605
01:10:15,010 --> 01:10:20,230
 machines the attachment weights actually

2606
01:10:17,310 --> 01:10:20,230
 

2607
01:10:17,320 --> 01:10:23,320
 are stateful so it means that explicitly

2608
01:10:20,220 --> 01:10:23,320
 

2609
01:10:20,230 --> 01:10:25,679
 we use this the attention ways from the

2610
01:10:23,310 --> 01:10:25,679
 

2611
01:10:23,320 --> 01:10:28,389
 previous time step in order to obtain

2612
01:10:25,669 --> 01:10:28,389
 

2613
01:10:25,679 --> 01:10:30,909
 the attention or the attention weight of

2614
01:10:28,379 --> 01:10:30,909
 

2615
01:10:28,389 --> 01:10:33,550
 the current are time steps so this is

2616
01:10:30,899 --> 01:10:33,550
 

2617
01:10:30,909 --> 01:10:36,880
 like explicit make it stable that we

2618
01:10:33,540 --> 01:10:36,880
 

2619
01:10:33,550 --> 01:10:39,699
 always leverage the information from the

2620
01:10:36,870 --> 01:10:39,699
 

2621
01:10:36,880 --> 01:10:42,610
 previous attention waves

2622
01:10:39,689 --> 01:10:42,610
 

2623
01:10:39,699 --> 01:10:46,540
 can or update the current attention

2624
01:10:42,600 --> 01:10:46,540
 

2625
01:10:42,610 --> 01:10:50,880
 weights are iterative Li and also for

2626
01:10:46,530 --> 01:10:50,880
 

2627
01:10:46,540 --> 01:10:54,820
 values yes it is also stateful so other

2628
01:10:50,870 --> 01:10:54,820
 

2629
01:10:50,880 --> 01:10:57,520
 concrete example so the ante n actually

2630
01:10:54,810 --> 01:10:57,520
 

2631
01:10:54,820 --> 01:11:00,580
 is compared with else TM and coking a

2632
01:10:57,510 --> 01:11:00,580
 

2633
01:10:57,520 --> 01:11:04,150
 sequence although we know that LS TM

2634
01:11:00,570 --> 01:11:04,150
 

2635
01:11:00,580 --> 01:11:06,699
 like is proposed to handle the gradient

2636
01:11:04,140 --> 01:11:06,699
 

2637
01:11:04,150 --> 01:11:10,300
 valuation problems right but it actually

2638
01:11:06,689 --> 01:11:10,300
 

2639
01:11:06,699 --> 01:11:12,130
 doesn't perform pretty very well to copy

2640
01:11:10,290 --> 01:11:12,130
 

2641
01:11:10,300 --> 01:11:14,739
 a sequence when the sequence gets very

2642
01:11:12,120 --> 01:11:14,739
 

2643
01:11:12,130 --> 01:11:16,929
 long for instance in this experiment

2644
01:11:14,729 --> 01:11:16,929
 

2645
01:11:14,739 --> 01:11:20,760
 when a sequence input sequence is longer

2646
01:11:16,919 --> 01:11:20,760
 

2647
01:11:16,929 --> 01:11:23,980
 than 20 tokens then else TN like

2648
01:11:20,750 --> 01:11:23,980
 

2649
01:11:20,760 --> 01:11:27,670
 systematically fails to copy such a

2650
01:11:23,970 --> 01:11:27,670
 

2651
01:11:23,980 --> 01:11:31,420
 signal and sequence so yeah you can see

2652
01:11:27,660 --> 01:11:31,420
 

2653
01:11:27,670 --> 01:11:34,540
 that like 30 50 or even 120 LCM doesn't

2654
01:11:31,410 --> 01:11:34,540
 

2655
01:11:31,420 --> 01:11:39,040
 copy the cannot be trained to generalize

2656
01:11:34,530 --> 01:11:39,040
 

2657
01:11:34,540 --> 01:11:41,590
 the sequence copy however with a newer

2658
01:11:39,030 --> 01:11:41,590
 

2659
01:11:39,040 --> 01:11:45,070
 turing machine that also incorporated

2660
01:11:41,580 --> 01:11:45,070
 

2661
01:11:41,590 --> 01:11:46,480
 the mention mechanisms it performs much

2662
01:11:45,060 --> 01:11:46,480
 

2663
01:11:45,070 --> 01:11:50,199
 better when the sequence get longer

2664
01:11:46,470 --> 01:11:50,199
 

2665
01:11:46,480 --> 01:11:54,580
 although when the sequence gets too long

2666
01:11:50,189 --> 01:11:54,580
 

2667
01:11:50,199 --> 01:11:58,540
 like 120 this one global error there

2668
01:11:54,570 --> 01:11:58,540
 

2669
01:11:54,580 --> 01:12:01,390
 we're up to that decoding time step

2670
01:11:58,530 --> 01:12:01,390
 

2671
01:11:58,540 --> 01:12:03,670
 which is pointed by the red arrow you

2672
01:12:01,380 --> 01:12:03,670
 

2673
01:12:01,390 --> 01:12:06,969
 see that it pushed all the subsequent

2674
01:12:03,660 --> 01:12:06,969
 

2675
01:12:03,670 --> 01:12:10,690
 vectors one step back so means that

2676
01:12:06,959 --> 01:12:10,690
 

2677
01:12:06,969 --> 01:12:13,690
 every vector from the from the t minus

2678
01:12:10,680 --> 01:12:13,690
 

2679
01:12:10,690 --> 01:12:15,580
 one is copied to time step T at the

2680
01:12:13,680 --> 01:12:15,580
 

2681
01:12:13,690 --> 01:12:17,800
 decoding time so this also caused a

2682
01:12:15,570 --> 01:12:17,800
 

2683
01:12:15,580 --> 01:12:20,969
 global error so this is also shortened

2684
01:12:17,790 --> 01:12:20,969
 

2685
01:12:17,800 --> 01:12:24,429
 limitation for the for the auntie em

2686
01:12:20,959 --> 01:12:24,429
 

2687
01:12:20,969 --> 01:12:27,010
 okay so then in the rest of the tutorial

2688
01:12:24,419 --> 01:12:27,010
 

2689
01:12:24,429 --> 01:12:30,370
 then we will cover the more powerful

2690
01:12:27,000 --> 01:12:30,370
 

2691
01:12:27,010 --> 01:12:35,219
 mechanisms which is using a multiple

2692
01:12:30,360 --> 01:12:35,219
 

2693
01:12:30,370 --> 01:12:40,060
 head to design our attention algorithms

2694
01:12:35,209 --> 01:12:40,060
 

2695
01:12:35,219 --> 01:12:43,690
 so multi-head attention was proposed

2696
01:12:40,050 --> 01:12:43,690
 

2697
01:12:40,060 --> 01:12:48,400
 like two years ago by bus money at an

2698
01:12:43,680 --> 01:12:48,400
 

2699
01:12:43,690 --> 01:12:50,890
 all that in war project the input query

2700
01:12:48,390 --> 01:12:50,890
 

2701
01:12:48,400 --> 01:12:53,530
 key and value into multiple different

2702
01:12:50,880 --> 01:12:53,530
 

2703
01:12:50,890 --> 01:12:56,350
 subspaces before

2704
01:12:53,520 --> 01:12:56,350
 

2705
01:12:53,530 --> 01:12:59,050
 Concannon them together so like for this

2706
01:12:56,340 --> 01:12:59,050
 

2707
01:12:56,350 --> 01:13:02,440
 one you can see that for the key query

2708
01:12:59,040 --> 01:13:02,440
 

2709
01:12:59,050 --> 01:13:05,020
 and value we use different transfers to

2710
01:13:02,430 --> 01:13:05,020
 

2711
01:13:02,440 --> 01:13:09,790
 perform the linear transformation to

2712
01:13:05,010 --> 01:13:09,790
 

2713
01:13:05,020 --> 01:13:11,050
 have to in order to get the reps their

2714
01:13:09,780 --> 01:13:11,050
 

2715
01:13:09,790 --> 01:13:13,390
 representation in multiple different

2716
01:13:11,040 --> 01:13:13,390
 

2717
01:13:11,050 --> 01:13:15,550
 subspaces so you can see that we have a

2718
01:13:13,380 --> 01:13:15,550
 

2719
01:13:13,390 --> 01:13:18,220
 dense layer right so the tens layer is

2720
01:13:15,540 --> 01:13:18,220
 

2721
01:13:15,550 --> 01:13:19,960
 seen is the same as the fully connected

2722
01:13:18,210 --> 01:13:19,960
 

2723
01:13:18,220 --> 01:13:22,090
 layer which is performed linear

2724
01:13:19,950 --> 01:13:22,090
 

2725
01:13:19,960 --> 01:13:25,000
 transformation with his own transfers

2726
01:13:22,080 --> 01:13:25,000
 

2727
01:13:22,090 --> 01:13:29,230
 then we can come together to formulate

2728
01:13:24,990 --> 01:13:29,230
 

2729
01:13:25,000 --> 01:13:32,230
 the multi-head retention so the

2730
01:13:29,220 --> 01:13:32,230
 

2731
01:13:29,230 --> 01:13:34,900
 transformer is purely based on the

2732
01:13:32,220 --> 01:13:34,900
 

2733
01:13:32,230 --> 01:13:37,480
 strategy of multi-head attention and

2734
01:13:34,890 --> 01:13:37,480
 

2735
01:13:34,900 --> 01:13:40,930
 actually transformer has been the key to

2736
01:13:37,470 --> 01:13:40,930
 

2737
01:13:37,480 --> 01:13:42,850
 advancing a lot of state of the art in

2738
01:13:40,920 --> 01:13:42,850
 

2739
01:13:40,930 --> 01:13:46,300
 multiple different problems which we'll

2740
01:13:42,840 --> 01:13:46,300
 

2741
01:13:42,850 --> 01:13:49,150
 cover later so to provide bottom mode

2742
01:13:46,290 --> 01:13:49,150
 

2743
01:13:46,300 --> 01:13:53,800
 come concrete context about transformer

2744
01:13:49,140 --> 01:13:53,800
 

2745
01:13:49,150 --> 01:13:55,960
 it has two parts key to key components

2746
01:13:53,790 --> 01:13:55,960
 

2747
01:13:53,800 --> 01:13:58,120
 one is include ER the other is the

2748
01:13:55,950 --> 01:13:58,120
 

2749
01:13:55,960 --> 01:14:00,580
 decoder so for encoder will see that

2750
01:13:58,110 --> 01:14:00,580
 

2751
01:13:58,120 --> 01:14:03,130
 those input sequence can be passed into

2752
01:14:00,570 --> 01:14:03,130
 

2753
01:14:00,580 --> 01:14:04,750
 a embedding and also together with the

2754
01:14:03,120 --> 01:14:04,750
 

2755
01:14:03,130 --> 01:14:09,030
 positioner embedding to formulate the

2756
01:14:04,740 --> 01:14:09,030
 

2757
01:14:04,750 --> 01:14:13,330
 input of the transformer encoder input

2758
01:14:09,020 --> 01:14:13,330
 

2759
01:14:09,030 --> 01:14:15,910
 representation then we use the their key

2760
01:14:13,320 --> 01:14:15,910
 

2761
01:14:13,330 --> 01:14:17,980
 query and value from the same

2762
01:14:15,900 --> 01:14:17,980
 

2763
01:14:15,910 --> 01:14:21,090
 representation to fit into the

2764
01:14:17,970 --> 01:14:21,090
 

2765
01:14:17,980 --> 01:14:25,060
 multi-head attention and then by adding

2766
01:14:21,080 --> 01:14:25,060
 

2767
01:14:21,090 --> 01:14:28,150
 the residual connection with with the

2768
01:14:25,050 --> 01:14:28,150
 

2769
01:14:25,060 --> 01:14:31,270
 layered organization we obtain the new

2770
01:14:28,140 --> 01:14:31,270
 

2771
01:14:28,150 --> 01:14:33,010
 representation to feed into the next two

2772
01:14:31,260 --> 01:14:33,010
 

2773
01:14:31,270 --> 01:14:34,900
 layer multi-layer perception with the

2774
01:14:33,000 --> 01:14:34,900
 

2775
01:14:33,010 --> 01:14:38,160
 reloj activation which is the position

2776
01:14:34,890 --> 01:14:38,160
 

2777
01:14:34,900 --> 01:14:40,900
 wise FF in here and we apply the same

2778
01:14:38,150 --> 01:14:40,900
 

2779
01:14:38,160 --> 01:14:43,000
 residual network residual connection and

2780
01:14:40,890 --> 01:14:43,000
 

2781
01:14:40,900 --> 01:14:45,850
 the real organization to obtain the

2782
01:14:42,990 --> 01:14:45,850
 

2783
01:14:43,000 --> 01:14:49,480
 output of one single transformer encoder

2784
01:14:45,840 --> 01:14:49,480
 

2785
01:14:45,850 --> 01:14:53,170
 block so this is how we represent the

2786
01:14:49,470 --> 01:14:53,170
 

2787
01:14:49,480 --> 01:14:56,230
 input sequence with with such multi-head

2788
01:14:53,160 --> 01:14:56,230
 

2789
01:14:53,170 --> 01:14:58,990
 attention and note that because all the

2790
01:14:56,220 --> 01:14:58,990
 

2791
01:14:56,230 --> 01:15:01,660
 query key and value thought in this

2792
01:14:58,980 --> 01:15:01,660
 

2793
01:14:58,990 --> 01:15:03,489
 encoder come from the same input tokens

2794
01:15:01,650 --> 01:15:03,489
 

2795
01:15:01,660 --> 01:15:06,280
 in the input sequence

2796
01:15:03,479 --> 01:15:06,280
 

2797
01:15:03,489 --> 01:15:09,120
 we also call it self attention so means

2798
01:15:06,270 --> 01:15:09,120
 

2799
01:15:06,280 --> 01:15:12,130
 that auto query key value are the same

2800
01:15:09,110 --> 01:15:12,130
 

2801
01:15:09,120 --> 01:15:15,670
 then for the decoder they are actually

2802
01:15:12,120 --> 01:15:15,670
 

2803
01:15:12,130 --> 01:15:17,560
 two important sources so one is what we

2804
01:15:15,660 --> 01:15:17,560
 

2805
01:15:15,670 --> 01:15:19,810
 have described just now which is the

2806
01:15:17,550 --> 01:15:19,810
 

2807
01:15:17,560 --> 01:15:23,020
 input representation from the transform

2808
01:15:19,800 --> 01:15:23,020
 

2809
01:15:19,810 --> 01:15:26,560
 encoder the other is the representation

2810
01:15:23,010 --> 01:15:26,560
 

2811
01:15:23,020 --> 01:15:30,520
 of the generated outputs before the

2812
01:15:26,550 --> 01:15:30,520
 

2813
01:15:26,560 --> 01:15:34,690
 current time steps so for instance we'll

2814
01:15:30,510 --> 01:15:34,690
 

2815
01:15:30,520 --> 01:15:37,780
 think about that at time step T we want

2816
01:15:34,680 --> 01:15:37,780
 

2817
01:15:34,690 --> 01:15:41,440
 to encode or represent all the generated

2818
01:15:37,770 --> 01:15:41,440
 

2819
01:15:37,780 --> 01:15:44,200
 outputs before transferred T then we can

2820
01:15:41,430 --> 01:15:44,200
 

2821
01:15:41,440 --> 01:15:46,960
 still apply such a self attention which

2822
01:15:44,190 --> 01:15:46,960
 

2823
01:15:44,200 --> 01:15:51,190
 is similar to the two that in the

2824
01:15:46,950 --> 01:15:51,190
 

2825
01:15:46,960 --> 01:15:53,739
 transform encoder to to apply the self

2826
01:15:51,180 --> 01:15:53,739
 

2827
01:15:51,190 --> 01:15:56,410
 attention with multiple hats and to get

2828
01:15:53,729 --> 01:15:56,410
 

2829
01:15:53,739 --> 01:15:59,380
 the representation for each token of the

2830
01:15:56,400 --> 01:15:59,380
 

2831
01:15:56,410 --> 01:16:02,370
 generated output sequence but there's

2832
01:15:59,370 --> 01:16:02,370
 

2833
01:15:59,380 --> 01:16:07,300
 one important difference between the

2834
01:16:02,360 --> 01:16:07,300
 

2835
01:16:02,370 --> 01:16:11,050
 self tension in decoder that is in this

2836
01:16:07,290 --> 01:16:11,050
 

2837
01:16:07,300 --> 01:16:14,260
 encoder actually for each token it can

2838
01:16:11,040 --> 01:16:14,260
 

2839
01:16:11,050 --> 01:16:18,340
 attend to up to tokens of all the time

2840
01:16:14,250 --> 01:16:18,340
 

2841
01:16:14,260 --> 01:16:21,430
 stats however in the decoder for each

2842
01:16:18,330 --> 01:16:21,430
 

2843
01:16:18,340 --> 01:16:24,880
 generated token it can only attend to

2844
01:16:21,420 --> 01:16:24,880
 

2845
01:16:21,430 --> 01:16:28,750
 the tokens that are no later than the

2846
01:16:24,870 --> 01:16:28,750
 

2847
01:16:24,880 --> 01:16:30,760
 current time step this is because we

2848
01:16:28,740 --> 01:16:30,760
 

2849
01:16:28,750 --> 01:16:34,060
 cannot simply use the future information

2850
01:16:30,750 --> 01:16:34,060
 

2851
01:16:30,760 --> 01:16:37,570
 to decode the current hook so that's why

2852
01:16:34,050 --> 01:16:37,570
 

2853
01:16:34,060 --> 01:16:41,770
 the this self attention is we have to

2854
01:16:37,560 --> 01:16:41,770
 

2855
01:16:37,570 --> 01:16:45,100
 apply some mask matrix to hide the

2856
01:16:41,760 --> 01:16:45,100
 

2857
01:16:41,770 --> 01:16:47,250
 attention links from to prevent

2858
01:16:45,090 --> 01:16:47,250
 

2859
01:16:45,100 --> 01:16:51,100
 predicting using the future information

2860
01:16:47,240 --> 01:16:51,100
 

2861
01:16:47,250 --> 01:16:54,760
 after that then in the day we use the

2862
01:16:51,090 --> 01:16:54,760
 

2863
01:16:51,100 --> 01:17:00,000
 another multi-head attention to decode

2864
01:16:54,750 --> 01:17:00,000
 

2865
01:16:54,760 --> 01:17:03,880
 the output where the query come from the

2866
01:16:59,990 --> 01:17:03,880
 

2867
01:17:00,000 --> 01:17:07,239
 the the representation from the previous

2868
01:17:03,870 --> 01:17:07,239
 

2869
01:17:03,880 --> 01:17:09,820
 time steps of the decoder and the key

2870
01:17:07,229 --> 01:17:09,820
 

2871
01:17:07,239 --> 01:17:12,160
 and value all come from the input

2872
01:17:09,810 --> 01:17:12,160
 

2873
01:17:09,820 --> 01:17:15,969
 representation from the transformer

2874
01:17:12,150 --> 01:17:15,969
 

2875
01:17:12,160 --> 01:17:16,870
 encoder then the rest will be very

2876
01:17:15,959 --> 01:17:16,870
 

2877
01:17:15,969 --> 01:17:19,390
 similar to the

2878
01:17:16,860 --> 01:17:19,390
 

2879
01:17:16,870 --> 01:17:21,610
 transforming encoder that we apply the

2880
01:17:19,380 --> 01:17:21,610
 

2881
01:17:19,390 --> 01:17:25,210
 normalization and also the residual

2882
01:17:21,600 --> 01:17:25,210
 

2883
01:17:21,610 --> 01:17:29,020
 connections then we use we apply another

2884
01:17:25,200 --> 01:17:29,020
 

2885
01:17:25,210 --> 01:17:33,130
 test layer to output the the decoded

2886
01:17:29,010 --> 01:17:33,130
 

2887
01:17:29,020 --> 01:17:36,400
 token so this is the transformer encoder

2888
01:17:33,120 --> 01:17:36,400
 

2889
01:17:33,130 --> 01:17:38,920
 and a decoder part to enable us to apply

2890
01:17:36,390 --> 01:17:38,920
 

2891
01:17:36,400 --> 01:17:43,380
 it into the machine translation problems

2892
01:17:38,910 --> 01:17:43,380
 

2893
01:17:38,920 --> 01:17:47,020
 to perform the sequence transaction and

2894
01:17:43,370 --> 01:17:47,020
 

2895
01:17:43,380 --> 01:17:49,630
 actually the sim the multi hat attention

2896
01:17:47,010 --> 01:17:49,630
 

2897
01:17:47,020 --> 01:17:51,910
 can also be used in many other problems

2898
01:17:49,620 --> 01:17:51,910
 

2899
01:17:49,630 --> 01:17:54,310
 for instance in computer vision so

2900
01:17:51,900 --> 01:17:54,310
 

2901
01:17:51,910 --> 01:17:57,790
 Instamatic segmentation the task is to

2902
01:17:54,300 --> 01:17:57,790
 

2903
01:17:54,310 --> 01:18:00,190
 classify a certain pixel of an image to

2904
01:17:57,780 --> 01:18:00,190
 

2905
01:17:57,790 --> 01:18:02,890
 recognize what type of these pixel is is

2906
01:18:00,180 --> 01:18:02,890
 

2907
01:18:00,190 --> 01:18:04,720
 to provide some more semantic meaning so

2908
01:18:02,880 --> 01:18:04,720
 

2909
01:18:02,890 --> 01:18:07,060
 for instance if you look only look at

2910
01:18:04,710 --> 01:18:07,060
 

2911
01:18:04,720 --> 01:18:09,490
 this partial image right and let's

2912
01:18:07,050 --> 01:18:09,490
 

2913
01:18:07,060 --> 01:18:11,680
 answer if we want to answer the question

2914
01:18:09,480 --> 01:18:11,680
 

2915
01:18:09,490 --> 01:18:14,560
 whether this certain pixel is a sea or a

2916
01:18:11,670 --> 01:18:14,560
 

2917
01:18:11,680 --> 01:18:16,360
 water it can be ambiguous because we

2918
01:18:14,550 --> 01:18:16,360
 

2919
01:18:14,560 --> 01:18:17,920
 don't know whether it's even for human

2920
01:18:16,350 --> 01:18:17,920
 

2921
01:18:16,360 --> 01:18:21,910
 beings very hard to tell whether it's a

2922
01:18:17,910 --> 01:18:21,910
 

2923
01:18:17,920 --> 01:18:23,830
 sea or water right and if you have more

2924
01:18:21,900 --> 01:18:23,830
 

2925
01:18:21,910 --> 01:18:25,930
 information about the picture for

2926
01:18:23,820 --> 01:18:25,930
 

2927
01:18:23,830 --> 01:18:28,960
 instance if you specifically when you

2928
01:18:25,920 --> 01:18:28,960
 

2929
01:18:25,930 --> 01:18:32,740
 see there's a boat here you probably

2930
01:18:28,950 --> 01:18:32,740
 

2931
01:18:28,960 --> 01:18:35,320
 what tend to classify those pixels the

2932
01:18:32,730 --> 01:18:35,320
 

2933
01:18:32,740 --> 01:18:38,250
 surrounding pixels at the bottom as sea

2934
01:18:35,310 --> 01:18:38,250
 

2935
01:18:35,320 --> 01:18:41,410
 rather than water to be more specific

2936
01:18:38,240 --> 01:18:41,410
 

2937
01:18:38,250 --> 01:18:43,750
 so actually multi had attention can be

2938
01:18:41,400 --> 01:18:43,750
 

2939
01:18:41,410 --> 01:18:48,700
 used to pour such feature representation

2940
01:18:43,740 --> 01:18:48,700
 

2941
01:18:43,750 --> 01:18:51,730
 like the boat in order to help infer the

2942
01:18:48,690 --> 01:18:51,730
 

2943
01:18:48,700 --> 01:18:54,280
 semantic meaning of the pixels which are

2944
01:18:51,720 --> 01:18:54,280
 

2945
01:18:51,730 --> 01:18:57,340
 even more distant distant from the

2946
01:18:54,270 --> 01:18:57,340
 

2947
01:18:54,280 --> 01:19:00,460
 existing objects like a boat here so

2948
01:18:57,330 --> 01:19:00,460
 

2949
01:18:57,340 --> 01:19:03,190
 this is the mechanisms proposed by some

2950
01:19:00,450 --> 01:19:03,190
 

2951
01:19:00,460 --> 01:19:04,840
 at all this year to apply the multi hat

2952
01:19:03,180 --> 01:19:04,840
 

2953
01:19:03,190 --> 01:19:08,050
 attention for semantic record plan

2954
01:19:04,830 --> 01:19:08,050
 

2955
01:19:04,840 --> 01:19:10,870
 segmentation so first of all for the raw

2956
01:19:08,040 --> 01:19:10,870
 

2957
01:19:08,050 --> 01:19:15,010
 image we still need to use a backbone

2958
01:19:10,860 --> 01:19:15,010
 

2959
01:19:10,870 --> 01:19:16,960
 Network like a ResNet 50 to obtain the

2960
01:19:15,000 --> 01:19:16,960
 

2961
01:19:15,010 --> 01:19:19,660
 feature map so this is like a feature

2962
01:19:16,950 --> 01:19:19,660
 

2963
01:19:16,960 --> 01:19:22,450
 instruction from the raw image then

2964
01:19:19,650 --> 01:19:22,450
 

2965
01:19:19,660 --> 01:19:25,360
 after that we can map we can project

2966
01:19:22,440 --> 01:19:25,360
 

2967
01:19:22,450 --> 01:19:28,600
 such a feature map into different

2968
01:19:25,350 --> 01:19:28,600
 

2969
01:19:25,360 --> 01:19:32,310
 outputs like the

2970
01:19:28,590 --> 01:19:32,310
 

2971
01:19:28,600 --> 01:19:35,290
 like the key query and V and value dense

2972
01:19:32,300 --> 01:19:35,290
 

2973
01:19:32,310 --> 01:19:39,070
 at the prediction time we can apply the

2974
01:19:35,280 --> 01:19:39,070
 

2975
01:19:35,290 --> 01:19:41,560
 multi-head attention to use the query to

2976
01:19:39,060 --> 01:19:41,560
 

2977
01:19:39,070 --> 01:19:45,190
 prove ur the key and together with the

2978
01:19:41,550 --> 01:19:45,190
 

2979
01:19:41,560 --> 01:19:47,290
 value in order to determine whether I

2980
01:19:45,180 --> 01:19:47,290
 

2981
01:19:45,190 --> 01:19:50,680
 whether we need to allocate some

2982
01:19:47,280 --> 01:19:50,680
 

2983
01:19:47,290 --> 01:19:52,570
 attention or the alignment bias of a

2984
01:19:50,670 --> 01:19:52,570
 

2985
01:19:50,680 --> 01:19:55,810
 different feature representation which

2986
01:19:52,560 --> 01:19:55,810
 

2987
01:19:52,570 --> 01:19:59,380
 is from the backbone and networks for

2988
01:19:55,800 --> 01:19:59,380
 

2989
01:19:55,810 --> 01:20:01,330
 instance maybe some certain patterns may

2990
01:19:59,370 --> 01:20:01,330
 

2991
01:19:59,380 --> 01:20:03,820
 formulate the representation for a boat

2992
01:20:01,320 --> 01:20:03,820
 

2993
01:20:01,330 --> 01:20:05,740
 then we can allocate more attention to

2994
01:20:03,810 --> 01:20:05,740
 

2995
01:20:03,820 --> 01:20:11,230
 that in order to categorize the

2996
01:20:05,730 --> 01:20:11,230
 

2997
01:20:05,740 --> 01:20:13,690
 surrounding areas to BC so as a concrete

2998
01:20:11,220 --> 01:20:13,690
 

2999
01:20:11,230 --> 01:20:18,120
 example for the performance of such a

3000
01:20:13,680 --> 01:20:18,120
 

3001
01:20:13,690 --> 01:20:20,500
 mechanism you can tell that for the

3002
01:20:18,110 --> 01:20:20,500
 

3003
01:20:18,120 --> 01:20:24,730
 original fully convolutional neural

3004
01:20:20,490 --> 01:20:24,730
 

3005
01:20:20,500 --> 01:20:28,750
 networks this actually does not fail to

3006
01:20:24,720 --> 01:20:28,750
 

3007
01:20:24,730 --> 01:20:30,820
 recognize the surrounding areas for the

3008
01:20:28,740 --> 01:20:30,820
 

3009
01:20:28,750 --> 01:20:33,460
 boat to be see actually you see that

3010
01:20:30,810 --> 01:20:33,460
 

3011
01:20:30,820 --> 01:20:36,130
 there's multiple area on the left bottom

3012
01:20:33,450 --> 01:20:36,130
 

3013
01:20:33,460 --> 01:20:39,670
 it classified them to be water rather

3014
01:20:36,120 --> 01:20:39,670
 

3015
01:20:36,130 --> 01:20:41,680
 than C and if you apply the multi head

3016
01:20:39,660 --> 01:20:41,680
 

3017
01:20:39,670 --> 01:20:44,260
 attention to prove over the vision map

3018
01:20:41,670 --> 01:20:44,260
 

3019
01:20:41,680 --> 01:20:48,160
 to have more information about what's

3020
01:20:44,250 --> 01:20:48,160
 

3021
01:20:44,260 --> 01:20:51,280
 around then you the model can be smarter

3022
01:20:48,150 --> 01:20:51,280
 

3023
01:20:48,160 --> 01:20:54,310
 and most specific to categorize certain

3024
01:20:51,270 --> 01:20:54,310
 

3025
01:20:51,280 --> 01:20:58,900
 elements or the pixels to be specific to

3026
01:20:54,300 --> 01:20:58,900
 

3027
01:20:54,310 --> 01:21:00,850
 BC rather than just water made by

3028
01:20:58,890 --> 01:21:00,850
 

3029
01:20:58,900 --> 01:21:06,180
 allocating more attention to those

3030
01:21:00,840 --> 01:21:06,180
 

3031
01:21:00,850 --> 01:21:10,510
 feature resin tation of the boat okay so

3032
01:21:06,170 --> 01:21:10,510
 

3033
01:21:06,180 --> 01:21:13,450
 next we will talk about some more

3034
01:21:10,500 --> 01:21:13,450
 

3035
01:21:10,510 --> 01:21:16,270
 powerful or pre-training methods that is

3036
01:21:13,440 --> 01:21:16,270
 

3037
01:21:13,450 --> 01:21:17,680
 coming from the transformer so before

3038
01:21:16,260 --> 01:21:17,680
 

3039
01:21:16,270 --> 01:21:22,050
 that I can take some questions if you

3040
01:21:17,670 --> 01:21:22,050
 

3041
01:21:17,680 --> 01:21:22,050
 have so any questions so far

3042
01:21:23,740 --> 01:21:23,740
 

3043
01:21:23,750 --> 01:21:29,210
 okay so let's move on to the

3044
01:21:26,629 --> 01:21:29,210
 

3045
01:21:26,639 --> 01:21:32,579
 pre-training part so question oh yeah

3046
01:21:29,200 --> 01:21:32,579
 

3047
01:21:29,210 --> 01:21:35,730
 sorry I didn't see that yeah have you

3048
01:21:32,569 --> 01:21:35,730
 

3049
01:21:32,579 --> 01:21:37,800
 looked do you know if there's any work

3050
01:21:35,720 --> 01:21:37,800
 

3051
01:21:35,730 --> 01:21:40,619
 that has looked into the weights that

3052
01:21:37,790 --> 01:21:40,619
 

3053
01:21:37,800 --> 01:21:43,170
 the transformer learns like for example

3054
01:21:40,609 --> 01:21:43,170
 

3055
01:21:40,619 --> 01:21:44,820
 in different layers you have different

3056
01:21:43,160 --> 01:21:44,820
 

3057
01:21:43,170 --> 01:21:47,190
 distribution over weights or things like

3058
01:21:44,810 --> 01:21:47,190
 

3059
01:21:44,820 --> 01:21:50,869
 that sorry can you speak a bit louder

3060
01:21:47,180 --> 01:21:50,869
 

3061
01:21:47,190 --> 01:21:54,239
 it's a bit distant okay yeah so are you

3062
01:21:50,859 --> 01:21:54,239
 

3063
01:21:50,869 --> 01:21:56,400
 aware of any prior work that has looked

3064
01:21:54,229 --> 01:21:56,400
 

3065
01:21:54,239 --> 01:21:59,099
 into the weights that the transformer

3066
01:21:56,390 --> 01:21:59,099
 

3067
01:21:56,400 --> 01:22:02,570
 learns in different layers so they have

3068
01:21:59,089 --> 01:22:02,570
 

3069
01:21:59,099 --> 01:22:05,159
 I think six layers in the original paper

3070
01:22:02,560 --> 01:22:05,159
 

3071
01:22:02,570 --> 01:22:09,900
 does anyone looked into those like sort

3072
01:22:05,149 --> 01:22:09,900
 

3073
01:22:05,159 --> 01:22:12,989
 of qualitative things so I noticed one

3074
01:22:09,890 --> 01:22:12,989
 

3075
01:22:09,900 --> 01:22:15,929
 paper that actually try to understand

3076
01:22:12,979 --> 01:22:15,929
 

3077
01:22:12,989 --> 01:22:19,380
 what the transformer learned from hockey

3078
01:22:15,919 --> 01:22:19,380
 

3079
01:22:15,929 --> 01:22:21,659
 tasks actually the the type of message

3080
01:22:19,370 --> 01:22:21,659
 

3081
01:22:19,380 --> 01:22:24,210
 is that the the hierarchy information

3082
01:22:21,649 --> 01:22:24,210
 

3083
01:22:21,659 --> 01:22:26,460
 that we would have expected are not that

3084
01:22:24,200 --> 01:22:26,460
 

3085
01:22:24,210 --> 01:22:30,750
 of its so this is this is a

3086
01:22:26,450 --> 01:22:30,750
 

3087
01:22:26,460 --> 01:22:32,730
 message for that paper consumes if we

3088
01:22:30,740 --> 01:22:32,730
 

3089
01:22:30,750 --> 01:22:34,949
 look at the output of neutral during

3090
01:22:32,720 --> 01:22:34,949
 

3091
01:22:32,730 --> 01:22:36,599
 machines it's pretty interpretable in

3092
01:22:34,939 --> 01:22:36,599
 

3093
01:22:34,949 --> 01:22:38,369
 the sense that when it if you see the

3094
01:22:36,589 --> 01:22:38,369
 

3095
01:22:36,599 --> 01:22:40,079
 output that is generated for copying you

3096
01:22:38,359 --> 01:22:40,079
 

3097
01:22:38,369 --> 01:22:41,909
 see that the Machine actually takes the

3098
01:22:40,069 --> 01:22:41,909
 

3099
01:22:40,079 --> 01:22:43,980
 hair to the first part of the tape and

3100
01:22:41,899 --> 01:22:43,980
 

3101
01:22:41,909 --> 01:22:45,659
 then copies it depending in the task you

3102
01:22:43,970 --> 01:22:45,659
 

3103
01:22:43,980 --> 01:22:48,270
 can make sense that it's kind of

3104
01:22:45,649 --> 01:22:48,270
 

3105
01:22:45,659 --> 01:22:50,760
 creating a program in itself right for

3106
01:22:48,260 --> 01:22:50,760
 

3107
01:22:48,270 --> 01:22:54,360
 executing that task now if we if we look

3108
01:22:50,750 --> 01:22:54,360
 

3109
01:22:50,760 --> 01:22:57,150
 at the point of networks paper is there

3110
01:22:54,350 --> 01:22:57,150
 

3111
01:22:54,360 --> 01:23:00,420
 some kind of intuition that could be

3112
01:22:57,140 --> 01:23:00,420
 

3113
01:22:57,150 --> 01:23:01,559
 associated with say the instance of

3114
01:23:00,410 --> 01:23:01,559
 

3115
01:23:00,420 --> 01:23:05,520
 pointer Network which is meant for

3116
01:23:01,549 --> 01:23:05,520
 

3117
01:23:01,559 --> 01:23:09,960
 convex hulls or some other tasks I

3118
01:23:05,510 --> 01:23:09,960
 

3119
01:23:05,520 --> 01:23:12,210
 personally tried implementing sorting

3120
01:23:09,950 --> 01:23:12,210
 

3121
01:23:09,960 --> 01:23:15,179
 through point of networks and it worked

3122
01:23:12,200 --> 01:23:15,179
 

3123
01:23:12,210 --> 01:23:16,800
 fabulously for the sequence lengths on

3124
01:23:15,169 --> 01:23:16,800
 

3125
01:23:15,179 --> 01:23:18,570
 which I trained it on but the

3126
01:23:16,790 --> 01:23:18,570
 

3127
01:23:16,800 --> 01:23:20,190
 performance rapidly degraded the moment

3128
01:23:18,560 --> 01:23:20,190
 

3129
01:23:18,570 --> 01:23:21,750
 the sequence left it was shown a

3130
01:23:20,180 --> 01:23:21,750
 

3131
01:23:20,190 --> 01:23:23,250
 sequence which was not at the same

3132
01:23:21,740 --> 01:23:23,250
 

3133
01:23:21,750 --> 01:23:24,840
 length as what did I seen in the

3134
01:23:23,240 --> 01:23:24,840
 

3135
01:23:23,250 --> 01:23:27,719
 training data and I was trying to figure

3136
01:23:24,830 --> 01:23:27,719
 

3137
01:23:24,840 --> 01:23:30,050
 out what what's going on there and I

3138
01:23:27,709 --> 01:23:30,050
 

3139
01:23:27,719 --> 01:23:33,059
 don't have a clear interpretation of

3140
01:23:30,040 --> 01:23:33,059
 

3141
01:23:30,050 --> 01:23:34,680
 what the encoder and decoder and the

3142
01:23:33,049 --> 01:23:34,680
 

3143
01:23:33,059 --> 01:23:36,030
 attention are actually you know

3144
01:23:34,670 --> 01:23:36,030
 

3145
01:23:34,680 --> 01:23:38,130
 what is what is it that they are trying

3146
01:23:36,020 --> 01:23:38,130
 

3147
01:23:36,030 --> 01:23:39,780
 to represent internally in case of

3148
01:23:38,120 --> 01:23:39,780
 

3149
01:23:38,130 --> 01:23:41,120
 Poynter network so any insights that you

3150
01:23:39,770 --> 01:23:41,120
 

3151
01:23:39,780 --> 01:23:46,080
 might have with the great

3152
01:23:41,110 --> 01:23:46,080
 

3153
01:23:41,120 --> 01:23:50,700
 so the yeah for the Pointer networks so

3154
01:23:46,070 --> 01:23:50,700
 

3155
01:23:46,080 --> 01:23:53,130
 I think my in my insight is that the for

3156
01:23:50,690 --> 01:23:53,130
 

3157
01:23:50,700 --> 01:23:57,600
 the for adit adit at each decoding part

3158
01:23:53,120 --> 01:23:57,600
 

3159
01:23:53,130 --> 01:24:00,530
 it may try to make use of the the other

3160
01:23:57,590 --> 01:24:00,530
 

3161
01:23:57,600 --> 01:24:03,240
 existing generated outputs to help

3162
01:24:00,520 --> 01:24:03,240
 

3163
01:24:00,530 --> 01:24:06,930
 determine which opener my next input

3164
01:24:03,230 --> 01:24:06,930
 

3165
01:24:03,240 --> 01:24:08,640
 from the predefined input set and the

3166
01:24:06,920 --> 01:24:08,640
 

3167
01:24:06,930 --> 01:24:12,150
 the sorting for instance for the sorting

3168
01:24:08,630 --> 01:24:12,150
 

3169
01:24:08,640 --> 01:24:14,940
 part I think if you have a very small

3170
01:24:12,140 --> 01:24:14,940
 

3171
01:24:12,150 --> 01:24:17,520
 data set a pro it may have a potential

3172
01:24:14,930 --> 01:24:17,520
 

3173
01:24:14,940 --> 01:24:22,650
 to overfit rather than generalize with

3174
01:24:17,510 --> 01:24:22,650
 

3175
01:24:17,520 --> 01:24:25,950
 certain certain patterns so although I

3176
01:24:22,640 --> 01:24:25,950
 

3177
01:24:22,650 --> 01:24:28,470
 haven't experimented such such results

3178
01:24:25,940 --> 01:24:28,470
 

3179
01:24:25,950 --> 01:24:32,520
 but my guess is that when you try a

3180
01:24:28,460 --> 01:24:32,520
 

3181
01:24:28,470 --> 01:24:35,190
 training on very large data sets

3182
01:24:32,510 --> 01:24:35,190
 

3183
01:24:32,520 --> 01:24:38,480
 it may have potential to generalize

3184
01:24:35,180 --> 01:24:38,480
 

3185
01:24:35,190 --> 01:24:42,830
 better than the the risk of overfitting

3186
01:24:38,470 --> 01:24:42,830
 

3187
01:24:38,480 --> 01:24:45,930
 of the input of the other privada inputs

3188
01:24:42,820 --> 01:24:45,930
 

3189
01:24:42,830 --> 01:24:47,730
 would it be correct to say that in case

3190
01:24:45,920 --> 01:24:47,730
 

3191
01:24:45,930 --> 01:24:50,520
 of sorting task after it has generated

3192
01:24:47,720 --> 01:24:50,520
 

3193
01:24:47,730 --> 01:24:53,460
 say first three outputs of the sequence

3194
01:24:50,510 --> 01:24:53,460
 

3195
01:24:50,520 --> 01:24:56,940
 at the next point of time it is actually

3196
01:24:53,450 --> 01:24:56,940
 

3197
01:24:53,460 --> 01:24:59,400
 trying to emulate comparing the latest

3198
01:24:56,930 --> 01:24:59,400
 

3199
01:24:56,940 --> 01:25:01,500
 output with all the inputs in a subtract

3200
01:24:59,390 --> 01:25:01,500
 

3201
01:24:59,400 --> 01:25:03,390
 you know subtraction or raddish primary

3202
01:25:01,490 --> 01:25:03,390
 

3203
01:25:01,500 --> 01:25:04,710
 subtraction sense and trying to figure

3204
01:25:03,380 --> 01:25:04,710
 

3205
01:25:03,390 --> 01:25:06,090
 out which are negative which are posit

3206
01:25:04,700 --> 01:25:06,090
 

3207
01:25:04,710 --> 01:25:08,130
 and take the smallest one and try to

3208
01:25:06,080 --> 01:25:08,130
 

3209
01:25:06,090 --> 01:25:10,410
 output that or is that interpretation

3210
01:25:08,120 --> 01:25:10,410
 

3211
01:25:08,130 --> 01:25:11,700
 very naive and it's some kind of

3212
01:25:10,400 --> 01:25:11,700
 

3213
01:25:10,410 --> 01:25:13,590
 embedding that it is learning which

3214
01:25:11,690 --> 01:25:13,590
 

3215
01:25:11,700 --> 01:25:16,110
 cannot be really that easily interpreted

3216
01:25:13,580 --> 01:25:16,110
 

3217
01:25:13,590 --> 01:25:17,850
 yeah that's that's a good point so if

3218
01:25:16,100 --> 01:25:17,850
 

3219
01:25:16,110 --> 01:25:20,940
 you look at the output generated from

3220
01:25:17,840 --> 01:25:20,940
 

3221
01:25:17,850 --> 01:25:23,520
 the pond the network right even actually

3222
01:25:20,930 --> 01:25:23,520
 

3223
01:25:20,940 --> 01:25:26,250
 the lab for instance like the Traveling

3224
01:25:23,510 --> 01:25:26,250
 

3225
01:25:23,520 --> 01:25:29,010
 Salesman problem here the output is

3226
01:25:26,240 --> 01:25:29,010
 

3227
01:25:26,250 --> 01:25:31,650
 actually not correct so means that so

3228
01:25:29,000 --> 01:25:31,650
 

3229
01:25:29,010 --> 01:25:34,170
 that's why my my thought is that on

3230
01:25:31,640 --> 01:25:34,170
 

3231
01:25:31,650 --> 01:25:37,650
 smaller data set if that path name has a

3232
01:25:34,160 --> 01:25:37,650
 

3233
01:25:34,170 --> 01:25:40,350
 potential to overfit to to memorize how

3234
01:25:37,640 --> 01:25:40,350
 

3235
01:25:37,650 --> 01:25:43,350
 to do the permutation of the input data

3236
01:25:40,340 --> 01:25:43,350
 

3237
01:25:40,350 --> 01:25:46,590
 points but when you CH analyze it may

3238
01:25:43,340 --> 01:25:46,590
 

3239
01:25:43,350 --> 01:25:48,000
 have the chance to to make use of more

3240
01:25:46,580 --> 01:25:48,000
 

3241
01:25:46,590 --> 01:25:49,620
 information from input

3242
01:25:47,990 --> 01:25:49,620
 

3243
01:25:48,000 --> 01:25:52,650
 for instance the distance between each

3244
01:25:49,610 --> 01:25:52,650
 

3245
01:25:49,620 --> 01:25:56,220
 data points here to understand how I

3246
01:25:52,640 --> 01:25:56,220
 

3247
01:25:52,650 --> 01:25:59,160
 just permitted order data inputs so

3248
01:25:56,210 --> 01:25:59,160
 

3249
01:25:56,220 --> 01:26:01,800
 that's why here we say that maybe we can

3250
01:25:59,150 --> 01:26:01,800
 

3251
01:25:59,160 --> 01:26:04,520
 also make use of the reach information

3252
01:26:01,790 --> 01:26:04,520
 

3253
01:26:01,800 --> 01:26:07,800
 from the graph and that may possibly

3254
01:26:04,510 --> 01:26:07,800
 

3255
01:26:04,520 --> 01:26:10,680
 provide with us more insights of what we

3256
01:26:07,790 --> 01:26:10,680
 

3257
01:26:07,800 --> 01:26:12,690
 learned to do the permutation because if

3258
01:26:10,670 --> 01:26:12,690
 

3259
01:26:10,680 --> 01:26:15,090
 you look if if the mother can look at

3260
01:26:12,680 --> 01:26:15,090
 

3261
01:26:12,690 --> 01:26:16,800
 the wooden date Labor's of the graph in

3262
01:26:15,080 --> 01:26:16,800
 

3263
01:26:15,090 --> 01:26:18,870
 order to decode then maybe he can

3264
01:26:16,790 --> 01:26:18,870
 

3265
01:26:16,800 --> 01:26:21,480
 provide more insights and make it more

3266
01:26:18,860 --> 01:26:21,480
 

3267
01:26:18,870 --> 01:26:25,730
 interpretable which is also not bound by

3268
01:26:21,470 --> 01:26:25,730
 

3269
01:26:21,480 --> 01:26:31,280
 this original pointer networks thank you

3270
01:26:25,720 --> 01:26:31,280
 

3271
01:26:25,730 --> 01:26:33,900
 okay so okay so let me move on to the

3272
01:26:31,270 --> 01:26:33,900
 

3273
01:26:31,280 --> 01:26:36,750
 pre-training this is actually pretty

3274
01:26:33,890 --> 01:26:36,750
 

3275
01:26:33,900 --> 01:26:39,860
 exciting our topic in especially in the

3276
01:26:36,740 --> 01:26:39,860
 

3277
01:26:36,750 --> 01:26:42,990
 past year so Posse I think this is like

3278
01:26:39,850 --> 01:26:42,990
 

3279
01:26:39,860 --> 01:26:44,910
 many of the breakthroughs in RP come

3280
01:26:42,980 --> 01:26:44,910
 

3281
01:26:42,990 --> 01:26:48,270
 from the pre training schemes so now

3282
01:26:44,900 --> 01:26:48,270
 

3283
01:26:44,910 --> 01:26:51,660
 let's look at this so amount is pert

3284
01:26:48,260 --> 01:26:51,660
 

3285
01:26:48,270 --> 01:26:55,260
 because like pretty impressive because

3286
01:26:51,650 --> 01:26:55,260
 

3287
01:26:51,660 --> 01:26:58,550
 you'll achieve state-of-the-art 11 RP

3288
01:26:55,250 --> 01:26:58,550
 

3289
01:26:55,260 --> 01:27:01,830
 pasts and how an its build based on the

3290
01:26:58,540 --> 01:27:01,830
 

3291
01:26:58,550 --> 01:27:05,070
 encoder reputation from the transformer

3292
01:27:01,820 --> 01:27:05,070
 

3293
01:27:01,830 --> 01:27:08,310
 so how it works so to provide more

3294
01:27:05,060 --> 01:27:08,310
 

3295
01:27:05,070 --> 01:27:09,990
 context about the pre-training so for

3296
01:27:08,300 --> 01:27:09,990
 

3297
01:27:08,310 --> 01:27:12,080
 instance recall that the for the

3298
01:27:09,980 --> 01:27:12,080
 

3299
01:27:09,990 --> 01:27:15,540
 computer vision right we can pre train

3300
01:27:12,070 --> 01:27:15,540
 

3301
01:27:12,080 --> 01:27:19,170
 like a backbone networks based on the

3302
01:27:15,530 --> 01:27:19,170
 

3303
01:27:15,540 --> 01:27:21,000
 image net or even larger data set to

3304
01:27:19,160 --> 01:27:21,000
 

3305
01:27:19,170 --> 01:27:24,270
 obtain the multi-layer representations

3306
01:27:20,990 --> 01:27:24,270
 

3307
01:27:21,000 --> 01:27:27,630
 of multiple levels of abstraction for

3308
01:27:24,260 --> 01:27:27,630
 

3309
01:27:24,270 --> 01:27:30,090
 the input image then for NRP

3310
01:27:27,620 --> 01:27:30,090
 

3311
01:27:27,630 --> 01:27:33,510
 we can also do the same we can actually

3312
01:27:30,080 --> 01:27:33,510
 

3313
01:27:30,090 --> 01:27:37,310
 do that through training on the Koppers

3314
01:27:33,500 --> 01:27:37,310
 

3315
01:27:33,510 --> 01:27:41,450
 to learn the representation of of the

3316
01:27:37,300 --> 01:27:41,450
 

3317
01:27:37,310 --> 01:27:44,160
 sentences in the text corpus then we can

3318
01:27:41,440 --> 01:27:44,160
 

3319
01:27:41,450 --> 01:27:46,830
 we can fine-tune such representation

3320
01:27:44,150 --> 01:27:46,830
 

3321
01:27:44,160 --> 01:27:49,860
 from the deeper pre-trained layers to

3322
01:27:46,820 --> 01:27:49,860
 

3323
01:27:46,830 --> 01:27:53,880
 are to solve some downstream RP tasks so

3324
01:27:49,850 --> 01:27:53,880
 

3325
01:27:49,860 --> 01:27:58,050
 this is what the pre-training can be can

3326
01:27:53,870 --> 01:27:58,050
 

3327
01:27:53,880 --> 01:28:00,750
 work in RP so like in this time in this

3328
01:27:58,040 --> 01:28:00,750
 

3329
01:27:58,050 --> 01:28:01,710
 case we can add just one or more upper

3330
01:28:00,740 --> 01:28:01,710
 

3331
01:28:00,750 --> 01:28:05,460
 layers for each new

3332
01:28:01,700 --> 01:28:05,460
 

3333
01:28:01,710 --> 01:28:07,739
 asked to do the to help to transform the

3334
01:28:05,450 --> 01:28:07,739
 

3335
01:28:05,460 --> 01:28:11,670
 pre-trained lanky representation into

3336
01:28:07,729 --> 01:28:11,670
 

3337
01:28:07,739 --> 01:28:14,100
 the output of a specific task so like in

3338
01:28:11,660 --> 01:28:14,100
 

3339
01:28:11,670 --> 01:28:17,520
 this example which is the like probably

3340
01:28:14,090 --> 01:28:17,520
 

3341
01:28:14,100 --> 01:28:20,280
 the simplest case we can use the pre

3342
01:28:17,510 --> 01:28:20,280
 

3343
01:28:17,520 --> 01:28:23,910
 trend what embedding like work to back a

3344
01:28:20,270 --> 01:28:23,910
 

3345
01:28:20,280 --> 01:28:27,090
 graph or first hacks to obtain the token

3346
01:28:23,900 --> 01:28:27,090
 

3347
01:28:23,910 --> 01:28:28,980
 presentation and then if we want to

3348
01:28:27,080 --> 01:28:28,980
 

3349
01:28:27,090 --> 01:28:31,230
 obtain the Repton for the entire

3350
01:28:28,970 --> 01:28:31,230
 

3351
01:28:28,980 --> 01:28:34,530
 language we can simply sum it up right

3352
01:28:31,220 --> 01:28:34,530
 

3353
01:28:31,230 --> 01:28:38,219
 however this is not the sequential

3354
01:28:34,520 --> 01:28:38,219
 

3355
01:28:34,530 --> 01:28:39,900
 information entirely and how to encode

3356
01:28:38,209 --> 01:28:39,900
 

3357
01:28:38,219 --> 01:28:42,960
 the sequential information to have more

3358
01:28:39,890 --> 01:28:42,960
 

3359
01:28:39,900 --> 01:28:45,290
 context so like a simple thought is to

3360
01:28:42,950 --> 01:28:45,290
 

3361
01:28:42,960 --> 01:28:47,960
 use the language model right so which is

3362
01:28:45,280 --> 01:28:47,960
 

3363
01:28:45,290 --> 01:28:51,660
 factorized based on the auto regression

3364
01:28:47,950 --> 01:28:51,660
 

3365
01:28:47,960 --> 01:28:53,280
 so gbg exactly does this by using the

3366
01:28:51,650 --> 01:28:53,280
 

3367
01:28:51,660 --> 01:28:55,830
 transformer decoder based on the

3368
01:28:53,270 --> 01:28:55,830
 

3369
01:28:53,280 --> 01:28:59,370
 multi-head attention and it pre-trained

3370
01:28:55,820 --> 01:28:59,370
 

3371
01:28:55,830 --> 01:29:04,080
 language model around the full dense

3372
01:28:59,360 --> 01:29:04,080
 

3373
01:28:59,370 --> 01:29:06,630
 documents with cow box and twelve hats

3374
01:29:04,070 --> 01:29:06,630
 

3375
01:29:04,080 --> 01:29:08,880
 so each block is a transform or encoder

3376
01:29:06,620 --> 01:29:08,880
 

3377
01:29:06,630 --> 01:29:11,190
 block that we have covered before but

3378
01:29:08,870 --> 01:29:11,190
 

3379
01:29:08,880 --> 01:29:13,469
 different from so there's one thing that

3380
01:29:11,180 --> 01:29:13,469
 

3381
01:29:11,190 --> 01:29:15,630
 we want we can highlight which is that

3382
01:29:13,459 --> 01:29:15,630
 

3383
01:29:13,469 --> 01:29:17,969
 gbt typically trans on the full-length

3384
01:29:15,620 --> 01:29:17,969
 

3385
01:29:15,630 --> 01:29:20,820
 documents and this is very different

3386
01:29:17,959 --> 01:29:20,820
 

3387
01:29:17,969 --> 01:29:23,640
 from Burt Burt only pre trans our

3388
01:29:20,810 --> 01:29:23,640
 

3389
01:29:20,820 --> 01:29:25,469
 sentences or like a pair of sentences so

3390
01:29:23,630 --> 01:29:25,469
 

3391
01:29:23,640 --> 01:29:26,880
 this is one difference and it also

3392
01:29:25,459 --> 01:29:26,880
 

3393
01:29:25,469 --> 01:29:31,290
 achieved the state of the other results

3394
01:29:26,870 --> 01:29:31,290
 

3395
01:29:26,880 --> 01:29:33,330
 at that time however this limitation for

3396
01:29:31,280 --> 01:29:33,330
 

3397
01:29:31,290 --> 01:29:35,969
 the language model representation so

3398
01:29:33,320 --> 01:29:35,969
 

3399
01:29:33,330 --> 01:29:39,090
 like if we want to obtain so like let's

3400
01:29:35,959 --> 01:29:39,090
 

3401
01:29:35,969 --> 01:29:41,489
 look at the examples at the bottom the

3402
01:29:39,080 --> 01:29:41,489
 

3403
01:29:39,090 --> 01:29:45,510
 highlighted word Bank how do we obtain

3404
01:29:41,479 --> 01:29:45,510
 

3405
01:29:41,489 --> 01:29:48,360
 the token station for Bank if we use

3406
01:29:45,500 --> 01:29:48,360
 

3407
01:29:45,510 --> 01:29:51,390
 language order and we go one direction

3408
01:29:48,350 --> 01:29:51,390
 

3409
01:29:48,360 --> 01:29:54,210
 or it will only look at the previous

3410
01:29:51,380 --> 01:29:54,210
 

3411
01:29:51,390 --> 01:29:57,120
 tokens to understand the context to up

3412
01:29:54,200 --> 01:29:57,120
 

3413
01:29:54,210 --> 01:30:00,540
 to in order to obtain the representation

3414
01:29:57,110 --> 01:30:00,540
 

3415
01:29:57,120 --> 01:30:04,920
 for this token Bank however if we ignore

3416
01:30:00,530 --> 01:30:04,920
 

3417
01:30:00,540 --> 01:30:08,910
 the context which is after the word Bank

3418
01:30:04,910 --> 01:30:08,910
 

3419
01:30:04,920 --> 01:30:10,380
 it actually misses a lot of useful

3420
01:30:08,900 --> 01:30:10,380
 

3421
01:30:08,910 --> 01:30:12,780
 information too

3422
01:30:10,370 --> 01:30:12,780
 

3423
01:30:10,380 --> 01:30:15,930
 10 a more actual representation for the

3424
01:30:12,770 --> 01:30:15,930
 

3425
01:30:12,780 --> 01:30:18,240
 World Bank in this context so that's why

3426
01:30:15,920 --> 01:30:18,240
 

3427
01:30:15,930 --> 01:30:22,050
 in order to understand or represent

3428
01:30:18,230 --> 01:30:22,050
 

3429
01:30:18,240 --> 01:30:25,890
 language bi-directional context will be

3430
01:30:22,040 --> 01:30:25,890
 

3431
01:30:22,050 --> 01:30:28,680
 very useful so this is what our birth

3432
01:30:25,880 --> 01:30:28,680
 

3433
01:30:25,890 --> 01:30:31,500
 does it is based on a bidirectional

3434
01:30:28,670 --> 01:30:31,500
 

3435
01:30:28,680 --> 01:30:33,990
 transform encoder to represent the

3436
01:30:31,490 --> 01:30:33,990
 

3437
01:30:31,500 --> 01:30:36,480
 language and it's a very big transform

3438
01:30:33,980 --> 01:30:36,480
 

3439
01:30:33,990 --> 01:30:39,390
 encoder that is pre trained and books

3440
01:30:36,470 --> 01:30:39,390
 

3441
01:30:36,480 --> 01:30:41,880
 and Wikipedia which have more than three

3442
01:30:39,380 --> 01:30:41,880
 

3443
01:30:39,390 --> 01:30:44,220
 billion words and you can see that the

3444
01:30:41,870 --> 01:30:44,220
 

3445
01:30:41,880 --> 01:30:48,600
 planners they have two versions so the

3446
01:30:44,210 --> 01:30:48,600
 

3447
01:30:44,220 --> 01:30:53,460
 larger version have like 340 megabyte

3448
01:30:48,590 --> 01:30:53,460
 

3449
01:30:48,600 --> 01:30:56,160
 parameters so now we start bidirectional

3450
01:30:53,450 --> 01:30:56,160
 

3451
01:30:53,460 --> 01:30:58,800
 encoding how do we really represent the

3452
01:30:56,150 --> 01:30:58,800
 

3453
01:30:56,160 --> 01:31:01,200
 input language actually as I just

3454
01:30:58,790 --> 01:31:01,200
 

3455
01:30:58,800 --> 01:31:04,470
 mentioned bird is pre trained our son

3456
01:31:01,190 --> 01:31:04,470
 

3457
01:31:01,200 --> 01:31:07,860
 our one sentence or a pair of sentence

3458
01:31:04,460 --> 01:31:07,860
 

3459
01:31:04,470 --> 01:31:10,020
 so let's look at a pair of tennis for a

3460
01:31:07,850 --> 01:31:10,020
 

3461
01:31:07,860 --> 01:31:13,500
 pair of sandals first of all we optic we

3462
01:31:10,010 --> 01:31:13,500
 

3463
01:31:10,020 --> 01:31:15,780
 we up try to obtain the token bedding

3464
01:31:13,490 --> 01:31:15,780
 

3465
01:31:13,500 --> 01:31:18,840
 for each word in the two sentences and

3466
01:31:15,770 --> 01:31:18,840
 

3467
01:31:15,780 --> 01:31:22,470
 we place a special token called step to

3468
01:31:18,830 --> 01:31:22,470
 

3469
01:31:18,840 --> 01:31:26,070
 separate these two sentences in in such

3470
01:31:22,460 --> 01:31:26,070
 

3471
01:31:22,470 --> 01:31:28,560
 a pair and we also add the segment

3472
01:31:26,060 --> 01:31:28,560
 

3473
01:31:26,070 --> 01:31:31,170
 embedding which is the same for the same

3474
01:31:28,550 --> 01:31:31,170
 

3475
01:31:28,560 --> 01:31:32,340
 for the same sentence so in this case

3476
01:31:31,160 --> 01:31:32,340
 

3477
01:31:31,170 --> 01:31:35,490
 you can see that in two different

3478
01:31:32,330 --> 01:31:35,490
 

3479
01:31:32,340 --> 01:31:37,890
 sentence we have two different segments

3480
01:31:35,480 --> 01:31:37,890
 

3481
01:31:35,490 --> 01:31:40,860
 and beddings to be learned in order to

3482
01:31:37,880 --> 01:31:40,860
 

3483
01:31:37,890 --> 01:31:43,470
 district distinguish the two sentences

3484
01:31:40,850 --> 01:31:43,470
 

3485
01:31:40,860 --> 01:31:45,750
 in a pair and also we have a beginning

3486
01:31:43,460 --> 01:31:45,750
 

3487
01:31:43,470 --> 01:31:48,120
 of sentence at Hogan special token in

3488
01:31:45,740 --> 01:31:48,120
 

3489
01:31:45,750 --> 01:31:51,420
 order to try to represent the entire

3490
01:31:48,110 --> 01:31:51,420
 

3491
01:31:48,120 --> 01:31:54,270
 sentence or in the in Hassanein spare to

3492
01:31:51,410 --> 01:31:54,270
 

3493
01:31:51,420 --> 01:31:59,400
 for decoding to the downstream repeat

3494
01:31:54,260 --> 01:31:59,400
 

3495
01:31:54,270 --> 01:32:01,800
 asks so if we have only one sentence

3496
01:31:59,390 --> 01:32:01,800
 

3497
01:31:59,400 --> 01:32:04,470
 actually we can just ignore the second

3498
01:32:01,790 --> 01:32:04,470
 

3499
01:32:01,800 --> 01:32:06,420
 sentence to mean that the one sentence

3500
01:32:04,460 --> 01:32:06,420
 

3501
01:32:04,470 --> 01:32:09,750
 are obtained is just a subset of

3502
01:32:06,410 --> 01:32:09,750
 

3503
01:32:06,420 --> 01:32:12,150
 apparels and his reputation so then we

3504
01:32:09,740 --> 01:32:12,150
 

3505
01:32:09,750 --> 01:32:14,250
 have two different tasks to pre-trained

3506
01:32:12,140 --> 01:32:14,250
 

3507
01:32:12,150 --> 01:32:17,050
 such a port model so why is the

3508
01:32:14,240 --> 01:32:17,050
 

3509
01:32:14,250 --> 01:32:20,710
 masculine key model well we

3510
01:32:17,040 --> 01:32:20,710
 

3511
01:32:17,050 --> 01:32:23,020
 had both of the contacts of the word to

3512
01:32:20,700 --> 01:32:23,020
 

3513
01:32:20,710 --> 01:32:24,550
 be predicted so you can see that it's

3514
01:32:23,010 --> 01:32:24,550
 

3515
01:32:23,020 --> 01:32:27,520
 very different from the language model

3516
01:32:24,540 --> 01:32:27,520
 

3517
01:32:24,550 --> 01:32:29,740
 that we only look at only the tokens

3518
01:32:27,510 --> 01:32:29,740
 

3519
01:32:27,520 --> 01:32:33,790
 from the previous time stamps so in

3520
01:32:29,730 --> 01:32:33,790
 

3521
01:32:29,740 --> 01:32:37,390
 order to that we randomly mask 15% of

3522
01:32:33,780 --> 01:32:37,390
 

3523
01:32:33,790 --> 01:32:40,930
 all the tokens to be predicted and we

3524
01:32:37,380 --> 01:32:40,930
 

3525
01:32:37,390 --> 01:32:43,420
 can and there are four Eddie

3526
01:32:40,920 --> 01:32:43,420
 

3527
01:32:40,930 --> 01:32:45,910
 80% of them we just replace it with a

3528
01:32:43,410 --> 01:32:45,910
 

3529
01:32:43,420 --> 01:32:50,350
 special token called mask so means that

3530
01:32:45,900 --> 01:32:50,350
 

3531
01:32:45,910 --> 01:32:52,060
 we used the input sequences like the

3532
01:32:50,340 --> 01:32:52,060
 

3533
01:32:50,350 --> 01:32:54,630
 contest information together with the

3534
01:32:52,050 --> 01:32:54,630
 

3535
01:32:52,060 --> 01:33:00,430
 mask which does not have any meaning to

3536
01:32:54,620 --> 01:33:00,430
 

3537
01:32:54,630 --> 01:33:02,200
 predict the mask token so it forces the

3538
01:33:00,420 --> 01:33:02,200
 

3539
01:33:00,430 --> 01:33:04,390
 prediction to use the contact

3540
01:33:02,190 --> 01:33:04,390
 

3541
01:33:02,200 --> 01:33:07,900
 information from the from the two

3542
01:33:04,380 --> 01:33:07,900
 

3543
01:33:04,390 --> 01:33:10,120
 directions in this case and in order to

3544
01:33:07,890 --> 01:33:10,120
 

3545
01:33:07,900 --> 01:33:14,170
 help from the model to past what the

3546
01:33:10,110 --> 01:33:14,170
 

3547
01:33:10,120 --> 01:33:17,200
 correct are the correct prediction for

3548
01:33:14,160 --> 01:33:17,200
 

3549
01:33:14,170 --> 01:33:19,930
 10% of them it will still do all cheat

3550
01:33:17,190 --> 01:33:19,930
 

3551
01:33:17,200 --> 01:33:23,680
 by using the the true answer which is

3552
01:33:19,920 --> 01:33:23,680
 

3553
01:33:19,930 --> 01:33:25,480
 the actual token - so this is like

3554
01:33:23,670 --> 01:33:25,480
 

3555
01:33:23,680 --> 01:33:27,850
 cheating right we use the token to

3556
01:33:25,470 --> 01:33:27,850
 

3557
01:33:25,480 --> 01:33:30,130
 predict the token so but it only takes a

3558
01:33:27,840 --> 01:33:30,130
 

3559
01:33:27,850 --> 01:33:32,200
 10% of time in order to bias towards the

3560
01:33:30,120 --> 01:33:32,200
 

3561
01:33:30,130 --> 01:33:34,870
 correct prediction no thought for the

3562
01:33:32,190 --> 01:33:34,870
 

3563
01:33:32,200 --> 01:33:37,540
 rest 10% of time we'll just replace with

3564
01:33:34,860 --> 01:33:37,540
 

3565
01:33:34,870 --> 01:33:42,520
 the random token to add some noise like

3566
01:33:37,530 --> 01:33:42,520
 

3567
01:33:37,540 --> 01:33:44,980
 a regularization so another task is to

3568
01:33:42,510 --> 01:33:44,980
 

3569
01:33:42,520 --> 01:33:48,490
 try to learn the logical coherence

3570
01:33:44,970 --> 01:33:48,490
 

3571
01:33:44,980 --> 01:33:52,270
 between the sentences of a pair so like

3572
01:33:48,480 --> 01:33:52,270
 

3573
01:33:48,490 --> 01:33:54,430
 in 50 percent of time we just use we

3574
01:33:52,260 --> 01:33:54,430
 

3575
01:33:52,270 --> 01:33:57,190
 just replaced the correct and xn has to

3576
01:33:54,420 --> 01:33:57,190
 

3577
01:33:54,430 --> 01:34:00,130
 appear random sentence and give such

3578
01:33:57,180 --> 01:34:00,130
 

3579
01:33:57,190 --> 01:34:02,640
 pair as a label called a negative then

3580
01:34:00,120 --> 01:34:02,640
 

3581
01:34:00,130 --> 01:34:06,370
 for the other half which are preserved a

3582
01:34:02,630 --> 01:34:06,370
 

3583
01:34:02,640 --> 01:34:09,580
 sequential pair of sentences to provide

3584
01:34:06,360 --> 01:34:09,580
 

3585
01:34:06,370 --> 01:34:14,020
 and label it as true so this is like we

3586
01:34:09,570 --> 01:34:14,020
 

3587
01:34:09,580 --> 01:34:16,960
 can so it means that we have we can try

3588
01:34:14,010 --> 01:34:16,960
 

3589
01:34:14,020 --> 01:34:21,160
 to learn the relationship between a pair

3590
01:34:16,950 --> 01:34:21,160
 

3591
01:34:16,960 --> 01:34:22,930
 of sentences with 30 levels and in in

3592
01:34:21,150 --> 01:34:22,930
 

3593
01:34:21,160 --> 01:34:25,720
 this time you can see that both of the

3594
01:34:22,920 --> 01:34:25,720
 

3595
01:34:22,930 --> 01:34:29,500
 tasks they are purely from the

3596
01:34:25,710 --> 01:34:29,500
 

3597
01:34:25,720 --> 01:34:31,310
 unsupervised large corpus so although in

3598
01:34:29,490 --> 01:34:31,310
 

3599
01:34:29,500 --> 01:34:34,550
 the in this of

3600
01:34:31,300 --> 01:34:34,550
 

3601
01:34:31,310 --> 01:34:36,530
 for the math longer model we do have the

3602
01:34:34,540 --> 01:34:36,530
 

3603
01:34:34,550 --> 01:34:38,930
 conscience for the predict program but

3604
01:34:36,520 --> 01:34:38,930
 

3605
01:34:36,530 --> 01:34:41,300
 this is from the corpus right so we

3606
01:34:38,920 --> 01:34:41,300
 

3607
01:34:38,930 --> 01:34:43,130
 don't need to manually label it and also

3608
01:34:41,290 --> 01:34:43,130
 

3609
01:34:41,300 --> 01:34:45,980
 for the next sentence prediction we also

3610
01:34:43,120 --> 01:34:45,980
 

3611
01:34:43,130 --> 01:34:48,650
 make use of the huge amount of corpus

3612
01:34:45,970 --> 01:34:48,650
 

3613
01:34:45,980 --> 01:34:50,630
 like whether a two sentences are a pair

3614
01:34:48,640 --> 01:34:50,630
 

3615
01:34:48,650 --> 01:34:53,690
 or not or like whether they are

3616
01:34:50,620 --> 01:34:53,690
 

3617
01:34:50,630 --> 01:34:55,580
 sequential or not so this we don't need

3618
01:34:53,680 --> 01:34:55,580
 

3619
01:34:53,690 --> 01:34:59,720
 for in Auto achieve this we don't need

3620
01:34:55,570 --> 01:34:59,720
 

3621
01:34:55,580 --> 01:35:02,090
 to manually label such two sentences to

3622
01:34:59,710 --> 01:35:02,090
 

3623
01:34:59,720 --> 01:35:04,400
 be whether they are a pair or not so

3624
01:35:02,080 --> 01:35:04,400
 

3625
01:35:02,090 --> 01:35:07,730
 this really leverages the power of the

3626
01:35:04,390 --> 01:35:07,730
 

3627
01:35:04,400 --> 01:35:10,640
 unsupervised corpus without any leveling

3628
01:35:07,720 --> 01:35:10,640
 

3629
01:35:07,730 --> 01:35:13,250
 cost so then once we have such

3630
01:35:10,630 --> 01:35:13,250
 

3631
01:35:10,640 --> 01:35:15,350
 pre-trained model then we can we do

3632
01:35:13,240 --> 01:35:15,350
 

3633
01:35:13,250 --> 01:35:18,800
 obtain the representation for each token

3634
01:35:15,340 --> 01:35:18,800
 

3635
01:35:15,350 --> 01:35:21,380
 of the transforming order and we can

3636
01:35:18,790 --> 01:35:21,380
 

3637
01:35:18,800 --> 01:35:24,410
 also fine tuned to different downstream

3638
01:35:21,370 --> 01:35:24,410
 

3639
01:35:21,380 --> 01:35:27,350
 tasks so here are the details so for

3640
01:35:24,400 --> 01:35:27,350
 

3641
01:35:24,410 --> 01:35:30,230
 sending second classification we can use

3642
01:35:27,340 --> 01:35:30,230
 

3643
01:35:27,350 --> 01:35:32,120
 the pre the very first special token

3644
01:35:30,220 --> 01:35:32,120
 

3645
01:35:30,230 --> 01:35:34,030
 which is called the beginning of signal

3646
01:35:32,110 --> 01:35:34,030
 

3647
01:35:32,120 --> 01:35:37,130
 sequence because it applies the

3648
01:35:34,020 --> 01:35:37,130
 

3649
01:35:34,030 --> 01:35:40,850
 attention over every token of every time

3650
01:35:37,120 --> 01:35:40,850
 

3651
01:35:37,130 --> 01:35:43,010
 steps so it has the potential to - to

3652
01:35:40,840 --> 01:35:43,010
 

3653
01:35:40,850 --> 01:35:44,900
 encode all the info information from the

3654
01:35:43,000 --> 01:35:44,900
 

3655
01:35:43,010 --> 01:35:49,130
 inputs and we just use that special

3656
01:35:44,890 --> 01:35:49,130
 

3657
01:35:44,900 --> 01:35:52,580
 token to add to a pen tool to append

3658
01:35:49,120 --> 01:35:52,580
 

3659
01:35:49,130 --> 01:35:55,580
 another dense layer to transform it into

3660
01:35:52,570 --> 01:35:55,580
 

3661
01:35:52,580 --> 01:35:58,250
 the categories to perform the sentence

3662
01:35:55,570 --> 01:35:58,250
 

3663
01:35:55,580 --> 01:36:01,220
 classification and in this case we can

3664
01:35:58,240 --> 01:36:01,220
 

3665
01:35:58,250 --> 01:36:03,200
 just train the dense area from scratch

3666
01:36:01,210 --> 01:36:03,200
 

3667
01:36:01,220 --> 01:36:06,350
 or in sometimes we can even like

3668
01:36:03,190 --> 01:36:06,350
 

3669
01:36:03,200 --> 01:36:09,140
 fine-tune the weights in that in a pre

3670
01:36:06,340 --> 01:36:09,140
 

3671
01:36:06,350 --> 01:36:12,020
 trained part this is also I mean both

3672
01:36:09,130 --> 01:36:12,020
 

3673
01:36:09,140 --> 01:36:14,300
 ways are possible so then in them entity

3674
01:36:12,010 --> 01:36:14,300
 

3675
01:36:12,020 --> 01:36:17,330
 recognition we want to us predict the

3676
01:36:14,290 --> 01:36:17,330
 

3677
01:36:14,300 --> 01:36:18,860
 label for each word in a sentence to be

3678
01:36:17,320 --> 01:36:18,860
 

3679
01:36:17,330 --> 01:36:21,710
 like the beginning of what energy or

3680
01:36:18,850 --> 01:36:21,710
 

3681
01:36:18,860 --> 01:36:23,870
 another energy like location person or

3682
01:36:21,700 --> 01:36:23,870
 

3683
01:36:21,710 --> 01:36:25,910
 something right so in this case we can

3684
01:36:23,860 --> 01:36:25,910
 

3685
01:36:23,870 --> 01:36:27,950
 we can retrieve the feature

3686
01:36:25,900 --> 01:36:27,950
 

3687
01:36:25,910 --> 01:36:30,530
 representation from the pre train birth

3688
01:36:27,940 --> 01:36:30,530
 

3689
01:36:27,950 --> 01:36:33,800
 for each token then we can also just

3690
01:36:30,520 --> 01:36:33,800
 

3691
01:36:30,530 --> 01:36:37,610
 transform it into with the tenth layer

3692
01:36:33,790 --> 01:36:37,610
 

3693
01:36:33,800 --> 01:36:40,610
 to the energy type for question

3694
01:36:37,600 --> 01:36:40,610
 

3695
01:36:37,610 --> 01:36:43,360
 answering we can so question answering

3696
01:36:40,600 --> 01:36:43,360
 

3697
01:36:40,610 --> 01:36:46,480
 is that we use the question two

3698
01:36:43,350 --> 01:36:46,480
 

3699
01:36:43,360 --> 01:36:48,820
 so we want to output the beginning of

3700
01:36:46,470 --> 01:36:48,820
 

3701
01:36:46,480 --> 01:36:51,400
 the answer and end of the answer from by

3702
01:36:48,810 --> 01:36:51,400
 

3703
01:36:48,820 --> 01:36:55,180
 marking the beginning and end position

3704
01:36:51,390 --> 01:36:55,180
 

3705
01:36:51,400 --> 01:36:57,790
 of the story so in this case we can we

3706
01:36:55,170 --> 01:36:57,790
 

3707
01:36:55,180 --> 01:37:01,450
 can try to predict the the beginning of

3708
01:36:57,780 --> 01:37:01,450
 

3709
01:36:57,790 --> 01:37:04,660
 the answer by marking the each of the

3710
01:37:01,440 --> 01:37:04,660
 

3711
01:37:01,450 --> 01:37:08,680
 location position of the story and we

3712
01:37:04,650 --> 01:37:08,680
 

3713
01:37:04,660 --> 01:37:11,080
 can use a printer s which is as here to

3714
01:37:08,670 --> 01:37:11,080
 

3715
01:37:08,680 --> 01:37:14,650
 be the printer and perform the dot

3716
01:37:11,070 --> 01:37:14,650
 

3717
01:37:11,080 --> 01:37:17,560
 product between this printer and all the

3718
01:37:14,640 --> 01:37:17,560
 

3719
01:37:14,650 --> 01:37:20,530
 feature presentation from pert for the

3720
01:37:17,550 --> 01:37:20,530
 

3721
01:37:17,560 --> 01:37:23,200
 story and then we can perform softmax to

3722
01:37:20,520 --> 01:37:23,200
 

3723
01:37:20,530 --> 01:37:26,770
 get the highest together token with the

3724
01:37:23,190 --> 01:37:26,770
 

3725
01:37:23,200 --> 01:37:28,240
 highest likelihood to be the beginning

3726
01:37:26,760 --> 01:37:28,240
 

3727
01:37:26,770 --> 01:37:30,430
 of the answer or the end of the answer

3728
01:37:28,230 --> 01:37:30,430
 

3729
01:37:28,240 --> 01:37:35,140
 so this is how we can find him to a

3730
01:37:30,420 --> 01:37:35,140
 

3731
01:37:30,430 --> 01:37:37,870
 Quincy answering so then gbt tool gets

3732
01:37:35,130 --> 01:37:37,870
 

3733
01:37:35,140 --> 01:37:43,710
 even larger so here you can see that it

3734
01:37:37,860 --> 01:37:43,710
 

3735
01:37:37,870 --> 01:37:48,040
 has stacked 48 + 2 and which result in

3736
01:37:43,700 --> 01:37:48,040
 

3737
01:37:43,710 --> 01:37:50,770
 1.5 billion printers about 4 gb d - it's

3738
01:37:48,030 --> 01:37:50,770
 

3739
01:37:48,040 --> 01:37:54,130
 like a lot it's larger than even than

3740
01:37:50,760 --> 01:37:54,130
 

3741
01:37:50,770 --> 01:37:56,530
 the gbg1 so it's but different from

3742
01:37:54,120 --> 01:37:56,530
 

3743
01:37:54,130 --> 01:38:00,100
 birth it is a it only used at the coda

3744
01:37:56,520 --> 01:38:00,100
 

3745
01:37:56,530 --> 01:38:06,190
 part of transformer so here note about

3746
01:38:00,090 --> 01:38:06,190
 

3747
01:38:00,100 --> 01:38:10,690
 the GPT to pre trans the like 8 billion

3748
01:38:06,180 --> 01:38:10,690
 

3749
01:38:06,190 --> 01:38:14,560
 web pages and after training on such a

3750
01:38:10,680 --> 01:38:14,560
 

3751
01:38:10,690 --> 01:38:16,210
 large corpus when they find that they

3752
01:38:14,550 --> 01:38:16,210
 

3753
01:38:14,560 --> 01:38:19,600
 don't need to even need to fine tune

3754
01:38:16,200 --> 01:38:19,600
 

3755
01:38:16,210 --> 01:38:21,790
 towards any specific language modeling

3756
01:38:19,590 --> 01:38:21,790
 

3757
01:38:19,600 --> 01:38:24,610
 data set to perform the language model

3758
01:38:21,780 --> 01:38:24,610
 

3759
01:38:21,790 --> 01:38:26,410
 tasks there so means that it achieved a

3760
01:38:24,600 --> 01:38:26,410
 

3761
01:38:24,610 --> 01:38:28,300
 zero short learning you don't need to

3762
01:38:26,400 --> 01:38:28,300
 

3763
01:38:26,410 --> 01:38:32,140
 find your animal because the the pre

3764
01:38:28,290 --> 01:38:32,140
 

3765
01:38:28,300 --> 01:38:35,430
 trend result is already good enough so

3766
01:38:32,130 --> 01:38:35,430
 

3767
01:38:32,140 --> 01:38:38,590
 here is the demo for CPD tool because

3768
01:38:35,420 --> 01:38:38,590
 

3769
01:38:35,430 --> 01:38:42,070
 like previously some people they argue

3770
01:38:38,580 --> 01:38:42,070
 

3771
01:38:38,590 --> 01:38:44,920
 that it is the most dangerous oh there's

3772
01:38:42,060 --> 01:38:44,920
 

3773
01:38:42,070 --> 01:38:47,200
 no projection ok ok it's fine I can just

3774
01:38:44,910 --> 01:38:47,200
 

3775
01:38:44,920 --> 01:38:51,150
 skip this then but what if you had time

3776
01:38:47,190 --> 01:38:51,150
 

3777
01:38:47,200 --> 01:38:53,440
 we can I can still do that door we can

3778
01:38:51,140 --> 01:38:53,440
 

3779
01:38:51,150 --> 01:38:54,880
 we can I can do it let them all either

3780
01:38:53,430 --> 01:38:54,880
 

3781
01:38:53,440 --> 01:38:55,750
 if you are interesting and just come to

3782
01:38:54,870 --> 01:38:55,750
 

3783
01:38:54,880 --> 01:38:58,820
 the pool

3784
01:38:55,740 --> 01:38:58,820
 

3785
01:38:55,750 --> 01:39:03,260
 so but this is like a back-up plan right

3786
01:38:58,810 --> 01:39:03,260
 

3787
01:38:58,820 --> 01:39:05,780
 so once we provide those inputs the the

3788
01:39:03,250 --> 01:39:05,780
 

3789
01:39:03,260 --> 01:39:09,110
 prefix like every human tenants pain is

3790
01:39:05,770 --> 01:39:09,110
 

3791
01:39:05,780 --> 01:39:13,430
 even shorter than that of a codfish then

3792
01:39:09,100 --> 01:39:13,430
 

3793
01:39:09,110 --> 01:39:17,390
 you can see that the GPT tool can keep

3794
01:39:13,420 --> 01:39:17,390
 

3795
01:39:13,430 --> 01:39:21,800
 generating the the the word right to

3796
01:39:17,380 --> 01:39:21,800
 

3797
01:39:17,390 --> 01:39:24,380
 form to keep composing the the text and

3798
01:39:21,790 --> 01:39:24,380
 

3799
01:39:21,800 --> 01:39:26,480
 it is partially readable right you can

3800
01:39:24,370 --> 01:39:26,480
 

3801
01:39:24,380 --> 01:39:29,120
 see that it's partially readable so

3802
01:39:26,470 --> 01:39:29,120
 

3803
01:39:26,480 --> 01:39:34,280
 chibi Tito is pretty powerful in terms

3804
01:39:29,110 --> 01:39:34,280
 

3805
01:39:29,120 --> 01:39:36,350
 of the language model so in the end we

3806
01:39:34,270 --> 01:39:36,350
 

3807
01:39:34,280 --> 01:39:39,260
 want to we still want to highlight the

3808
01:39:36,340 --> 01:39:39,260
 

3809
01:39:36,350 --> 01:39:41,480
 challenges for such one start powerful

3810
01:39:39,250 --> 01:39:41,480
 

3811
01:39:39,260 --> 01:39:44,090
 pre-trained models based on transformer

3812
01:39:41,470 --> 01:39:44,090
 

3813
01:39:41,480 --> 01:39:46,390
 because as we just mentioned they are

3814
01:39:44,080 --> 01:39:46,390
 

3815
01:39:44,090 --> 01:39:49,370
 they have a lot of the parameters which

3816
01:39:46,380 --> 01:39:49,370
 

3817
01:39:46,390 --> 01:39:51,740
 make it very hard to be deployed and

3818
01:39:49,360 --> 01:39:51,740
 

3819
01:39:49,370 --> 01:39:54,440
 certain resource constrained devices

3820
01:39:51,730 --> 01:39:54,440
 

3821
01:39:51,740 --> 01:39:56,690
 like mobile devices or edge devices so

3822
01:39:54,430 --> 01:39:56,690
 

3823
01:39:54,440 --> 01:39:59,090
 so recently there are a lot of work to

3824
01:39:56,680 --> 01:39:59,090
 

3825
01:39:56,690 --> 01:40:01,610
 try to make the multi-head attention or

3826
01:39:59,080 --> 01:40:01,610
 

3827
01:39:59,090 --> 01:40:05,540
 the generation to be more structured

3828
01:40:01,600 --> 01:40:05,540
 

3829
01:40:01,610 --> 01:40:09,800
 sparser and even more light-weighted so

3830
01:40:05,530 --> 01:40:09,800
 

3831
01:40:05,540 --> 01:40:12,200
 here are a few approaches to that so the

3832
01:40:09,790 --> 01:40:12,200
 

3833
01:40:09,800 --> 01:40:14,870
 so record at the the heavy

3834
01:40:12,190 --> 01:40:14,870
 

3835
01:40:12,200 --> 01:40:17,330
 parameterization come from the linear

3836
01:40:14,860 --> 01:40:17,330
 

3837
01:40:14,870 --> 01:40:20,450
 transformation of the key query and

3838
01:40:17,320 --> 01:40:20,450
 

3839
01:40:17,330 --> 01:40:23,930
 value in the market attention so here so

3840
01:40:20,440 --> 01:40:23,930
 

3841
01:40:20,450 --> 01:40:28,790
 we use a tense layer heavily in the in

3842
01:40:23,920 --> 01:40:28,790
 

3843
01:40:23,930 --> 01:40:31,540
 transformer architecture so what what if

3844
01:40:28,780 --> 01:40:31,540
 

3845
01:40:28,790 --> 01:40:34,010
 we can just use a more light weighted

3846
01:40:31,530 --> 01:40:34,010
 

3847
01:40:31,540 --> 01:40:36,320
 version of the fully kinetic layer or

3848
01:40:34,000 --> 01:40:36,320
 

3849
01:40:34,010 --> 01:40:41,180
 the dense layer so one interesting idea

3850
01:40:36,310 --> 01:40:41,180
 

3851
01:40:36,320 --> 01:40:43,190
 is to treat apply the algebra of hyper

3852
01:40:41,170 --> 01:40:43,190
 

3853
01:40:41,180 --> 01:40:46,490
 complex numbers rather than just add

3854
01:40:43,180 --> 01:40:46,490
 

3855
01:40:43,190 --> 01:40:49,220
 real value numbers so that is the code

3856
01:40:46,480 --> 01:40:49,220
 

3857
01:40:46,490 --> 01:40:52,700
 and that will result in a quaternion

3858
01:40:49,210 --> 01:40:52,700
 

3859
01:40:49,220 --> 01:40:55,820
 transformer actually we found that this

3860
01:40:52,690 --> 01:40:55,820
 

3861
01:40:52,700 --> 01:40:59,450
 can save the parameters immediately by

3862
01:40:55,810 --> 01:40:59,450
 

3863
01:40:55,820 --> 01:41:01,490
 up to 75 percent without significant

3864
01:40:59,440 --> 01:41:01,490
 

3865
01:40:59,450 --> 01:41:04,100
 degrading of the performance and here's

3866
01:41:01,480 --> 01:41:04,100
 

3867
01:41:01,490 --> 01:41:05,810
 how we can how we can apply this idea so

3868
01:41:04,090 --> 01:41:05,810
 

3869
01:41:04,100 --> 01:41:07,839
 recall that in court earlier is the for

3870
01:41:05,800 --> 01:41:07,839
 

3871
01:41:05,810 --> 01:41:10,359
 directional hyper compressed number

3872
01:41:07,829 --> 01:41:10,359
 

3873
01:41:07,839 --> 01:41:12,339
 the algebra of the of the

3874
01:41:10,349 --> 01:41:12,339
 

3875
01:41:10,359 --> 01:41:15,909
 hyper-competitive burn which is which is

3876
01:41:12,329 --> 01:41:15,909
 

3877
01:41:12,339 --> 01:41:18,129
 the Hamilton product this is the algebra

3878
01:41:15,899 --> 01:41:18,129
 

3879
01:41:15,909 --> 01:41:19,569
 for performing the multiplication which

3880
01:41:18,119 --> 01:41:19,569
 

3881
01:41:18,129 --> 01:41:23,439
 is a Hamilton product of two

3882
01:41:19,559 --> 01:41:23,439
 

3883
01:41:19,569 --> 01:41:26,219
 quadrillions you can see that when we

3884
01:41:23,429 --> 01:41:26,219
 

3885
01:41:23,439 --> 01:41:28,929
 rewrite in a matrix multiplication way

3886
01:41:26,209 --> 01:41:28,929
 

3887
01:41:26,219 --> 01:41:31,359
 the all the parameters on the left hand

3888
01:41:28,919 --> 01:41:31,359
 

3889
01:41:28,929 --> 01:41:32,199
 block which is the matrix five four by

3890
01:41:31,349 --> 01:41:32,199
 

3891
01:41:31,359 --> 01:41:34,449
 four matrix

3892
01:41:32,189 --> 01:41:34,449
 

3893
01:41:32,199 --> 01:41:37,989
 they are the degree of freedom is only

3894
01:41:34,439 --> 01:41:37,989
 

3895
01:41:34,449 --> 01:41:40,179
 four rather than sixteen but you can see

3896
01:41:37,979 --> 01:41:40,179
 

3897
01:41:37,989 --> 01:41:43,569
 that the permutation of the of the

3898
01:41:40,169 --> 01:41:43,569
 

3899
01:41:40,179 --> 01:41:46,359
 signed W is determinant we determined by

3900
01:41:43,559 --> 01:41:46,359
 

3901
01:41:43,569 --> 01:41:48,099
 the algebra of the Hamilton product so

3902
01:41:46,349 --> 01:41:48,099
 

3903
01:41:46,359 --> 01:41:51,249
 on the right hand side of the figure you

3904
01:41:48,089 --> 01:41:51,249
 

3905
01:41:48,099 --> 01:41:55,289
 can see that if we apply the fully

3906
01:41:51,239 --> 01:41:55,289
 

3907
01:41:51,249 --> 01:41:59,499
 granted transformation by using the

3908
01:41:55,279 --> 01:41:59,499
 

3909
01:41:55,289 --> 01:42:02,019
 multiplication we can just reuse many of

3910
01:41:59,489 --> 01:42:02,019
 

3911
01:41:59,499 --> 01:42:04,599
 the we have we used these four printers

3912
01:42:02,009 --> 01:42:04,599
 

3913
01:42:02,019 --> 01:42:07,539
 right in different permutation and with

3914
01:42:04,589 --> 01:42:07,539
 

3915
01:42:04,599 --> 01:42:09,219
 different signs to formulate the the

3916
01:42:07,529 --> 01:42:09,219
 

3917
01:42:07,539 --> 01:42:11,769
 connections the four by four connections

3918
01:42:09,209 --> 01:42:11,769
 

3919
01:42:09,219 --> 01:42:14,169
 and because of degree of freedom is only

3920
01:42:11,759 --> 01:42:14,169
 

3921
01:42:11,769 --> 01:42:17,589
 four so the printers is saved up to

3922
01:42:14,159 --> 01:42:17,589
 

3923
01:42:14,169 --> 01:42:21,010
 seventy-five percent so this is a very

3924
01:42:17,579 --> 01:42:21,010
 

3925
01:42:17,589 --> 01:42:23,739
 simple idea then recall that the

3926
01:42:21,000 --> 01:42:23,739
 

3927
01:42:21,010 --> 01:42:26,919
 computational cost over last sequence is

3928
01:42:23,729 --> 01:42:26,919
 

3929
01:42:23,739 --> 01:42:30,189
 also very high is because we perform the

3930
01:42:26,909 --> 01:42:30,189
 

3931
01:42:26,919 --> 01:42:32,349
 matrix multiplication in the attention

3932
01:42:30,179 --> 01:42:32,349
 

3933
01:42:30,189 --> 01:42:34,659
 commutation which is the stock max of

3934
01:42:32,339 --> 01:42:34,659
 

3935
01:42:32,349 --> 01:42:37,179
 the modification of query and the

3936
01:42:34,649 --> 01:42:37,179
 

3937
01:42:34,659 --> 01:42:39,669
 transpose of the key then we multiplied

3938
01:42:37,169 --> 01:42:39,669
 

3939
01:42:37,179 --> 01:42:43,689
 by another matrix which is a value so

3940
01:42:39,659 --> 01:42:43,689
 

3941
01:42:39,669 --> 01:42:47,199
 the the matrix come multiplication has a

3942
01:42:43,679 --> 01:42:47,199
 

3943
01:42:43,689 --> 01:42:49,329
 time compacity of which is quadratic in

3944
01:42:47,189 --> 01:42:49,329
 

3945
01:42:47,199 --> 01:42:51,669
 terms of the input sequence or the

3946
01:42:49,319 --> 01:42:51,669
 

3947
01:42:49,329 --> 01:42:54,339
 output sequence so the sequence lens is

3948
01:42:51,659 --> 01:42:54,339
 

3949
01:42:51,669 --> 01:42:56,709
 long longer then the quadratic capacity

3950
01:42:54,329 --> 01:42:56,709
 

3951
01:42:54,339 --> 01:42:59,199
 is really really terrible so that's why

3952
01:42:56,699 --> 01:42:59,199
 

3953
01:42:56,709 --> 01:43:02,669
 you can see that even in per try the

3954
01:42:59,189 --> 01:43:02,669
 

3955
01:42:59,199 --> 01:43:06,249
 predefined sequence length is 512 and

3956
01:43:02,659 --> 01:43:06,249
 

3957
01:43:02,669 --> 01:43:08,409
 but in some problems like the especially

3958
01:43:06,239 --> 01:43:08,409
 

3959
01:43:06,249 --> 01:43:11,619
 for the question-answering when the

3960
01:43:08,399 --> 01:43:11,619
 

3961
01:43:08,409 --> 01:43:15,879
 story can be tens of thousands of tokens

3962
01:43:11,609 --> 01:43:15,879
 

3963
01:43:11,619 --> 01:43:18,129
 then if you apply the burden it's not

3964
01:43:15,869 --> 01:43:18,129
 

3965
01:43:15,879 --> 01:43:20,739
 very powerful because the sequence like

3966
01:43:18,119 --> 01:43:20,739
 

3967
01:43:18,129 --> 01:43:25,300
 tens of tens of thousands right so

3968
01:43:20,729 --> 01:43:25,300
 

3969
01:43:20,739 --> 01:43:28,150
 it's very challenging and that's why we

3970
01:43:25,290 --> 01:43:28,150
 

3971
01:43:25,300 --> 01:43:31,630
 can the like recent works offered some

3972
01:43:28,140 --> 01:43:31,630
 

3973
01:43:28,150 --> 01:43:34,570
 alternatives to tackle the challenge to

3974
01:43:31,620 --> 01:43:34,570
 

3975
01:43:31,630 --> 01:43:37,770
 to represent the long sequences by using

3976
01:43:34,560 --> 01:43:37,770
 

3977
01:43:34,570 --> 01:43:41,650
 transformer so one approach is to just

3978
01:43:37,760 --> 01:43:41,650
 

3979
01:43:37,770 --> 01:43:43,780
 segment this input sequence for instance

3980
01:43:41,640 --> 01:43:43,780
 

3981
01:43:41,650 --> 01:43:46,719
 we can just divide the input sequence

3982
01:43:43,770 --> 01:43:46,719
 

3983
01:43:43,780 --> 01:43:49,660
 into several different segments and then

3984
01:43:46,709 --> 01:43:49,660
 

3985
01:43:46,719 --> 01:43:53,890
 we only trend the transformer encoder or

3986
01:43:49,650 --> 01:43:53,890
 

3987
01:43:49,660 --> 01:43:55,290
 decoder just based on each segment so

3988
01:43:53,880 --> 01:43:55,290
 

3989
01:43:53,890 --> 01:43:59,410
 it's like we train segment by segment

3990
01:43:55,280 --> 01:43:59,410
 

3991
01:43:55,290 --> 01:44:03,160
 then during the inference time we can

3992
01:43:59,400 --> 01:44:03,160
 

3993
01:43:59,410 --> 01:44:06,880
 just output or decode a sequence token

3994
01:44:03,150 --> 01:44:06,880
 

3995
01:44:03,160 --> 01:44:09,390
 by using the current segment then after

3996
01:44:06,870 --> 01:44:09,390
 

3997
01:44:06,880 --> 01:44:12,489
 that we can just move shift one position

3998
01:44:09,380 --> 01:44:12,489
 

3999
01:44:09,390 --> 01:44:16,150
 to make use of the new segment and

4000
01:44:12,479 --> 01:44:16,150
 

4001
01:44:12,489 --> 01:44:18,460
 predict the next token and perform the

4002
01:44:16,140 --> 01:44:18,460
 

4003
01:44:16,150 --> 01:44:19,110
 inference commutation for all from

4004
01:44:18,450 --> 01:44:19,110
 

4005
01:44:18,460 --> 01:44:21,969
 scratch

4006
01:44:19,100 --> 01:44:21,969
 

4007
01:44:19,110 --> 01:44:24,190
 however they are obviously there are two

4008
01:44:21,959 --> 01:44:24,190
 

4009
01:44:21,969 --> 01:44:26,140
 drawbacks so why is that the inference

4010
01:44:24,180 --> 01:44:26,140
 

4011
01:44:24,190 --> 01:44:28,870
 right the inference every time you just

4012
01:44:26,130 --> 01:44:28,870
 

4013
01:44:26,140 --> 01:44:30,850
 do the shift one position you perform

4014
01:44:28,860 --> 01:44:30,850
 

4015
01:44:28,870 --> 01:44:33,430
 all the inference commutation from

4016
01:44:30,840 --> 01:44:33,430
 

4017
01:44:30,850 --> 01:44:36,489
 scratch so that's a lot of time capacity

4018
01:44:33,420 --> 01:44:36,489
 

4019
01:44:33,430 --> 01:44:38,190
 and on the other hand because for doing

4020
01:44:36,479 --> 01:44:38,190
 

4021
01:44:36,489 --> 01:44:42,370
 training we channel with segment the

4022
01:44:38,180 --> 01:44:42,370
 

4023
01:44:38,190 --> 01:44:44,830
 sequence so the these causes the

4024
01:44:42,360 --> 01:44:44,830
 

4025
01:44:42,370 --> 01:44:49,050
 contacts segmentation so mean that we

4026
01:44:44,820 --> 01:44:49,050
 

4027
01:44:44,830 --> 01:44:53,739
 love we lose the contacts information

4028
01:44:49,040 --> 01:44:53,739
 

4029
01:44:49,050 --> 01:44:56,710
 from across the consecutive segments so

4030
01:44:53,729 --> 01:44:56,710
 

4031
01:44:53,739 --> 01:44:59,080
 in order to do that we probably can pour

4032
01:44:56,700 --> 01:44:59,080
 

4033
01:44:56,710 --> 01:45:01,540
 the idea from what we have done for us

4034
01:44:59,070 --> 01:45:01,540
 

4035
01:44:59,080 --> 01:45:04,030
 because record in the early times of on

4036
01:45:01,530 --> 01:45:04,030
 

4037
01:45:01,540 --> 01:45:06,190
 a language model we also have streamed

4038
01:45:04,020 --> 01:45:06,190
 

4039
01:45:04,030 --> 01:45:09,310
 the problems we cannot simply trend

4040
01:45:06,180 --> 01:45:09,310
 

4041
01:45:06,190 --> 01:45:12,280
 along the model we own a very long

4042
01:45:09,300 --> 01:45:12,280
 

4043
01:45:09,310 --> 01:45:15,670
 sequence and instead we use a truncated

4044
01:45:12,270 --> 01:45:15,670
 

4045
01:45:12,280 --> 01:45:19,239
 PPT G to perform the training so this

4046
01:45:15,660 --> 01:45:19,239
 

4047
01:45:15,670 --> 01:45:21,219
 also like we can trick the transformer

4048
01:45:19,229 --> 01:45:21,219
 

4049
01:45:19,239 --> 01:45:25,930
 segment a transformer training as well

4050
01:45:21,209 --> 01:45:25,930
 

4051
01:45:21,219 --> 01:45:28,630
 by just read cash and by caching and

4052
01:45:25,920 --> 01:45:28,630
 

4053
01:45:25,930 --> 01:45:31,750
 reusing the stage from the previous

4054
01:45:28,620 --> 01:45:31,750
 

4055
01:45:28,630 --> 01:45:33,140
 segment to to train to every time we

4056
01:45:31,740 --> 01:45:33,140
 

4057
01:45:31,750 --> 01:45:36,800
 only train the

4058
01:45:33,130 --> 01:45:36,800
 

4059
01:45:33,140 --> 01:45:39,350
 great the train over the using of the

4060
01:45:36,790 --> 01:45:39,350
 

4061
01:45:36,800 --> 01:45:41,660
 gradients of the current segment but we

4062
01:45:39,340 --> 01:45:41,660
 

4063
01:45:39,350 --> 01:45:44,510
 still cache and make use of the result

4064
01:45:41,650 --> 01:45:44,510
 

4065
01:45:41,660 --> 01:45:46,310
 from a previous segment to do the

4066
01:45:44,500 --> 01:45:46,310
 

4067
01:45:44,510 --> 01:45:49,280
 trainer training so this is also in

4068
01:45:46,300 --> 01:45:49,280
 

4069
01:45:46,310 --> 01:45:51,710
 spirit very similar to the idea of PBT G

4070
01:45:49,270 --> 01:45:51,710
 

4071
01:45:49,280 --> 01:45:54,590
 and since this time the context

4072
01:45:51,700 --> 01:45:54,590
 

4073
01:45:51,710 --> 01:45:56,840
 information is able to flow across the

4074
01:45:54,580 --> 01:45:56,840
 

4075
01:45:54,590 --> 01:45:59,210
 consecutive segments then during the

4076
01:45:56,830 --> 01:45:59,210
 

4077
01:45:56,840 --> 01:46:02,030
 testing we can just feeling a very long

4078
01:45:59,200 --> 01:46:02,030
 

4079
01:45:59,210 --> 01:46:04,700
 sequence and and predict the tokens of

4080
01:46:02,020 --> 01:46:04,700
 

4081
01:46:02,030 --> 01:46:09,250
 different hand steps all at once single

4082
01:46:04,690 --> 01:46:09,250
 

4083
01:46:04,700 --> 01:46:12,830
 pass so in this way it it is a way to

4084
01:46:09,240 --> 01:46:12,830
 

4085
01:46:09,250 --> 01:46:16,120
 resolve the context fragmentation

4086
01:46:12,820 --> 01:46:16,120
 

4087
01:46:12,830 --> 01:46:18,160
 problem and also the the inference

4088
01:46:16,110 --> 01:46:18,160
 

4089
01:46:16,120 --> 01:46:23,810
 acceleration doing the inference time

4090
01:46:18,150 --> 01:46:23,810
 

4091
01:46:18,160 --> 01:46:26,870
 and on the other alternative we can

4092
01:46:23,800 --> 01:46:26,870
 

4093
01:46:23,810 --> 01:46:29,960
 actually try to specify the attention

4094
01:46:26,860 --> 01:46:29,960
 

4095
01:46:26,870 --> 01:46:32,480
 connections so the so recorded during

4096
01:46:29,950 --> 01:46:32,480
 

4097
01:46:29,960 --> 01:46:34,670
 the decoding time like at the time step

4098
01:46:32,470 --> 01:46:34,670
 

4099
01:46:32,480 --> 01:46:37,430
 five you probably you can only attend to

4100
01:46:34,660 --> 01:46:37,430
 

4101
01:46:34,670 --> 01:46:39,620
 the generated token at hand step one two

4102
01:46:37,420 --> 01:46:39,620
 

4103
01:46:37,430 --> 01:46:42,890
 three four five but on the other hand

4104
01:46:39,610 --> 01:46:42,890
 

4105
01:46:39,620 --> 01:46:44,900
 why should we always attend to all the

4106
01:46:42,880 --> 01:46:44,900
 

4107
01:46:42,890 --> 01:46:46,910
 generated tokens in the previous or the

4108
01:46:44,890 --> 01:46:46,910
 

4109
01:46:44,900 --> 01:46:49,700
 current time selves so why not we

4110
01:46:46,900 --> 01:46:49,700
 

4111
01:46:46,910 --> 01:46:52,700
 specify such attention Corrections so

4112
01:46:49,690 --> 01:46:52,700
 

4113
01:46:49,700 --> 01:46:55,250
 here the space transformer offer such a

4114
01:46:52,690 --> 01:46:55,250
 

4115
01:46:52,700 --> 01:46:58,250
 way so if you look at the middle of the

4116
01:46:55,240 --> 01:46:58,250
 

4117
01:46:55,250 --> 01:47:01,880
 middle figure we can we have us we can

4118
01:46:58,240 --> 01:47:01,880
 

4119
01:46:58,250 --> 01:47:06,130
 actually specify it by selectively

4120
01:47:01,870 --> 01:47:06,130
 

4121
01:47:01,880 --> 01:47:09,860
 attend to some some certain previous

4122
01:47:06,120 --> 01:47:09,860
 

4123
01:47:06,130 --> 01:47:12,410
 times that token with astride so this

4124
01:47:09,850 --> 01:47:12,410
 

4125
01:47:09,860 --> 01:47:14,780
 stripe offers a way to capture some

4126
01:47:12,400 --> 01:47:14,780
 

4127
01:47:12,410 --> 01:47:16,900
 periodic patterns from possibly from an

4128
01:47:14,770 --> 01:47:16,900
 

4129
01:47:14,780 --> 01:47:20,630
 image or from certain types of music and

4130
01:47:16,890 --> 01:47:20,630
 

4131
01:47:16,900 --> 01:47:22,940
 for text if there's no lack of such a

4132
01:47:20,620 --> 01:47:22,940
 

4133
01:47:20,630 --> 01:47:25,940
 periodic pattern we can just selectively

4134
01:47:22,930 --> 01:47:25,940
 

4135
01:47:22,940 --> 01:47:28,430
 sample some fixed position from the

4136
01:47:25,930 --> 01:47:28,430
 

4137
01:47:25,940 --> 01:47:30,230
 previous generated output but the idea

4138
01:47:28,420 --> 01:47:30,230
 

4139
01:47:28,430 --> 01:47:33,500
 is still to specify the connections

4140
01:47:30,220 --> 01:47:33,500
 

4141
01:47:30,230 --> 01:47:39,110
 between the amount the attention

4142
01:47:33,490 --> 01:47:39,110
 

4143
01:47:33,500 --> 01:47:40,970
 connections so yep before before we move

4144
01:47:39,100 --> 01:47:40,970
 

4145
01:47:39,110 --> 01:47:43,330
 on to next so do we have any questions

4146
01:47:40,960 --> 01:47:43,330
 

4147
01:47:40,970 --> 01:47:43,330
 so far

4148
01:47:45,330 --> 01:47:45,330
 

4149
01:47:45,340 --> 01:47:49,880
 Hey

4150
01:47:46,990 --> 01:47:49,880
 

4151
01:47:47,000 --> 01:47:52,400
 so in the transformer paper one key

4152
01:47:49,870 --> 01:47:52,400
 

4153
01:47:49,880 --> 01:47:54,050
 piece seems to be the positional

4154
01:47:52,390 --> 01:47:54,050
 

4155
01:47:52,400 --> 01:47:57,230
 embeddings which are used for

4156
01:47:54,040 --> 01:47:57,230
 

4157
01:47:54,050 --> 01:48:00,680
 representing temporal ordering the paper

4158
01:47:57,220 --> 01:48:00,680
 

4159
01:47:57,230 --> 01:48:02,540
 is kind of light on details about how

4160
01:48:00,670 --> 01:48:02,540
 

4161
01:48:00,680 --> 01:48:07,280
 they came up with the sinusoid form for

4162
01:48:02,530 --> 01:48:07,280
 

4163
01:48:02,540 --> 01:48:08,870
 it how important it is and is there any

4164
01:48:07,270 --> 01:48:08,870
 

4165
01:48:07,280 --> 01:48:11,960
 room for improvement there what are your

4166
01:48:08,860 --> 01:48:11,960
 

4167
01:48:08,870 --> 01:48:14,960
 thoughts yes so in the paper they use

4168
01:48:11,950 --> 01:48:14,960
 

4169
01:48:11,960 --> 01:48:17,060
 the sine cosine functions for the

4170
01:48:14,950 --> 01:48:17,060
 

4171
01:48:14,960 --> 01:48:20,290
 positional embedding and actually when

4172
01:48:17,050 --> 01:48:20,290
 

4173
01:48:17,060 --> 01:48:22,790
 you if you if so and you also have the

4174
01:48:20,280 --> 01:48:22,790
 

4175
01:48:20,290 --> 01:48:26,420
 the hyper printers depending on the

4176
01:48:22,780 --> 01:48:26,420
 

4177
01:48:22,790 --> 01:48:29,000
 position to control the period of such a

4178
01:48:26,410 --> 01:48:29,000
 

4179
01:48:26,420 --> 01:48:32,030
 sine cosine periodic functions so these

4180
01:48:28,990 --> 01:48:32,030
 

4181
01:48:29,000 --> 01:48:35,000
 actually offer the different ways to to

4182
01:48:32,020 --> 01:48:35,000
 

4183
01:48:32,030 --> 01:48:39,050
 view the positions at multiple different

4184
01:48:34,990 --> 01:48:39,050
 

4185
01:48:35,000 --> 01:48:41,840
 damage dimensions of the positional

4186
01:48:39,040 --> 01:48:41,840
 

4187
01:48:39,050 --> 01:48:44,390
 embedding actually we have more I

4188
01:48:41,830 --> 01:48:44,390
 

4189
01:48:41,840 --> 01:48:48,050
 detailed and I are more details of the

4190
01:48:44,380 --> 01:48:48,050
 

4191
01:48:44,390 --> 01:48:50,989
 position and vary in the d2l a I link so

4192
01:48:48,040 --> 01:48:50,989
 

4193
01:48:48,050 --> 01:48:57,770
 it probably can look at the section 903

4194
01:48:50,979 --> 01:48:57,770
 

4195
01:48:50,989 --> 01:48:59,900
 we have the details there yeah alright

4196
01:48:57,760 --> 01:48:59,900
 

4197
01:48:57,770 --> 01:49:02,630
 so I have a very basic question about

4198
01:48:59,890 --> 01:49:02,630
 

4199
01:48:59,900 --> 01:49:05,570
 the output size that we use in

4200
01:49:02,620 --> 01:49:05,570
 

4201
01:49:02,630 --> 01:49:07,640
 translation models like you said that it

4202
01:49:05,560 --> 01:49:07,640
 

4203
01:49:05,570 --> 01:49:11,570
 is typically equal to the size of the

4204
01:49:07,630 --> 01:49:11,570
 

4205
01:49:07,640 --> 01:49:14,500
 embeddings right but can we reduce it

4206
01:49:11,560 --> 01:49:14,500
 

4207
01:49:11,570 --> 01:49:16,910
 was much smaller set of words based on

4208
01:49:14,490 --> 01:49:16,910
 

4209
01:49:14,500 --> 01:49:19,820
 whatever the sentence is there for

4210
01:49:16,900 --> 01:49:19,820
 

4211
01:49:16,910 --> 01:49:22,670
 example if I want to translate I'm going

4212
01:49:19,810 --> 01:49:22,670
 

4213
01:49:19,820 --> 01:49:25,310
 to the market you know what these words

4214
01:49:22,660 --> 01:49:25,310
 

4215
01:49:22,670 --> 01:49:27,860
 are in some language like German for

4216
01:49:25,300 --> 01:49:27,860
 

4217
01:49:25,310 --> 01:49:30,110
 every word you can have a mapping so

4218
01:49:27,850 --> 01:49:30,110
 

4219
01:49:27,860 --> 01:49:31,970
 instead of having to compute the

4220
01:49:30,100 --> 01:49:31,970
 

4221
01:49:30,110 --> 01:49:33,739
 probability of all the words in the

4222
01:49:31,960 --> 01:49:33,739
 

4223
01:49:31,970 --> 01:49:36,050
 German language you could possibly

4224
01:49:33,729 --> 01:49:36,050
 

4225
01:49:33,739 --> 01:49:38,630
 reduce it to much smaller set of words

4226
01:49:36,040 --> 01:49:38,630
 

4227
01:49:36,050 --> 01:49:41,270
 now I'm wondering if we do this will it

4228
01:49:38,620 --> 01:49:41,270
 

4229
01:49:38,630 --> 01:49:44,930
 lead to a significant reduction in the

4230
01:49:41,260 --> 01:49:44,930
 

4231
01:49:41,270 --> 01:49:48,410
 computational cost actually I will have

4232
01:49:44,920 --> 01:49:48,410
 

4233
01:49:44,930 --> 01:49:51,320
 a better idea than just try to predict

4234
01:49:48,400 --> 01:49:51,320
 

4235
01:49:48,410 --> 01:49:53,810
 over the draw over the drawer for kuvira

4236
01:49:51,310 --> 01:49:53,810
 

4237
01:49:51,320 --> 01:49:56,690
 set so the simple idea is to use is to

4238
01:49:53,800 --> 01:49:56,690
 

4239
01:49:53,810 --> 01:49:58,970
 use the PPE which is a byte

4240
01:49:56,680 --> 01:49:58,970
 

4241
01:49:56,690 --> 01:50:02,290
 in coding so in this case you probably

4242
01:49:58,960 --> 01:50:02,290
 

4243
01:49:58,970 --> 01:50:04,400
 can try to formulate the tokens based on

4244
01:50:02,280 --> 01:50:04,400
 

4245
01:50:02,290 --> 01:50:06,830
 based on the frequency or other

4246
01:50:04,390 --> 01:50:06,830
 

4247
01:50:04,400 --> 01:50:08,510
 heuristics so the in this way you will

4248
01:50:06,820 --> 01:50:08,510
 

4249
01:50:06,830 --> 01:50:10,130
 give you a immediately benefit of

4250
01:50:08,500 --> 01:50:10,130
 

4251
01:50:08,510 --> 01:50:12,350
 reducing the side of the vocabulary

4252
01:50:10,120 --> 01:50:12,350
 

4253
01:50:10,130 --> 01:50:15,020
 which can hopefully accelerate the

4254
01:50:12,340 --> 01:50:15,020
 

4255
01:50:12,350 --> 01:50:17,600
 computation so pair the bytes per

4256
01:50:15,010 --> 01:50:17,600
 

4257
01:50:15,020 --> 01:50:20,420
 pairwise encoding we also provide some

4258
01:50:17,590 --> 01:50:20,420
 

4259
01:50:17,600 --> 01:50:25,820
 contests in t2 t2 area you can you can

4260
01:50:20,410 --> 01:50:25,820
 

4261
01:50:20,420 --> 01:50:29,720
 check that okay so then I'll pass on to

4262
01:50:25,810 --> 01:50:29,720
 

4263
01:50:25,820 --> 01:50:40,400
 my colleague Alex so he may share more

4264
01:50:29,710 --> 01:50:40,400
 

4265
01:50:29,720 --> 01:50:42,020
 paper ideas with you okay thanks so so

4266
01:50:40,390 --> 01:50:42,020
 

4267
01:50:40,400 --> 01:50:44,750
 given that we're a little bit short on

4268
01:50:42,010 --> 01:50:44,750
 

4269
01:50:42,020 --> 01:50:46,850
 time let me just quickly go through a

4270
01:50:44,740 --> 01:50:46,850
 

4271
01:50:44,750 --> 01:50:49,670
 couple of open questions and a bit more

4272
01:50:46,840 --> 01:50:49,670
 

4273
01:50:46,850 --> 01:50:52,670
 supplementary material because the

4274
01:50:49,660 --> 01:50:52,670
 

4275
01:50:49,670 --> 01:50:54,950
 gentlemen who run the audio they

4276
01:50:52,660 --> 01:50:54,950
 

4277
01:50:52,670 --> 01:50:56,870
 actually here they get paid for the time

4278
01:50:54,940 --> 01:50:56,870
 

4279
01:50:54,950 --> 01:51:01,420
 of that year here so they need to be out

4280
01:50:56,860 --> 01:51:01,420
 

4281
01:50:56,870 --> 01:51:04,490
 of here by 6:00 um so one I think very

4282
01:51:01,410 --> 01:51:04,490
 

4283
01:51:01,420 --> 01:51:06,560
 burning open question that we have and

4284
01:51:04,480 --> 01:51:06,560
 

4285
01:51:04,490 --> 01:51:09,350
 any theorist here in the room who might

4286
01:51:06,550 --> 01:51:09,350
 

4287
01:51:06,560 --> 01:51:12,200
 be willing to tackle this is the issue

4288
01:51:09,340 --> 01:51:12,200
 

4289
01:51:09,350 --> 01:51:13,910
 of function complexity so we've seen

4290
01:51:12,190 --> 01:51:13,910
 

4291
01:51:12,200 --> 01:51:16,760
 that attention actually works really

4292
01:51:13,900 --> 01:51:16,760
 

4293
01:51:13,910 --> 01:51:19,430
 well and with comparatively simple

4294
01:51:16,750 --> 01:51:19,430
 

4295
01:51:16,760 --> 01:51:21,800
 functions we can actually model rather

4296
01:51:19,420 --> 01:51:21,800
 

4297
01:51:19,430 --> 01:51:24,260
 which dependencies and that's because

4298
01:51:21,790 --> 01:51:24,260
 

4299
01:51:21,800 --> 01:51:28,190
 you basically learn the mechanism now

4300
01:51:24,250 --> 01:51:28,190
 

4301
01:51:24,260 --> 01:51:29,660
 the problem is capturing and quantifying

4302
01:51:28,180 --> 01:51:29,660
 

4303
01:51:28,190 --> 01:51:32,120
 the function class and a function

4304
01:51:29,650 --> 01:51:32,120
 

4305
01:51:29,660 --> 01:51:33,470
 complexity is non-trivial so for

4306
01:51:32,110 --> 01:51:33,470
 

4307
01:51:32,120 --> 01:51:35,360
 instance if you look at iterated

4308
01:51:33,460 --> 01:51:35,360
 

4309
01:51:33,470 --> 01:51:36,950
 function systems then even some very

4310
01:51:35,350 --> 01:51:36,950
 

4311
01:51:35,360 --> 01:51:39,290
 simple functions can give you you know

4312
01:51:36,940 --> 01:51:39,290
 

4313
01:51:36,950 --> 01:51:40,910
 your code you know attract you know

4314
01:51:39,280 --> 01:51:40,910
 

4315
01:51:39,290 --> 01:51:43,330
 strange attractors and all of that so

4316
01:51:40,900 --> 01:51:43,330
 

4317
01:51:40,910 --> 01:51:46,790
 analyzing this is probably going to be

4318
01:51:43,320 --> 01:51:46,790
 

4319
01:51:43,330 --> 01:51:48,560
 non-trivial the other thing is of course

4320
01:51:46,780 --> 01:51:48,560
 

4321
01:51:46,790 --> 01:51:50,210
 you know how do you actually regularize

4322
01:51:48,550 --> 01:51:50,210
 

4323
01:51:48,560 --> 01:51:53,750
 those things do we need a specific

4324
01:51:50,200 --> 01:51:53,750
 

4325
01:51:50,210 --> 01:51:54,980
 mechanism to regularize attention also

4326
01:51:53,740 --> 01:51:54,980
 

4327
01:51:53,750 --> 01:51:57,440
 the other thing is how do we interpret

4328
01:51:54,970 --> 01:51:57,440
 

4329
01:51:54,980 --> 01:51:59,090
 things and there's some very nice recent

4330
01:51:57,430 --> 01:51:59,090
 

4331
01:51:57,440 --> 01:52:02,180
 work that just came out like in the past

4332
01:51:59,080 --> 01:52:02,180
 

4333
01:51:59,090 --> 01:52:04,490
 few weeks one by u8 and manning and then

4334
01:52:02,170 --> 01:52:04,490
 

4335
01:52:02,180 --> 01:52:06,590
 one by kernan at all where they actually

4336
01:52:04,480 --> 01:52:06,590
 

4337
01:52:04,490 --> 01:52:07,820
 analyzed things for pert and essentially

4338
01:52:06,580 --> 01:52:07,820
 

4339
01:52:06,590 --> 01:52:09,340
 what they do is they look at the

4340
01:52:07,810 --> 01:52:09,340
 

4341
01:52:07,820 --> 01:52:11,470
 attention weights they embed

4342
01:52:09,330 --> 01:52:11,470
 

4343
01:52:09,340 --> 01:52:13,270
 parse trees and then they regress from

4344
01:52:11,460 --> 01:52:13,270
 

4345
01:52:11,470 --> 01:52:14,710
 attention way to parse trees and then

4346
01:52:13,260 --> 01:52:14,710
 

4347
01:52:13,270 --> 01:52:17,230
 there's a little bit of reasoning which

4348
01:52:14,700 --> 01:52:17,230
 

4349
01:52:14,710 --> 01:52:20,560
 she'll start and it'll to embedding and

4350
01:52:17,220 --> 01:52:20,560
 

4351
01:52:17,230 --> 01:52:22,060
 they call it like distance square

4352
01:52:20,550 --> 01:52:22,060
 

4353
01:52:20,560 --> 01:52:24,880
 embedding but it's really the two norm

4354
01:52:22,050 --> 01:52:24,880
 

4355
01:52:22,060 --> 01:52:27,100
 that matters but this is where things

4356
01:52:24,870 --> 01:52:27,100
 

4357
01:52:24,880 --> 01:52:28,720
 map quite work quite nicely which

4358
01:52:27,090 --> 01:52:28,720
 

4359
01:52:27,100 --> 01:52:30,430
 actually you would kind of expect that

4360
01:52:28,710 --> 01:52:30,430
 

4361
01:52:28,720 --> 01:52:33,850
 if you regress between two things that

4362
01:52:30,420 --> 01:52:33,850
 

4363
01:52:30,430 --> 01:52:37,060
 you'll get something but I think more

4364
01:52:33,840 --> 01:52:37,060
 

4365
01:52:33,850 --> 01:52:40,210
 interesting is can we actually use some

4366
01:52:37,050 --> 01:52:40,210
 

4367
01:52:37,060 --> 01:52:41,980
 ideas from LP for instance to guide the

4368
01:52:40,200 --> 01:52:41,980
 

4369
01:52:40,210 --> 01:52:44,350
 steps within the reasoning within the

4370
01:52:41,970 --> 01:52:44,350
 

4371
01:52:41,980 --> 01:52:47,500
 attention is this structure that we can

4372
01:52:44,340 --> 01:52:47,500
 

4373
01:52:44,350 --> 01:52:49,600
 use so to some extent the sparse

4374
01:52:47,490 --> 01:52:49,600
 

4375
01:52:47,500 --> 01:52:53,020
 transformice paper takes a first step

4376
01:52:49,590 --> 01:52:53,020
 

4377
01:52:49,600 --> 01:52:55,480
 where they explicitly hack you know one

4378
01:52:53,010 --> 01:52:55,480
 

4379
01:52:53,020 --> 01:52:57,040
 hip that hat looks at the past K steps

4380
01:52:55,470 --> 01:52:57,040
 

4381
01:52:55,480 --> 01:52:59,590
 and the other one lip that looks at

4382
01:52:57,030 --> 01:52:59,590
 

4383
01:52:57,040 --> 01:53:02,410
 steps every K steps into the past and

4384
01:52:59,580 --> 01:53:02,410
 

4385
01:52:59,590 --> 01:53:03,880
 thus you can factorize things nicely but

4386
01:53:02,400 --> 01:53:03,880
 

4387
01:53:02,410 --> 01:53:05,560
 can we do this a little bit more

4388
01:53:03,870 --> 01:53:05,560
 

4389
01:53:03,880 --> 01:53:08,100
 systematically because right now this is

4390
01:53:05,550 --> 01:53:08,100
 

4391
01:53:05,560 --> 01:53:12,400
 essentially you know trial and error

4392
01:53:08,090 --> 01:53:12,400
 

4393
01:53:08,100 --> 01:53:15,240
 another issue is well you know for large

4394
01:53:12,390 --> 01:53:15,240
 

4395
01:53:12,400 --> 01:53:17,920
 state spaces well can we make them

4396
01:53:15,230 --> 01:53:17,920
 

4397
01:53:15,240 --> 01:53:20,080
 specialize can we have something that's

4398
01:53:17,910 --> 01:53:20,080
 

4399
01:53:17,920 --> 01:53:22,210
 you know pseudo-random Dane's the

4400
01:53:20,070 --> 01:53:22,210
 

4401
01:53:20,080 --> 01:53:23,740
 squadron's are a really neat trick and

4402
01:53:22,200 --> 01:53:23,740
 

4403
01:53:22,210 --> 01:53:25,720
 the fact that they work actually is a

4404
01:53:23,730 --> 01:53:25,720
 

4405
01:53:23,740 --> 01:53:28,480
 good point of that there's something to

4406
01:53:25,710 --> 01:53:28,480
 

4407
01:53:25,720 --> 01:53:31,210
 be gained here right that rather than

4408
01:53:28,470 --> 01:53:31,210
 

4409
01:53:28,480 --> 01:53:33,400
 having you know a full four by four

4410
01:53:31,200 --> 01:53:33,400
 

4411
01:53:31,210 --> 01:53:35,020
 matrix you can traumatize it with a

4412
01:53:33,390 --> 01:53:35,020
 

4413
01:53:33,400 --> 01:53:37,000
 lower dimensional just four-dimensional

4414
01:53:35,010 --> 01:53:37,000
 

4415
01:53:35,020 --> 01:53:39,430
 space and you still get most of the

4416
01:53:36,990 --> 01:53:39,430
 

4417
01:53:37,000 --> 01:53:42,100
 benefits can we do something with maybe

4418
01:53:39,420 --> 01:53:42,100
 

4419
01:53:39,430 --> 01:53:44,890
 pseudo-random dense matrices or maybe we

4420
01:53:42,090 --> 01:53:44,890
 

4421
01:53:42,100 --> 01:53:48,700
 can run sparse structure the other thing

4422
01:53:44,880 --> 01:53:48,700
 

4423
01:53:44,890 --> 01:53:50,680
 is and this is probably the thing that

4424
01:53:48,690 --> 01:53:50,680
 

4425
01:53:48,700 --> 01:53:53,800
 will make a very significant

4426
01:53:50,670 --> 01:53:53,800
 

4427
01:53:50,680 --> 01:53:57,780
 breakthrough in terms of efficiency can

4428
01:53:53,790 --> 01:53:57,780
 

4429
01:53:53,800 --> 01:54:00,370
 be used attention for power efficiency

4430
01:53:57,770 --> 01:54:00,370
 

4431
01:53:57,780 --> 01:54:02,920
 so after all I mean this is part of the

4432
01:54:00,360 --> 01:54:02,920
 

4433
01:54:00,370 --> 01:54:04,990
 reason why animals use attention right

4434
01:54:02,910 --> 01:54:04,990
 

4435
01:54:02,920 --> 01:54:06,940
 because if I'm looking forward and I'm

4436
01:54:04,980 --> 01:54:06,940
 

4437
01:54:04,990 --> 01:54:08,320
 looking at you guys I'm not really

4438
01:54:06,930 --> 01:54:08,320
 

4439
01:54:06,940 --> 01:54:09,640
 paying it attention to anything that's

4440
01:54:08,310 --> 01:54:09,640
 

4441
01:54:08,320 --> 01:54:11,580
 happening on the sides of my brain

4442
01:54:09,630 --> 01:54:11,580
 

4443
01:54:09,640 --> 01:54:14,260
 switches off the pieces on the side

4444
01:54:11,570 --> 01:54:14,260
 

4445
01:54:11,580 --> 01:54:16,720
 unless a saber-toothed tiger tiger

4446
01:54:14,250 --> 01:54:16,720
 

4447
01:54:14,260 --> 01:54:18,320
 wasn't going to attach me attack me in

4448
01:54:16,710 --> 01:54:18,320
 

4449
01:54:16,720 --> 01:54:21,320
 which case well lateral motion

4450
01:54:18,310 --> 01:54:21,320
 

4451
01:54:18,320 --> 01:54:23,420
 would kick in but it seems I am saving

4452
01:54:21,310 --> 01:54:23,420
 

4453
01:54:21,320 --> 01:54:27,110
 energy by just focusing on giving this

4454
01:54:23,410 --> 01:54:27,110
 

4455
01:54:23,420 --> 01:54:29,330
 talk also can we reduce memory footprint

4456
01:54:27,100 --> 01:54:29,330
 

4457
01:54:27,110 --> 01:54:30,980
 of course there's a very low hanging

4458
01:54:29,320 --> 01:54:30,980
 

4459
01:54:29,330 --> 01:54:33,350
 fruit and this is essentially the

4460
01:54:30,970 --> 01:54:33,350
 

4461
01:54:30,980 --> 01:54:35,690
 parallel for and all undergrads in your

4462
01:54:33,340 --> 01:54:35,690
 

4463
01:54:33,350 --> 01:54:37,130
 lab to take all the papers that haven't

4464
01:54:35,680 --> 01:54:37,130
 

4465
01:54:35,690 --> 01:54:39,800
 used the tension of transformers and

4466
01:54:37,120 --> 01:54:39,800
 

4467
01:54:37,130 --> 01:54:42,380
 birth yet and rewrite them and maybe you

4468
01:54:39,790 --> 01:54:42,380
 

4469
01:54:39,800 --> 01:54:44,900
 can get them published somewhere um so

4470
01:54:42,370 --> 01:54:44,900
 

4471
01:54:42,380 --> 01:54:46,520
 these are I think some of the open

4472
01:54:44,890 --> 01:54:46,520
 

4473
01:54:44,900 --> 01:54:48,890
 questions I don't really necessarily

4474
01:54:46,510 --> 01:54:48,890
 

4475
01:54:46,520 --> 01:54:50,690
 have a good answer for all or any of

4476
01:54:48,880 --> 01:54:50,690
 

4477
01:54:48,890 --> 01:54:54,340
 them but I think this is this might

4478
01:54:50,680 --> 01:54:54,340
 

4479
01:54:50,690 --> 01:54:57,230
 actually help now a couple of resources

4480
01:54:54,330 --> 01:54:57,230
 

4481
01:54:54,340 --> 01:55:02,630
 so after already mentioned this so this

4482
01:54:57,220 --> 01:55:02,630
 

4483
01:54:57,230 --> 01:55:04,700
 is book d2l I'm essentially you know 152

4484
01:55:02,620 --> 01:55:04,700
 

4485
01:55:02,630 --> 01:55:06,590
 Peter notebooks all open source if you

4486
01:55:04,690 --> 01:55:06,590
 

4487
01:55:04,700 --> 01:55:08,330
 don't like something send us a pull

4488
01:55:06,580 --> 01:55:08,330
 

4489
01:55:06,590 --> 01:55:11,750
 request on github and we'll incorporate

4490
01:55:08,320 --> 01:55:11,750
 

4491
01:55:08,330 --> 01:55:13,850
 it within hours people are using it

4492
01:55:11,740 --> 01:55:13,850
 

4493
01:55:11,750 --> 01:55:15,620
 actually as textbook and you can get the

4494
01:55:13,840 --> 01:55:15,620
 

4495
01:55:13,850 --> 01:55:18,500
 slides if you have to teach a class in

4496
01:55:15,610 --> 01:55:18,500
 

4497
01:55:15,620 --> 01:55:21,860
 deep learning just download the stuff

4498
01:55:18,490 --> 01:55:21,860
 

4499
01:55:18,500 --> 01:55:23,510
 and reuse it and we're cool with

4500
01:55:21,850 --> 01:55:23,510
 

4501
01:55:21,860 --> 01:55:25,490
 anything so there to be the notebooks

4502
01:55:23,500 --> 01:55:25,490
 

4503
01:55:23,510 --> 01:55:31,880
 and you can look at it on your mobile

4504
01:55:25,480 --> 01:55:31,880
 

4505
01:55:25,490 --> 01:55:33,410
 phone yeah and of course this source so

4506
01:55:31,870 --> 01:55:33,410
 

4507
01:55:31,880 --> 01:55:35,600
 if you go to github and you don't like

4508
01:55:33,400 --> 01:55:35,600
 

4509
01:55:33,410 --> 01:55:38,080
 something you send us a pull request and

4510
01:55:35,590 --> 01:55:38,080
 

4511
01:55:35,600 --> 01:55:41,920
 you can kill trees and print it out

4512
01:55:38,070 --> 01:55:41,920
 

4513
01:55:38,080 --> 01:55:45,410
 there's a last important that we taught

4514
01:55:41,910 --> 01:55:45,410
 

4515
01:55:41,920 --> 01:55:47,150
 120 videos and yeah you have to listen

4516
01:55:45,400 --> 01:55:47,150
 

4517
01:55:45,410 --> 01:55:49,450
 to me so please do something better on

4518
01:55:47,140 --> 01:55:49,450
 

4519
01:55:47,150 --> 01:55:53,030
 your own and put your own videos up and

4520
01:55:49,440 --> 01:55:53,030
 

4521
01:55:49,450 --> 01:55:56,300
 so to conclude all of that well so

4522
01:55:53,020 --> 01:55:56,300
 

4523
01:55:53,030 --> 01:55:58,880
 there's actually a larger ecosystem of

4524
01:55:56,290 --> 01:55:58,880
 

4525
01:55:56,300 --> 01:56:01,400
 tools that you know sit behind this

4526
01:55:58,870 --> 01:56:01,400
 

4527
01:55:58,880 --> 01:56:04,190
 so it's tools for computer vision glue

4528
01:56:01,390 --> 01:56:04,190
 

4529
01:56:01,400 --> 01:56:06,260
 on CV glue on TS include an NLP for

4530
01:56:04,180 --> 01:56:06,260
 

4531
01:56:04,190 --> 01:56:10,520
 computer vision NLP and time series a

4532
01:56:06,250 --> 01:56:10,520
 

4533
01:56:06,260 --> 01:56:12,350
 deep learning composite EVM and DGL deep

4534
01:56:10,510 --> 01:56:12,350
 

4535
01:56:10,520 --> 01:56:15,440
 learning on graphs and of course

4536
01:56:12,340 --> 01:56:15,440
 

4537
01:56:12,350 --> 01:56:18,650
 underlying all of that imagenet um so if

4538
01:56:15,430 --> 01:56:18,650
 

4539
01:56:15,440 --> 01:56:21,590
 you like what you saw have a look there

4540
01:56:18,640 --> 01:56:21,590
 

4541
01:56:18,650 --> 01:56:24,320
 and enjoy and thanks for coming along

4542
01:56:21,580 --> 01:56:24,320
 

4543
01:56:21,590 --> 01:56:25,460
 and while suffering through all of this

4544
01:56:24,310 --> 01:56:25,460
 

4545
01:56:24,320 --> 01:56:29,249
 so thanks

4546
01:56:25,450 --> 01:56:29,249
 

4547
01:56:25,460 --> 01:56:29,249
[Applause]

4548
01:56:30,850 --> 01:56:30,850
 

4549
01:56:30,860 --> 01:56:36,320
 and yeah online there's references and

4550
01:56:34,720 --> 01:56:36,320
 

4551
01:56:34,730 --> 01:56:40,540
 other stuff so you'll find all of that

4552
01:56:36,310 --> 01:56:40,540
 

4553
01:56:36,320 --> 01:56:40,540
 there okay thanks